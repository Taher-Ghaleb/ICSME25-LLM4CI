ID,URL,Title,Description,Code,LLM_YML_Output,Time
1,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-net-to-azure-app-service,Deploying .NET to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy a .NET project to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If the path to your project is not the repository root, change AZURE_WEBAPP_PACKAGE_PATH . If you use a version of .NET other than 5 , change DOTNET_VERSION . If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and deploy ASP.Net Core app to an Azure Web App

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name
  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root
  DOTNET_VERSION: '5'                 # set this to the .NET Core version to use

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Set up dependency caching for faster builds
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Build with dotnet
        run: dotnet build --configuration Release

      - name: dotnet publish
        run: dotnet publish -c Release -o ${{env.DOTNET_ROOT}}/myapp

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: .net-app
          path: ${{env.DOTNET_ROOT}}/myapp

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: .net-app

      - name: Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}","on:
  push:
    branches:
      - main
env:
  AZURE_WEBAPP_NAME: your-webapp-name
  AZURE_WEBAPP_PACKAGE_PATH: .
  DOTNET_VERSION: '5'
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up .NET
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Build with dotnet
      run: dotnet build --configuration Release
    - name: Deploy to Azure WebApp
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
",0
2,https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions,About workflows - Advanced workflow features - Storing secrets,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your workflows use sensitive data, such as passwords or certificates, you can save these in GitHub as secrets and then use them in your workflows as environment variables. This means that you will be able to create and share workflows without having to embed sensitive values directly in the workflow's YAML source. This example job demonstrates how to reference an existing secret as an environment variable, and send it as a parameter to an example command.","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Retrieve secret
        env:
          super_secret: ${{ secrets.SUPERSECRET }}
        run: |
          example-command ""$super_secret""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret
        run: echo ""Using secret""
        env:
          SECRET_VALUE: ${{ secrets.MY_SECRET }}
",0
3,https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions,About workflows - Advanced workflow features - Creating dependent jobs,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. By default, the jobs in your workflow all run in parallel at the same time. If you have a job that must only run after another job has completed, you can use the needs keyword to create this dependency. If one of the jobs fails, all dependent jobs are skipped; however, if you need the jobs to continue, you can define this using the if conditional statement. In this example, the setup , build , and test jobs run in series, with build and test being dependent on the successful completion of the job that precedes them:","jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: ./setup_server.sh
  build:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - run: ./build_server.sh
  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: ./test_server.sh","jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Setting up environment""

  build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - run: echo ""Building the project""

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo ""Running tests""
",0
4,https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions,About workflows - Advanced workflow features - Using a matrix,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. The matrix is created using the strategy keyword, which receives the build options as an array. For example, this matrix will run the job multiple times, using different versions of Node.js:","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [10, 12, 14]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - run: npm test
",0
5,https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions,About workflows - Advanced workflow features - Caching dependencies,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your jobs regularly reuse dependencies, you can consider caching these files to help improve performance. Once the cache is created, it is available to all workflows in the same repository. This example demonstrates how to cache the ~/.npm directory:","jobs:
  example-job:
    steps:
      - name: Cache node modules
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache NPM dependencies
        uses: actions/cache@v2
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-
      - name: Install dependencies
        run: npm install
",0
6,https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions,About workflows - Advanced workflow features - Using databases and service containers,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your job requires a database or cache service, you can use the services keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can use services to create a postgres container, and then use node to connect to the service.","jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node:20-bookworm-slim
    services:
      postgres:
        image: postgres
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: npm ci
      - name: Connect to PostgreSQL
        run: node client.js
        env:
          POSTGRES_HOST: postgres
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Install dependencies
        run: npm install

      - name: Run database script
        env:
          PGHOST: localhost
          PGUSER: postgres
          PGPASSWORD: postgres
          PGDATABASE: postgres
        run: node script.js
",0
7,https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions,About workflows - Advanced workflow features - Using labels to route workflows,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If you want to be sure that a particular type of runner will process your job, you can use labels to control where jobs are executed. You can assign labels to a self-hosted runner in addition to their default label of self-hosted . Then, you can refer to these labels in your YAML workflow, ensuring that the job is routed in a predictable way. GitHub-hosted runners have predefined labels assigned. This example shows how a workflow can use labels to specify the required runner:","jobs:
  example-job:
    runs-on: [self-hosted, linux, x64, gpu]","jobs:
  example-job:
    runs-on: [self-hosted, custom-label]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on a self-hosted runner with a custom label""
",0
8,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for binaries,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the binary you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write","permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up JDK
        uses: actions/setup-java@v2
        with:
          java-version: '11'

      - name: Build binary
        run: ./gradlew build

      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: my-binary
          path: build/libs/my-binary.jar

      - name: Generate attestation
        uses: slsa-framework/slsa-github-generator@v1
        with:
          artifact_path: build/libs/my-binary.jar
",0
9,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for binaries,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the binary you would like to attest, add the following permissions. After the step where the binary has been built, add the following step.","- name: Generate artifact attestation
  uses: actions/attest-build-provenance@v2
  with:
    subject-path: 'PATH/TO/ARTIFACT'","permissions:
  id-token: write
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Build binary
        run: npm run build

      - name: Generate artifact attestation
        uses: slsa-framework/slsa-github-generator@v1
        with:
          artifact_path: ./path/to/binary
",0
10,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for container images,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the container image you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write
  packages: write","permissions:
  contents: read
  id-token: write
  packages: write
  actions: read
",0
11,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for container images,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the container image you would like to attest, add the following permissions. After the step where the image has been built, add the following step.","- name: Generate artifact attestation
  uses: actions/attest-build-provenance@v2
  with:
    subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
    subject-digest: 'sha256:fedcba0...'
    push-to-registry: true","permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: user/repo:tag

    - name: Generate build provenance
      uses: slsa-framework/slsa-github-generator@v1
      with:
        artifact_type: container
        artifact_name: user/repo:tag
",0
12,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for binaries,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the binary you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write","permissions:
  contents: read
  id-token: write
  packages: read
  actions: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Java
        uses: actions/setup-java@v2
        with:
          java-version: '11'

      - name: Build with Gradle
        run: ./gradlew build

      - name: Generate SBOM
        run: ./gradlew generateSbom

      - name: Upload SBOM
        uses: actions/upload-artifact@v2
        with:
          name: sbom
          path: build/reports/sbom

      - name: Attest SBOM
        uses: slsa-framework/slsa-github-generator@v1
        with:
          artifact_path: build/reports/sbom
          attestation_type: sbom
",0
13,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for binaries,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the binary you would like to attest, add the following permissions. After the step where the binary has been built, add the following step.","- name: Generate SBOM attestation
  uses: actions/attest-sbom@v1
  with:
    subject-path: 'PATH/TO/ARTIFACT'
    sbom-path: 'PATH/TO/SBOM'","permissions:
  id-token: write
  contents: read
  actions: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build binary
        run: |
          # Your build commands here

      - name: Generate SBOM attestation
        uses: slsa-framework/slsa-github-generator@v1
        with:
          artifact_path: path/to/your/binary
          sbom_path: path/to/your/sbom
",0
14,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for container images,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the container image you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write
  packages: write","permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build container image
        run: |
          docker build -t my-image:latest .

      - name: Generate SBOM
        run: |
          syft my-image:latest -o json > sbom.json

      - name: Attest SBOM
        uses: slsa-framework/attest-sbom@v1
        with:
          sbom-path: sbom.json
          image: my-image:latest
",0
15,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for container images,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the container image you would like to attest, add the following permissions. After the step where the image has been built, add the following step.","- name: Generate SBOM attestation
  uses: actions/attest-sbom@v1
  with:
    subject-name: ${{ env.REGISTRY }}/PATH/TO/IMAGE
    subject-digest: 'sha256:fedcba0...'
    sbom-path: 'sbom.json'
    push-to-registry: true","permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build container image
      run: |
        docker build -t my-image:latest .

    - name: Generate SBOM attestation
      uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1
      with:
        artifact_type: container
        artifact_name: my-image:latest
",0
16,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/setting-a-default-shell-and-working-directory,Setting a default shell and working directory - Setting default shell and working directory - Example: Set the default shell and working directory,"You can use defaults.run to provide default shell and working-directory options for all run steps in a workflow. You can also set default settings for run that are only available to a job. For more information, see jobs.<job_id>.defaults.run . You cannot use contexts or expressions in this keyword. When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","defaults:
  run:
    shell: bash
    working-directory: ./scripts","jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./my-directory
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
17,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/setting-a-default-shell-and-working-directory,Setting a default shell and working directory - Setting default shell and working directory for a job - Example: Setting default run step options for a job,"Use jobs.<job_id>.defaults.run to provide default shell and working-directory to all run steps in the job. You can provide default shell and working-directory options for all run steps in a job. You can also set default settings for run for the entire workflow. For more information, see defaults.run . These can be overriden at the jobs.<job_id>.defaults.run and jobs.<job_id>.steps[*].run levels. When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","jobs:
  job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts","jobs:
  example_job:
    defaults:
      run:
        shell: bash
        working-directory: ./my-directory
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
18,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Migrating script steps - Azure Pipelines syntax for script steps,"You can run a script or a shell command as a step in a workflow. In Azure Pipelines, script steps can be specified using the script key, or with the bash , powershell , or pwsh keys. Scripts can also be specified as an input to the Bash task or the PowerShell task . In GitHub Actions, all scripts are specified using the run key. To select a particular shell, you can specify the shell key when providing the script. For more information, see Workflow syntax for GitHub Actions . Below is an example of the syntax for each system.","jobs:
  - job: scripts
    pool:
      vmImage: 'windows-latest'
    steps:
      - script: echo ""This step runs in the default shell""
      - bash: echo ""This step runs in bash""
      - pwsh: Write-Host ""This step runs in PowerShell Core""
      - task: PowerShell@2
        inputs:
          script: Write-Host ""This step runs in PowerShell""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run a shell script
        run: echo ""Hello, World!""
        shell: bash

      - name: Run a PowerShell script
        run: Write-Host ""Hello, World!""
        shell: pwsh
",0
19,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Migrating script steps - GitHub Actions syntax for script steps,"You can run a script or a shell command as a step in a workflow. In Azure Pipelines, script steps can be specified using the script key, or with the bash , powershell , or pwsh keys. Scripts can also be specified as an input to the Bash task or the PowerShell task . In GitHub Actions, all scripts are specified using the run key. To select a particular shell, you can specify the shell key when providing the script. For more information, see Workflow syntax for GitHub Actions . Below is an example of the syntax for each system.","jobs:
  scripts:
    runs-on: windows-latest
    steps:
      - run: echo ""This step runs in the default shell""
      - run: echo ""This step runs in bash""
        shell: bash
      - run: Write-Host ""This step runs in PowerShell Core""
        shell: pwsh
      - run: Write-Host ""This step runs in PowerShell""
        shell: powershell","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run a shell script
        run: echo ""Hello, World!""
        shell: bash

      - name: Run a PowerShell script
        run: Write-Host ""Hello, World!""
        shell: pwsh
",0
20,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Differences in the default shell on Windows - Azure Pipelines syntax using CMD by default,"In Azure Pipelines, the default shell for scripts on Windows platforms is the Command shell ( cmd.exe ). In GitHub Actions, the default shell for scripts on Windows platforms is PowerShell. PowerShell has several differences in built-in commands, variable expansion, and flow control. If you're running a simple command, you might be able to run a Command shell script in PowerShell without any changes. But in most cases, you will either need to update your script with PowerShell syntax or instruct GitHub Actions to run the script with the Command shell instead of PowerShell. You can do this by specifying shell as cmd . Below is an example of the syntax for each system.","jobs:
  - job: run_command
    pool:
      vmImage: 'windows-latest'
    steps:
      - script: echo ""This step runs in CMD on Windows by default""","jobs:
  example-job:
    runs-on: windows-latest
    steps:
      - name: Run command in CMD
        run: echo Hello, World!
        shell: cmd
",0
21,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Differences in the default shell on Windows - GitHub Actions syntax for specifying CMD,"In Azure Pipelines, the default shell for scripts on Windows platforms is the Command shell ( cmd.exe ). In GitHub Actions, the default shell for scripts on Windows platforms is PowerShell. PowerShell has several differences in built-in commands, variable expansion, and flow control. If you're running a simple command, you might be able to run a Command shell script in PowerShell without any changes. But in most cases, you will either need to update your script with PowerShell syntax or instruct GitHub Actions to run the script with the Command shell instead of PowerShell. You can do this by specifying shell as cmd . Below is an example of the syntax for each system.","jobs:
  run_command:
    runs-on: windows-latest
    steps:
      - run: echo ""This step runs in PowerShell on Windows by default""
      - run: echo ""This step runs in CMD on Windows explicitly""
        shell: cmd","jobs:
  example-job:
    runs-on: windows-latest
    steps:
      - name: Run command in CMD
        run: echo Hello, World!
        shell: cmd
",0
22,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Migrating conditionals and expression syntax - Azure Pipelines syntax for conditional expressions,"Azure Pipelines and GitHub Actions can both run steps conditionally. In Azure Pipelines, conditional expressions are specified using the condition key. In GitHub Actions, conditional expressions are specified using the if key. Azure Pipelines uses functions within expressions to execute steps conditionally. In contrast, GitHub Actions uses an infix notation. For example, you must replace the eq function in Azure Pipelines with the == operator in GitHub Actions. Below is an example of the syntax for each system.","jobs:
  - job: conditional
    pool:
      vmImage: 'ubuntu-latest'
    steps:
      - script: echo ""This step runs with str equals 'ABC' and num equals 123""
        condition: and(eq(variables.str, 'ABC'), eq(variables.num, 123))","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run step if condition is met
        if: ${{ github.event_name == 'push' }}
        run: echo ""This step runs on push events""
",0
23,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Migrating conditionals and expression syntax - GitHub Actions syntax for conditional expressions,"Azure Pipelines and GitHub Actions can both run steps conditionally. In Azure Pipelines, conditional expressions are specified using the condition key. In GitHub Actions, conditional expressions are specified using the if key. Azure Pipelines uses functions within expressions to execute steps conditionally. In contrast, GitHub Actions uses an infix notation. For example, you must replace the eq function in Azure Pipelines with the == operator in GitHub Actions. Below is an example of the syntax for each system.","jobs:
  conditional:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This step runs with str equals 'ABC' and num equals 123""
        if: ${{ env.str == 'ABC' && env.num == 123 }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Example step
        if: ${{ github.event_name == 'push' }}
        run: echo ""This step runs only on push events""
",0
24,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Dependencies between jobs - Azure Pipelines syntax for dependencies between jobs,"Both Azure Pipelines and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies can be specified explicitly. In Azure Pipelines, this is done with the dependsOn key. In GitHub Actions, this is done with the needs key. Below is an example of the syntax for each system. The workflows start a first job named initial , and when that job completes, two jobs named fanout1 and fanout2 will run. Finally, when those jobs complete, the job fanin will run.","jobs:
  - job: initial
    pool:
      vmImage: 'ubuntu-latest'
    steps:
      - script: echo ""This job will be run first.""
  - job: fanout1
    pool:
      vmImage: 'ubuntu-latest'
    dependsOn: initial
    steps:
      - script: echo ""This job will run after the initial job, in parallel with fanout2.""
  - job: fanout2
    pool:
      vmImage: 'ubuntu-latest'
    dependsOn: initial
    steps:
      - script: echo ""This job will run after the initial job, in parallel with fanout1.""
  - job: fanin:
    pool:
      vmImage: 'ubuntu-latest'
    dependsOn: [fanout1, fanout2]
    steps:
      - script: echo ""This job will run after fanout1 and fanout2 have finished.""","jobs:
  initial:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running initial job""

  fanout1:
    runs-on: ubuntu-latest
    needs: initial
    steps:
      - run: echo ""Running fanout1 job""

  fanout2:
    runs-on: ubuntu-latest
    needs: initial
    steps:
      - run: echo ""Running fanout2 job""

  fanin:
    runs-on: ubuntu-latest
    needs: [fanout1, fanout2]
    steps:
      - run: echo ""Running fanin job""
",0
25,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Dependencies between jobs - GitHub Actions syntax for dependencies between jobs,"Both Azure Pipelines and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies can be specified explicitly. In Azure Pipelines, this is done with the dependsOn key. In GitHub Actions, this is done with the needs key. Below is an example of the syntax for each system. The workflows start a first job named initial , and when that job completes, two jobs named fanout1 and fanout2 will run. Finally, when those jobs complete, the job fanin will run.","jobs:
  initial:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This job will be run first.""
  fanout1:
    runs-on: ubuntu-latest
    needs: initial
    steps:
      - run: echo ""This job will run after the initial job, in parallel with fanout2.""
  fanout2:
    runs-on: ubuntu-latest
    needs: initial
    steps:
      - run: echo ""This job will run after the initial job, in parallel with fanout1.""
  fanin:
    runs-on: ubuntu-latest
    needs: [fanout1, fanout2]
    steps:
      - run: echo ""This job will run after fanout1 and fanout2 have finished.""","jobs:
  initial:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running initial job""

  fanout1:
    runs-on: ubuntu-latest
    needs: initial
    steps:
      - run: echo ""Running fanout1 job""

  fanout2:
    runs-on: ubuntu-latest
    needs: initial
    steps:
      - run: echo ""Running fanout2 job""

  fanin:
    runs-on: ubuntu-latest
    needs: [fanout1, fanout2]
    steps:
      - run: echo ""Running fanin job""
",0
26,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Migrating tasks to actions - Azure Pipelines syntax for tasks,"Azure Pipelines uses tasks , which are application components that can be re-used in multiple workflows. GitHub Actions uses actions , which can be used to perform tasks and customize your workflow. In both systems, you can specify the name of the task or action to run, along with any required inputs as key/value pairs. Below is an example of the syntax for each system.","jobs:
  - job: run_python
    pool:
      vmImage: 'ubuntu-latest'
    steps:
      - task: UsePythonVersion@0
        inputs:
          versionSpec: '3.7'
          architecture: 'x64'
      - script: python script.py","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
",0
27,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions,Migrating from Azure Pipelines to GitHub Actions - Migrating tasks to actions - GitHub Actions syntax for actions,"Azure Pipelines uses tasks , which are application components that can be re-used in multiple workflows. GitHub Actions uses actions , which can be used to perform tasks and customize your workflow. In both systems, you can specify the name of the task or action to run, along with any required inputs as key/value pairs. Below is an example of the syntax for each system.","jobs:
  run_python:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: '3.7'
          architecture: 'x64'
      - run: python script.py","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Example Action
        uses: actions/example-action@v1
        with:
          input1: value1
          input2: value2
",0
28,https://docs.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization,Creating workflow templates for your organization - Creating a workflow template,"Workflow templates can be created by users with write access to the organization's public  .github repository. These can then be used by organization members who have permission to create workflows. Workflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see the GitHub Enterprise Cloud documentation . Note  To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, seeReusing workflows. Note To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, see Reusing workflows . This procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow. If it doesn't already exist, create a new public repository named .github in your organization. Create a directory named workflow-templates . Create your new workflow file inside the workflow-templates directory. If you need to refer to a repository's default branch, you can use the $default-branch placeholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch. For example, this file named octo-organization-ci.yml demonstrates a basic workflow.","name: Octo Organization CI

on:
  push:
    branches: [ $default-branch ]
  pull_request:
    branches: [ $default-branch ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Run a one-line script
        run: echo Hello from Octo Organization","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm test
",0
29,https://docs.github.com/en/actions/managing-issues-and-pull-requests/adding-labels-to-issues,Adding labels to issues - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Label issues
on:
  issues:
    types:
      - reopened
      - opened
jobs:
  label_issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - run: gh issue edit ""$NUMBER"" --add-label ""$LABELS""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          NUMBER: ${{ github.event.issue.number }}
          LABELS: triage","on:
  issues:
    types: [opened]

jobs:
  add_labels:
    runs-on: ubuntu-latest
    steps:
      - name: Add labels to issue
        uses: actions-ecosystem/action-add-labels@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          labels: 'bug, enhancement'
",0
30,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action?learn=create_actions&learnProduct=actions,Creating a JavaScript action - Creating an action metadata file,"Create a new file named action.yml in the hello-world-javascript-action directory with the following example code. For more information, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'node20'
  main: 'index.js'","name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:
    description: 'Who to greet'
    required: true
    default: 'World'
runs:
  using: 'node12'
  main: 'index.js'
",0
31,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action?learn=create_actions&learnProduct=actions,Creating a JavaScript action - Testing out your action in a workflow - Example using a public action,"Now you're ready to test your action out in a workflow. Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository . This example demonstrates how your new public action can be run from within an external repository. Copy the following YAML into a new file at .github/workflows/main.yml , and update the uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b line with your username and the name of the public repository you created above. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  test-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: your-username/your-repo-name@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: ""Your Name""
",0
32,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action?learn=create_actions&learnProduct=actions,Creating a JavaScript action - Testing out your action in a workflow - Example using a private action,"Now you're ready to test your action out in a workflow. Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository . Copy the workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Run private action
        uses: ./  # Assumes the action is in the same repository
        with:
          who-to-greet: YourName
",0
33,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle,Building and testing Java with Gradle - Using a Gradle workflow template - Specifying the Java version and architecture,"To get started quickly, add a workflow template to the .github/workflows directory of your repository. GitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template. On GitHub, navigate to the main page of the repository. Under your repository name, click Actions . If you already have a workflow in your repository, click New workflow . The ""Choose a workflow"" page shows a selection of recommended workflow templates. Search for ""Java with Gradle"". On the ""Java with Gradle"" workflow, click Configure .
This workflow performs the following steps: Checks out a copy of project's repository. Sets up the Java JDK. Sets up the Gradle environment. The gradle/actions/setup-gradle action takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions. The ""Build with Gradle"" step executes the build task using the Gradle Wrapper . Edit the workflow as required. For example, change the Java version. Note    This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, seeSecurity hardening for GitHub Actions. Note Click Commit changes . The gradle.yml workflow file is added to the .github/workflows directory of your repository. The workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( x64 or x86 ), you can use the setup-java action to choose a different Java runtime environment. For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version , distribution and architecture parameters to '11' , 'temurin' and x64 .","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 11 for x64
    uses: actions/setup-java@v4
    with:
      java-version: '11'
      distribution: 'temurin'
      architecture: x64","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        architecture: 'x64'
    - name: Set up Gradle
      uses: gradle/gradle-build-action@a1b2c3d4e5f6g7h8i9j0k
    - name: Build with Gradle
      run: ./gradlew build
",0
34,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle,Building and testing Java with Gradle - Building and testing your code,"You can use the same commands that you use locally to build and test your code. The workflow template will run the build task by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file. If you use different commands to build your project, or you want to use a different task, you can specify those. For example, you may want to run the package task that's configured in your ci.gradle file.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - name: Setup Gradle
    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  - name: Build with Gradle
    run: ./gradlew -b ci.gradle package","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
    - name: Build with Gradle
      run: ./gradlew build
",0
35,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle,Building and testing Java with Gradle - Packaging workflow data as artifacts,"After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow . Gradle will usually create output files like JARs, EARs, or WARs in the build/libs directory. You can upload the contents of that directory using the upload-artifact action.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - name: Setup Gradle
    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  - name: Build with Gradle
    run: ./gradlew build

  - name: Upload build artifacts
    uses: actions/upload-artifact@v4
    with:
      name: Package
      path: build/libs","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
    - name: Build with Gradle
      run: ./gradlew build
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-artifacts
        path: build/libs
",0
36,https://docs.github.com/en/actions/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using tags for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions: This example demonstrates how a user can reference a major release tag:","steps:
    - uses: actions/javascript-action@v1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: example/action@v1
",0
37,https://docs.github.com/en/actions/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using tags for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions: This example demonstrates how a user can reference a major release tag: This example demonstrates how a user can reference a specific patch release tag:","steps:
    - uses: actions/javascript-action@v1.0.1","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use major release tag
        uses: example/action@v1
      - name: Use specific patch release tag
        uses: example/action@v1.0.1
",0
38,https://docs.github.com/en/actions/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using branches for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. If you prefer to use branch names for release management, this example demonstrates how to reference a named branch:","steps:
    - uses: actions/javascript-action@v1-beta","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
      - uses: my-org/my-action@release-branch
",0
39,https://docs.github.com/en/actions/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using a commit's SHA for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. Each Git commit receives a calculated SHA value, which is unique and immutable. Your action's users might prefer to rely on a commit's SHA value, as this approach can be more reliable than specifying a tag, which could be deleted or moved. However, this means that users will not receive further updates made to the action. You must use a commit's full SHA value, and not an abbreviated value.","steps:
    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@<full-commit-SHA>
",0
40,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=mac,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run script
      run: echo ""Hello, World!""
",0
41,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=mac,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: OWNER/REPO@SHA
        with:
          who-to-greet: ""Your Name""
",0
42,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=mac,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
    - run: ./goodbye.sh
      shell: bash
",0
43,https://docs.github.com/en/actions/migrating-to-github-actions/automated-migrations/extending-github-actions-importer-with-custom-transformers,Extending GitHub Actions Importer with custom transformers - Creating custom transformers for items - Example custom transformer for a build step,"You can create custom transformers that GitHub Actions Importer will use when converting existing build steps or triggers to their equivalent in GitHub Actions. This is especially useful when: GitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. In order to create custom transformers for build steps and triggers: The following example converts a build step that uses the ""buildJavaScriptApp"" identifier to run various npm commands: The above example results in the following GitHub Actions workflow step. It is comprised of converted build steps that had a buildJavaScriptApp identifier:","- name: build javascript app
  run: |
    npm run build
    npm run package
    npm run deploy","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Build JavaScript app
        run: npm run build
      - name: Run tests
        run: npm test
",0
44,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven,Building and testing Java with Maven - Using a Maven workflow template - Specifying the Java version and architecture,"To get started quickly, add a workflow template to the .github/workflows directory of your repository. GitHub provides a workflow template for Maven that should work for most Java with Maven projects. The subsequent sections of this guide give examples of how you can customize this workflow template. On GitHub, navigate to the main page of the repository. Under your repository name, click Actions . If you already have a workflow in your repository, click New workflow . The ""Choose a workflow"" page shows a selection of recommended workflow templates. Search for ""Java with Maven"". On the ""Java with Maven"" workflow, click Configure . Edit the workflow as required. For example, change the Java version. Click Commit changes . The maven.yml workflow file is added to the .github/workflows directory of your repository. The workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( x64 or x86 ), you can use the setup-java action to choose a different Java runtime environment. For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version , distribution and architecture parameters to '11' , 'temurin' and x64 .","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 11 for x64
    uses: actions/setup-java@v4
    with:
      java-version: '11'
      distribution: 'temurin'
      architecture: x64","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        architecture: 'x64'
    - name: Build with Maven
      run: mvn -B package --file pom.xml
",0
45,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven,Building and testing Java with Maven - Building and testing your code,"You can use the same commands that you use locally to build and test your code. The workflow template will run the package target by default. In the default Maven configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file. If you use different commands to build your project, or you want to use a different target, you can specify those. For example, you may want to run the verify target that's configured in a pom-ci.xml file.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
  - name: Run the Maven verify phase
    run: mvn --batch-mode --update-snapshots verify","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
    - name: Build with Maven
      run: mvn -B package
",0
46,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven,Building and testing Java with Maven - Caching dependencies,"You can cache your dependencies to speed up your workflow runs. After a successful run, your local Maven repository will be stored in a cache. In future workflow runs, the cache will be restored so that dependencies don't need to be downloaded from remote Maven repositories. You can cache dependencies simply using the setup-java action or can use cache action for custom and more advanced configuration.","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 17
    uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
      cache: maven
  - name: Build with Maven
    run: mvn --batch-mode --update-snapshots verify","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'maven'
    - run: mvn install
",0
47,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven,Building and testing Java with Maven - Packaging workflow data as artifacts,"After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow . Maven will usually create output files like JARs, EARs, or WARs in the target directory. To upload those as artifacts, you can copy them into a new directory that contains artifacts to upload. For example, you can create a directory called staging . Then you can upload the contents of that directory using the upload-artifact action.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
  - run: mvn --batch-mode --update-snapshots verify
  - run: mkdir staging && cp target/*.jar staging
  - uses: actions/upload-artifact@v4
    with:
      name: Package
      path: staging","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
    - name: Build with Maven
      run: mvn clean package
    - name: Prepare artifacts
      run: mkdir -p staging && cp target/*.jar staging/
    - name: Upload artifacts
      uses: actions/upload-artifact@v2
      with:
        name: java-packages
        path: staging/
",0
48,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant,Building and testing Java with Ant - Using an Ant workflow template - Specifying the Java version and architecture,"To get started quickly, add a workflow template to the .github/workflows directory of your repository. GitHub provides a workflow template for Ant that should work for most Java with Ant projects. The subsequent sections of this guide give examples of how you can customize this workflow template. On GitHub, navigate to the main page of the repository. Under your repository name, click Actions . If you already have a workflow in your repository, click New workflow . The ""Choose a workflow"" page shows a selection of recommended workflow templates. Search for ""Java with Ant"". On the ""Java with Ant"" workflow, click Configure . Edit the workflow as required. For example, change the Java version. Click Commit changes . The ant.yml workflow file is added to the .github/workflows directory of your repository. The workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( x64 or x86 ), you can use the setup-java action to choose a different Java runtime environment. For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version , distribution and architecture parameters to '11' , 'temurin' and x64 .","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 11 for x64
    uses: actions/setup-java@v4
    with:
      java-version: '11'
      distribution: 'temurin'
      architecture: x64","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        architecture: 'x64'
    - name: Build with Ant
      run: ant build
    - name: Test with Ant
      run: ant test
",0
49,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant,Building and testing Java with Ant - Building and testing your code,"You can use the same commands that you use locally to build and test your code. The workflow template will run the default target specified in your build.xml file. Your default target will commonly be set to build classes, run tests and package classes into their distributable format, for example, a JAR file. If you use different commands to build your project, or you want to run a different target, you can specify those. For example, you may want to run the jar target that's configured in your build-ci.xml file.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
  - name: Run the Ant jar target
    run: ant -noinput -buildfile build-ci.xml jar","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
    - name: Build with Ant
      run: ant
",0
50,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant,Building and testing Java with Ant - Packaging workflow data as artifacts,"After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow . Ant will usually create output files like JARs, EARs, or WARs in the build/jar directory. You can upload the contents of that directory using the upload-artifact action.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - run: ant -noinput -buildfile build.xml
  - uses: actions/upload-artifact@v4
    with:
      name: Package
      path: build/jar","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK
      uses: actions/setup-java@v2
      with:
        java-version: '11'
    - name: Build with Ant
      run: ant build
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: java-packages
        path: build/jar
",0
51,https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development,Installing an Apple certificate on macOS runners for Xcode development - Add a step to your workflow,"This example workflow includes a step that imports the Apple certificate and provisioning profile from the GitHub secrets, and installs them on the runner.","name: App build
on: push

jobs:
  build_with_signing:
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install the Apple certificate and provisioning profile
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # import certificate and provisioning profile from secrets
          echo -n ""$BUILD_CERTIFICATE_BASE64"" | base64 --decode -o $CERTIFICATE_PATH
          echo -n ""$BUILD_PROVISION_PROFILE_BASE64"" | base64 --decode -o $PP_PATH

          # create temporary keychain
          security create-keychain -p ""$KEYCHAIN_PASSWORD"" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p ""$KEYCHAIN_PASSWORD"" $KEYCHAIN_PATH

          # import certificate to keychain
          security import $CERTIFICATE_PATH -P ""$P12_PASSWORD"" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k ""$KEYCHAIN_PASSWORD"" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # apply provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
      - name: Build app
          # ...","jobs:
  build:
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Apple certificate
        uses: apple-actions/import-codesign-certs@v1
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.P12_PASSWORD }}
          provisioning-profile-base64: ${{ secrets.PROVISIONING_PROFILE }}
",0
52,https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development,Installing an Apple certificate on macOS runners for Xcode development - Required clean-up on self-hosted runners,"GitHub-hosted runners are isolated virtual machines that are automatically destroyed at the end of the job execution. This means that the certificates and provisioning profile used on the runner during the job will be destroyed with the runner when the job is completed. On self-hosted runners, the $RUNNER_TEMP directory is cleaned up at the end of the job execution, but the keychain and provisioning profile might still exist on the runner. If you use self-hosted runners, you should add a final step to your workflow to help ensure that these sensitive files are deleted at the end of the job. The workflow step shown below is an example of how to do this.","- name: Clean up keychain and provisioning profile
  if: ${{ always() }}
  run: |
    security delete-keychain $RUNNER_TEMP/app-signing.keychain-db
    rm ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision","jobs:
  install-certificate:
    runs-on: macos-latest
    steps:
      - name: Install Apple certificate
        run: |
          security create-keychain -p """" build.keychain
          security import /path/to/certificate.p12 -k ~/Library/Keychains/build.keychain -P ${{ secrets.CERT_PASSWORD }} -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k """" ~/Library/Keychains/build.keychain
      - name: Clean up keychain on self-hosted runners
        if: ${{ runner.os == 'macOS' && !github.context.runner.is_virtual_environment }}
        run: |
          security delete-keychain ~/Library/Keychains/build.keychain
",0
53,https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages,Publishing Node.js packages - Publishing packages to the npm registry,"You can trigger a workflow to publish your package every time you publish a new release. The process in the following example is executed when the release event of type published is triggered. If the CI tests pass, the process uploads the package to the npm registry. For more information, see Managing releases in a repository . To perform authenticated operations against the npm registry in your workflow, you'll need to store your npm authentication token as a secret. For example, create a repository secret called NPM_TOKEN . For more information, see Using secrets in GitHub Actions . By default, npm uses the name field of the package.json file to determine the name of your published package. When publishing to a global namespace, you only need to include the package name. For example, you would publish a package named my-package to https://www.npmjs.com/package/my-package . If you're publishing a package that includes a scope prefix, include the scope in the name of your package.json file. For example, if your npm scope prefix is ""octocat"" and the package name is ""hello-world"", the name in your package.json file should be @octocat/hello-world . If your npm package uses a scope prefix and the package is public, you need to use the option npm publish --access public . This is an option that npm requires to prevent someone from publishing a private package unintentionally. If you would like to publish your package with provenance, include the --provenance flag with your npm publish command. This allows you to publicly and verifiably establish where and how your package was built, which increases supply chain security for people who consume your package. For more information, see Generating provenance statements in the npm documentation. This example stores the NPM_TOKEN secret in the NODE_AUTH_TOKEN environment variable. When the setup-node action creates an .npmrc file, it references the token from the NODE_AUTH_TOKEN environment variable.","name: Publish Package to npmjs
on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
      # Setup .npmrc file to publish to npm
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
      - run: npm ci
      - run: npm publish --provenance --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '16'
        registry-url: 'https://registry.npmjs.org'
    - run: npm ci
    - run: npm test
    - run: npm publish --access public --provenance
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
",0
54,https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages,Publishing Node.js packages - Publishing packages to GitHub Packages - Example workflow,"You can trigger a workflow to publish your package every time you publish a new release. The process in the following example is executed when the release event of type published is triggered. If the CI tests pass, the process uploads the package to GitHub Packages. For more information, see Managing releases in a repository . This example stores the GITHUB_TOKEN secret in the NODE_AUTH_TOKEN environment variable. When the setup-node action creates an .npmrc file, it references the token from the NODE_AUTH_TOKEN environment variable.","name: Publish package to GitHub Packages
on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      # Setup .npmrc file to publish to GitHub Packages
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://npm.pkg.github.com'
          # Defaults to the user or organization that owns the workflow file
          scope: '@octocat'
      - run: npm ci
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","on:
  release:
    types: [published]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '16'
        registry-url: 'https://npm.pkg.github.com'
    - run: npm ci
    - run: npm test
    - run: npm publish
      env:
        NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
",0
55,https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages,Publishing Node.js packages - Publishing packages using Yarn,"If you use the Yarn package manager, you can install and publish packages using Yarn.","name: Publish Package to npmjs
on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # Setup .npmrc file to publish to npm
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          # Defaults to the user or organization that owns the workflow file
          scope: '@octocat'
      - run: yarn
      - run: yarn npm publish // for Yarn version 1, use `yarn publish` instead
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'yarn'
      - name: Install dependencies
        run: yarn install
      - name: Publish package
        run: yarn publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
",0
56,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect,About security hardening with OpenID Connect - Configuring the OIDC trust with the cloud - Understanding the OIDC token,"When you configure your cloud to trust GitHub's OIDC provider, you must add conditions that filter incoming requests, so that untrusted repositories or workflows cant request access tokens for your cloud resources: Each job requests an OIDC token from GitHub's OIDC provider, which responds with an automatically generated JSON web token (JWT) that is unique for each workflow job where it is generated. When the job runs, the OIDC token is presented to the cloud provider. To validate the token, the cloud provider checks if the OIDC token's subject and other claims are a match for the conditions that were preconfigured on the cloud role's OIDC trust definition. The following example OIDC token uses a subject ( sub ) that references a job environment named prod in the octo-org/octo-repo repository.","{
  ""typ"": ""JWT"",
  ""alg"": ""RS256"",
  ""x5t"": ""example-thumbprint"",
  ""kid"": ""example-key-id""
}
{
  ""jti"": ""example-id"",
  ""sub"": ""repo:octo-org/octo-repo:environment:prod"",
  ""environment"": ""prod"",
  ""aud"": ""https://github.com/octo-org"",
  ""ref"": ""refs/heads/main"",
  ""sha"": ""example-sha"",
  ""repository"": ""octo-org/octo-repo"",
  ""repository_owner"": ""octo-org"",
  ""actor_id"": ""12"",
  ""repository_visibility"": ""private"",
  ""repository_id"": ""74"",
  ""repository_owner_id"": ""65"",
  ""run_id"": ""example-run-id"",
  ""run_number"": ""10"",
  ""run_attempt"": ""2"",
  ""runner_environment"": ""github-hosted"",
  ""actor"": ""octocat"",
  ""workflow"": ""example-workflow"",
  ""head_ref"": """",
  ""base_ref"": """",
  ""event_name"": ""workflow_dispatch"",
  ""ref_type"": ""branch"",
  ""job_workflow_ref"": ""octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main"",
  ""iss"": ""https://token.actions.githubusercontent.com"",
  ""nbf"": 1632492967,
  ""exp"": 1632493867,
  ""iat"": 1632493567
}","jobs:
  example-job:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Request OIDC token
        id: oidc
        run: echo ""Requesting OIDC token""
      - name: Use OIDC token
        run: |
          echo ""Using OIDC token for cloud authentication""
          # Example command to use the OIDC token
          # cloud-cli authenticate --token ${{ steps.oidc.outputs.token }}
",0
57,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect,About security hardening with OpenID Connect - Updating your actions for OIDC - Adding permissions settings,"To update your custom actions to authenticate using OIDC, you can use getIDToken() from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see ""OIDC Token"" in the npm package documentation . You could also use a curl command to request the JWT, using the following environment variables. For example: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
58,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect,About security hardening with OpenID Connect - Updating your actions for OIDC - Adding permissions settings,"To update your custom actions to authenticate using OIDC, you can use getIDToken() from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see ""OIDC Token"" in the npm package documentation . You could also use a curl command to request the JWT, using the following environment variables. For example: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","jobs:
  example-job:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Request OIDC Token
        run: |
          echo ""Requesting OIDC Token""
          curl -H ""Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"" \
               -H ""Accept: application/json"" \
               https://api.github.com/actions/oidc/token
",0
59,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow,Using self-hosted runners in a workflow - Using default labels to route jobs,"A self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform: You can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:","runs-on: [self-hosted, linux, ARM64]","jobs:
  build:
    runs-on: [self-hosted, linux, x64]
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
60,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow,Using self-hosted runners in a workflow - Using custom labels to route jobs,"You can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled. For example, if you have a job that requires a specific type of graphics hardware, you can create a custom label called gpu and assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job. This example shows a job that combines default and custom labels:","runs-on: [self-hosted, linux, x64, gpu]","jobs:
  build:
    runs-on: [self-hosted, gpu]
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
61,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow,Using self-hosted runners in a workflow - Using groups to route jobs,"In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
62,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow,Using self-hosted runners in a workflow - Using labels and groups to route jobs,"When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [group:ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
63,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer,Migrating from Azure DevOps with GitHub Actions Importer - Reference - Optional arguments - --config-file-path - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. The --config-file-path argument can also be used to specify which repository a converted reusable workflow or composite action should be migrated to. In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform an audit. To audit an Azure DevOps instance using a configuration file, the configuration file must be in the following format and each repository_slug must be unique:","source_files:
  - repository_slug: azdo-project/1
    path: file.yml
  - repository_slug: azdo-project/2
    paths: path.yml","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer audit
        run: |
          gh actions-importer audit --config-file-path path/to/config-file.yaml
",0
64,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer,Migrating from Azure DevOps with GitHub Actions Importer - Reference - Optional arguments - --config-file-path - Specify the repository of converted reusable workflows and composite actions,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. The --config-file-path argument can also be used to specify which repository a converted reusable workflow or composite action should be migrated to. GitHub Actions Importer uses the YAML file provided to the --config-file-path argument to determine the repository that converted reusable workflows and composite actions are migrated to. To begin, you should run an audit without the --config-file-path argument: The output of this command will contain a file named config.yml that contains a list of all the reusable workflows and composite actions that were converted by GitHub Actions Importer. For example, the config.yml file may have the following contents:","reusable_workflows:
  - name: my-reusable-workflow.yml
    target_url: https://github.com/octo-org/octo-repo
    ref: main

composite_actions:
  - name: my-composite-action.yml
    target_url: https://github.com/octo-org/octo-repo
    ref: main","reusable_workflows:
  - name: build-and-test
    repository: my-org/build-and-test-repo
  - name: deploy
    repository: my-org/deploy-repo

composite_actions:
  - name: setup-environment
    repository: my-org/setup-env-repo
  - name: run-tests
    repository: my-org/run-tests-repo
",0
65,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer,Migrating from Azure DevOps with GitHub Actions Importer - Reference - Templates - Template file path names - Variable file path name example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps. You can transform Azure DevOps templates with GitHub Actions Importer. GitHub Actions Importer can extract templates with relative or dynamic file paths with variable, parameter, and iterative expressions in the file name. However, there must be a default value set.","# File: azure-pipelines.yml
variables:
- template: 'templates/vars.yml'

steps:
- template: ""./templates/$""","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        uses: github/gh-actions-importer@v1
        with:
          template-file-path: ${{ env.TEMPLATE_FILE_PATH }}
          variable-file-path: ${{ env.VARIABLE_FILE_PATH }}
        env:
          TEMPLATE_FILE_PATH: 'default/template/path'
          VARIABLE_FILE_PATH: 'default/variable/path'
",0
66,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer,Migrating from Azure DevOps with GitHub Actions Importer - Reference - Templates - Template file path names - Variable file path name example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps. You can transform Azure DevOps templates with GitHub Actions Importer. GitHub Actions Importer can extract templates with relative or dynamic file paths with variable, parameter, and iterative expressions in the file name. However, there must be a default value set.","# File: templates/vars.yml
variables:
  one: 'simple_step.yml'","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        uses: github/gh-actions-importer@v1
        with:
          template-file-path: ${{ env.TEMPLATE_FILE_PATH }}
          variable-file-path: ${{ env.VARIABLE_FILE_PATH }}
        env:
          TEMPLATE_FILE_PATH: 'default/template/path'
          VARIABLE_FILE_PATH: 'default/variable/path'
",0
67,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer,Migrating from Azure DevOps with GitHub Actions Importer - Reference - Templates - Template file path names - Parameter file path name example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps. You can transform Azure DevOps templates with GitHub Actions Importer. GitHub Actions Importer can extract templates with relative or dynamic file paths with variable, parameter, and iterative expressions in the file name. However, there must be a default value set.","parameters:
- name: template
  type: string
  default: simple_step.yml

steps:
- template: ""./templates/${{ parameters.template }}""","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        uses: github/gh-actions-importer@v1
        with:
          template-file-path: ${{ env.TEMPLATE_FILE_PATH }}
          parameter-file-path: ${{ env.PARAMETER_FILE_PATH }}
        env:
          TEMPLATE_FILE_PATH: 'default/template/path'
          PARAMETER_FILE_PATH: 'default/parameter/path'
",0
68,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer,Migrating from Azure DevOps with GitHub Actions Importer - Reference - Templates - Template file path names - Iterative file path name example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps. You can transform Azure DevOps templates with GitHub Actions Importer. GitHub Actions Importer can extract templates with relative or dynamic file paths with variable, parameter, and iterative expressions in the file name. However, there must be a default value set.","parameters:
- name: steps
  type: object
  default:
  - build_step
  - release_step
steps:
- ${{ each step in parameters.steps }}:
    - template: ""$-variables.yml""","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        uses: github-actions-importer/importer-action@v1
        with:
          azure-devops-template: ${{ env.AZURE_DEVOPS_TEMPLATE }}
          output-path: ${{ env.OUTPUT_PATH }}
        env:
          AZURE_DEVOPS_TEMPLATE: 'default-template.yml'
          OUTPUT_PATH: './migrated-templates'
",0
69,https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container,Running jobs in a container - Overview - Example: Running a job within a container,"Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. Note The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell .","name: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: node:14
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
70,https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container,Running jobs in a container - Overview - Example: Running a job within a container,"Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. Note The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell . When you only specify a container image, you can omit the image keyword.","jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container: node:18","jobs:
  example-job:
    runs-on: ubuntu-latest
    container: node:14
    steps:
      - run: echo ""Running inside a container""
",0
71,https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container,Running jobs in a container - Defining credentials for a container registry - Example: Defining credentials for a container registry,"If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password . The credentials are the same values that you would provide to the docker login command.","container:
  image: ghcr.io/owner/image
  credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: your-container-image:tag
      credentials:
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
    steps:
      - run: echo ""Running job in a container with registry credentials""
",0
72,https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container,Running jobs in a container - Mounting volumes in a container - Example: Mounting volumes in a container,"Use jobs.<job_id>.container.volumes to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host. To specify a volume, you specify the source and destination path: <source>:<destinationPath> . The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.","volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
      volumes:
        - /host/path:/container/path
    steps:
      - name: Check mounted volume
        run: ls /container/path
",0
73,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go,Building and testing Go - Specifying a Go version - Using multiple versions of Go,"The easiest way to specify a Go version is by using the setup-go action provided by GitHub. For more information see, the setup-go action . To use a preinstalled version of Go on a GitHub-hosted runner, pass the relevant version to the go-version property of the setup-go action. This action finds a specific version of Go from the tools cache on each runner, and adds the necessary binaries to PATH . These changes will persist for the remainder of the job. The setup-go action is the recommended way of using Go with GitHub Actions, because it helps ensure consistent behavior across different runners and different versions of Go. If you are using a self-hosted runner, you must install Go and add it to PATH .","name: Go

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [ '1.19', '1.20', '1.21.x' ]

    steps:
      - uses: actions/checkout@v4
      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      # You can test your matrix by printing the current Go version
      - name: Display Go version
        run: go version","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [1.15, 1.16, 1.17]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: Build
        run: go build ./...
      - name: Test
        run: go test ./...
",0
74,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go,Building and testing Go - Specifying a Go version - Using a specific Go version,"The easiest way to specify a Go version is by using the setup-go action provided by GitHub. For more information see, the setup-go action . To use a preinstalled version of Go on a GitHub-hosted runner, pass the relevant version to the go-version property of the setup-go action. This action finds a specific version of Go from the tools cache on each runner, and adds the necessary binaries to PATH . These changes will persist for the remainder of the job. The setup-go action is the recommended way of using Go with GitHub Actions, because it helps ensure consistent behavior across different runners and different versions of Go. If you are using a self-hosted runner, you must install Go and add it to PATH . You can configure your job to use a specific version of Go, such as 1.20.8 . Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest patch release of Go 1.21:","- name: Setup Go 1.21.x
        uses: actions/setup-go@v5
        with:
          # Semantic version range syntax or exact version of Go
          go-version: '1.21.x'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.21.x'
      - run: go build ./...
      - run: go test ./...
",0
75,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go,Building and testing Go - Installing dependencies,You can use go get to install dependencies:,"steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21.x'
      - name: Install dependencies
        run: |
          go get .
          go get example.com/octo-examplemodule
          go get example.com/octo-examplemodule@v1.3.4","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: '1.x'
      - name: Install dependencies
        run: go get -v ./...
      - name: Build
        run: go build -v ./...
      - name: Test
        run: go test -v ./...
",0
76,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go,Building and testing Go - Installing dependencies - Caching dependencies,"You can use go get to install dependencies: You can cache and restore dependencies using the setup-go action . By default, caching is enabled when using the setup-go action. The setup-go action searches for the dependency file, go.sum , in the repository root and uses the hash of the dependency file as a part of the cache key. You can use the cache-dependency-path parameter for cases when multiple dependency files are used, or when they are located in different subdirectories.","- name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.17'
          cache-dependency-path: subdir/go.sum","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.x'
      - run: go get -v ./...
      - run: go build -v ./...
      - run: go test -v ./...
",0
77,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go,Building and testing Go - Building and testing your code,You can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use go build and go test in a job:,"name: Go
on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21.x'
      - name: Install dependencies
        run: go get .
      - name: Build
        run: go build -v ./...
      - name: Test with the Go CLI
        run: go test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.x'
      - name: Build
        run: go build ./...
      - name: Test
        run: go test ./...
",0
78,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go,Building and testing Go - Packaging workflow data as artifacts,"After a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the upload-artifact action to upload test results. For more information, see Storing and sharing data from a workflow .","name: Upload Go test results

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [ '1.19', '1.20', '1.21.x' ]

    steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      - name: Install dependencies
        run: go get .
      - name: Test with Go
        run: go test -json > TestResults-${{ matrix.go-version }}.json
      - name: Upload Go test results
        uses: actions/upload-artifact@v4
        with:
          name: Go-results-${{ matrix.go-version }}
          path: TestResults-${{ matrix.go-version }}.json","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: '1.17'
    - name: Build
      run: go build ./...
    - name: Test
      run: go test -v ./... | tee test-results.txt
    - name: Upload test results
      uses: actions/upload-artifact@v2
      with:
        name: test-results
        path: test-results.txt
",0
79,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings,Supplemental arguments and settings - Optional parameters - Using a credentials file for authentication,GitHub Actions Importer has several optional parameters that you can use to customize the migration process. The --credentials-file parameter specifies the path to a file containing credentials for different servers that GitHub Actions Importer can authenticate to. This is useful when build scripts (such as .travis.yml or jenkinsfile ) are stored in multiple GitHub Enterprise Server instances. A credentials file must be a YAML file containing a list of server and access token combinations. GitHub Actions Importer uses the credentials for the URL that most closely matches the network request being made. For example:,"- url: https://github.com
  access_token: ghp_mygeneraltoken
- url: https://github.com/specific_org/
  access_token: ghp_myorgspecifictoken
- url: https://jenkins.org
  access_token: abc123
  username: marty_mcfly","jobs:
  import:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        run: |
          gh actions-importer migrate --credentials-file path/to/credentials.yml
",0
80,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings,Supplemental arguments and settings - Optional parameters - Using a credentials file for authentication - Alternative source code providers,"GitHub Actions Importer has several optional parameters that you can use to customize the migration process. The --credentials-file parameter specifies the path to a file containing credentials for different servers that GitHub Actions Importer can authenticate to. This is useful when build scripts (such as .travis.yml or jenkinsfile ) are stored in multiple GitHub Enterprise Server instances. A credentials file must be a YAML file containing a list of server and access token combinations. GitHub Actions Importer uses the credentials for the URL that most closely matches the network request being made. For example: For the above credentials file, GitHub Actions Importer uses the access token ghp_mygeneraltoken to authenticate all network requests to https://github.com , unless the network request is for a repository in the specific_org organization. In that case, the ghp_myorgspecifictoken token is used to authenticate instead. GitHub Actions Importer can automatically fetch source code from non-GitHub repositories. A credentials file can specify the provider , the provider URL, and the credentials needed to retrieve the source code.","- url: https://gitlab.com
  access_token: super_secret_token
  provider: gitlab","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        run: |
          gh-actions-importer migrate \
            --credentials-file path/to/credentials.yml
",0
81,https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts,Storing and sharing data from a workflow - Uploading build and test artifacts - Example,"You can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, see About continuous integration with GitHub Actions . The output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage. You can use the upload-artifact action to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided then artifact will be used as the default name. For more information on syntax, see the actions/upload-artifact action. For example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in the dist directory, you would deploy the files in the dist directory to your web application server if all tests completed successfully. This example shows you how to create a workflow for a Node.js project that builds the code in the src directory and runs the tests in the tests directory. You can assume that running npm test produces a code coverage report named code-coverage.html stored in the output/test/ directory. The workflow uploads the production artifacts in the dist directory, but excludes any markdown files. It also uploads the code-coverage.html report as another artifact.","name: Node CI

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: npm install, build, and test
        run: |
          npm install
          npm run build --if-present
          npm test
      - name: Archive production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-without-markdown
          path: |
            dist
            !dist/**/*.md
      - name: Archive code coverage results
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-report
          path: output/test/code-coverage.html","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '14'
    - name: Install dependencies
      run: npm install
    - name: Build
      run: npm run build
    - name: Test
      run: npm test
    - name: Upload production artifacts
      uses: actions/upload-artifact@v3
      with:
        name: production-artifacts
        path: dist/
        exclude: '**/*.md'
    - name: Upload code coverage report
      uses: actions/upload-artifact@v3
      with:
        name: code-coverage-report
        path: output/test/code-coverage.html
",0
82,https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts,Storing and sharing data from a workflow - Configuring a custom artifact retention period,"You can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can use retention-days with the upload-artifact action. This example demonstrates how to set a custom retention period of 5 days for the artifact named my-artifact :","- name: 'Upload Artifact'
    uses: actions/upload-artifact@v4
    with:
      name: my-artifact
      path: my_file.txt
      retention-days: 5","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Create a file
        run: echo ""Hello, World!"" > my-artifact.txt
      - name: Upload artifact with custom retention
        uses: actions/upload-artifact@v3
        with:
          name: my-artifact
          path: my-artifact.txt
          retention-days: 5
",0
83,https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts,Storing and sharing data from a workflow - Downloading or deleting artifacts - Downloading artifacts during a workflow run,"During a workflow run, you can use the download-artifact action to download artifacts that were previously uploaded in the same workflow run. After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see Downloading workflow artifacts , Removing workflow artifacts , and REST API endpoints for GitHub Actions artifacts . The actions/download-artifact action can be used to download previously uploaded artifacts during a workflow run. Note  If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. SeeDownload Artifacts from other Workflow Runs or Repositoriesin the documentation for thedownload-artifactaction. Note If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. See Download Artifacts from other Workflow Runs or Repositories in the documentation for the download-artifact action. Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is artifact .","- name: Download a single artifact
  uses: actions/download-artifact@v4
  with:
    name: my-artifact","jobs:
  download_artifact:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v3
        with:
          name: artifact
",0
84,https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts,Storing and sharing data from a workflow - Downloading or deleting artifacts - Downloading artifacts during a workflow run,"During a workflow run, you can use the download-artifact action to download artifacts that were previously uploaded in the same workflow run. After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see Downloading workflow artifacts , Removing workflow artifacts , and REST API endpoints for GitHub Actions artifacts . The actions/download-artifact action can be used to download previously uploaded artifacts during a workflow run. Note  If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. SeeDownload Artifacts from other Workflow Runs or Repositoriesin the documentation for thedownload-artifactaction. Note If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. See Download Artifacts from other Workflow Runs or Repositories in the documentation for the download-artifact action. Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is artifact . You can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts.","- name: Download all workflow run artifacts
  uses: actions/download-artifact@v4","jobs:
  download_artifacts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v3
        with:
          name: artifact
",0
85,https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts,Storing and sharing data from a workflow - Passing data between jobs in a workflow,"You can use the upload-artifact and download-artifact actions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see the actions/upload-artifact and download-artifact actions. Jobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses the needs keyword to ensure that job_1 , job_2 , and job_3 run sequentially. For example, job_2 requires job_1 using the needs: job_1 syntax. Job 1 performs these steps: Job 2 uses the result in the previous job: Job 3 displays the result uploaded in the previous job: The full math operation performed in this workflow example is (3 + 7) x 9 = 90 .","name: Share data between jobs

on: [push]

jobs:
  job_1:
    name: Add 3 and 7
    runs-on: ubuntu-latest
    steps:
      - shell: bash
        run: |
          expr 3 + 7 > math-homework.txt
      - name: Upload math result for job 1
        uses: actions/upload-artifact@v4
        with:
          name: homework_pre
          path: math-homework.txt

  job_2:
    name: Multiply by 9
    needs: job_1
    runs-on: windows-latest
    steps:
      - name: Download math result for job 1
        uses: actions/download-artifact@v4
        with:
          name: homework_pre
      - shell: bash
        run: |
          value=`cat math-homework.txt`
          expr $value \* 9 > math-homework.txt
      - name: Upload math result for job 2
        uses: actions/upload-artifact@v4
        with:
          name: homework_final
          path: math-homework.txt

  job_3:
    name: Display results
    needs: job_2
    runs-on: macOS-latest
    steps:
      - name: Download math result for job 2
        uses: actions/download-artifact@v4
        with:
          name: homework_final
      - name: Print the final result
        shell: bash
        run: |
          value=`cat math-homework.txt`
          echo The result is $value","jobs:
  job_1:
    runs-on: ubuntu-latest
    steps:
      - name: Perform addition
        run: echo $((3 + 7)) > result.txt
      - name: Upload result
        uses: actions/upload-artifact@v3
        with:
          name: addition-result
          path: result.txt

  job_2:
    runs-on: ubuntu-latest
    needs: job_1
    steps:
      - name: Download addition result
        uses: actions/download-artifact@v3
        with:
          name: addition-result
      - name: Perform multiplication
        run: |
          result=$(cat result.txt)
          echo $((result * 9)) > final-result.txt
      - name: Upload final result
        uses: actions/upload-artifact@v3
        with:
          name: final-result
          path: final-result.txt

  job_3:
    runs-on: ubuntu-latest
    needs: job_2
    steps:
      - name: Download final result
        uses: actions/download-artifact@v3
        with:
          name: final-result
      - name: Display result
        run: cat final-result.txt
",0
86,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=mac,Running jobs on larger runners - Targeting macOS larger runners in a workflow,"To run your workflows on macOS larger runners, set the value of the runs-on key to a label associated with a macOS larger runner. For a list of macOS larger runner labels, see Available macOS larger runners . In this example, the workflow uses a label that is associated with macOS XL runners. The runs-on key sends the job to any available runner with a matching label:","name: learn-github-actions-testing
on: [push]
jobs:
  build:
    runs-on: macos-13-xlarge
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: swift build
      - name: Run tests
        run: swift test","jobs:
  build:
    runs-on: macos-12-xl
    steps:
      - uses: actions/checkout@v3
",0
87,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - inputs - Example: Specifying inputs,"Optional Input parameters allow you to specify data that the action expects to use during runtime. GitHub stores input parameters as environment variables. We recommend using lowercase input ids. This example configures two inputs: num-octocats and octocat-eye-color . The num-octocats input is not required and will default to a value of 1 . octocat-eye-color is required and has no default value. Note  Actions usingrequired: truewill not automatically return an error if the input is not specified. Note Actions using required: true will not automatically return an error if the input is not specified. Workflow files that use this action can use the with keyword to set an input value for octocat-eye-color . For more information about the with syntax, see Workflow syntax for GitHub Actions .","inputs:
  num-octocats:
    description: 'Number of Octocats'
    required: false
    default: '1'
  octocat-eye-color:
    description: 'Eye color of the Octocats'
    required: true","inputs:
  num-octocats:
    description: 'Number of octocats'
    required: false
    default: 1
  octocat-eye-color:
    description: 'Eye color of the octocat'
    required: true
",0
88,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - outputs for Docker container and JavaScript actions - Example: Declaring outputs for Docker container and JavaScript actions,"Optional Output parameters allow you to declare data that an action sets. Actions that run later in a workflow can use the output data set in previously run actions. For example, if you had an action that performed the addition of two inputs (x + y = z), the action could output the sum (z) for other actions to use as an input. Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. If you don't declare an output in your action metadata file, you can still set outputs and use them in a workflow. For more information on setting outputs in an action, see Workflow commands for GitHub Actions .","outputs:
  sum: # id of the output
    description: 'The sum of the inputs'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run Docker action
        uses: docker://my-docker-action:latest
        id: docker_action
        with:
          input1: value1
          input2: value2

      - name: Use Docker action output
        run: echo ""Docker action output: ${{ steps.docker_action.outputs.output_name }}""

      - name: Run JavaScript action
        uses: my-js-action@v1
        id: js_action
        with:
          input1: value1
          input2: value2

      - name: Use JavaScript action output
        run: echo ""JavaScript action output: ${{ steps.js_action.outputs.output_name }}""
",0
89,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - outputs for composite actions - Example: Declaring outputs for composite actions,"Optional  outputs use the same parameters as outputs.<output_id> and outputs.<output_id>.description (see outputs for Docker container and JavaScript actions ), but also includes the value token. Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.","outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-id }}
runs:
  using: ""composite""
  steps:
    - id: random-number-generator
      run: echo ""random-id=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash","outputs:
  example_output:
    description: ""An example output for a composite action""
    value: ${{ steps.step_id.outputs.output_name }}
",0
90,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - Example: Using Node.js v20,Required Configures the path to the action's code and the runtime used to execute the code.,"runs:
  using: 'node20'
  main: 'main.js'","runs:
  using: 'node20'
  main: 'index.js'
",0
91,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.pre,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to run a script at the start of a job, before the main: action begins. For example, you can use pre: to run a prerequisite setup script. The runtime specified with the using syntax will execute this file. The pre: action always runs by default but you can override this using runs.pre-if . Note  runs.preis not supported for local actions. Note runs.pre is not supported for local actions. In this example, the pre: action runs a script called setup.js :","runs:
  using: 'node20'
  pre: 'setup.js'
  main: 'index.js'
  post: 'cleanup.js'","runs:
  using: 'node12'
  pre: 'setup.js'
  main: 'index.js'
",0
92,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.pre-if,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to define conditions for the pre: action execution. The pre: action will only run if the conditions in pre-if are met. If not set, then pre-if defaults to always() . In pre-if , status check functions evaluate against the job's status, not the action's own status. Note that the step context is unavailable, as no steps have run yet. In this example, cleanup.js only runs on Linux-based runners:","pre: 'cleanup.js'
  pre-if: runner.os == 'linux'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run pre-action
        uses: actions/javascript-action@v1
        with:
          pre: cleanup.js
        pre-if: runner.os == 'Linux'
",0
93,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.post,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to run a script at the end of a job, once the main: action has completed. For example, you can use post: to terminate certain processes or remove unneeded files. The runtime specified with the using syntax will execute this file. In this example, the post: action runs a script called cleanup.js :","runs:
  using: 'node20'
  main: 'index.js'
  post: 'cleanup.js'","runs:
  using: 'node12'
  main: 'index.js'
  post: 'cleanup.js'
",0
94,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.post-if,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to define conditions for the post: action execution. The post: action will only run if the conditions in post-if are met. If not set, then post-if defaults to always() . In post-if , status check functions evaluate against the job's status, not the action's own status. For example, this cleanup.js will only run on Linux-based runners:","post: 'cleanup.js'
  post-if: runner.os == 'linux'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run JavaScript action
        uses: ./path-to-action
        with:
          node-version: '14'
    post:
      - name: Cleanup
        if: runner.os == 'Linux'
        run: node cleanup.js
",0
95,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].run,Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional The command you want to run. This can be inline or a script in your action repository:,"runs:
  using: ""composite""
  steps:
    - run: ${{ github.action_path }}/test/script.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
96,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].run,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional The command you want to run. This can be inline or a script in your action repository: Alternatively, you can use $GITHUB_ACTION_PATH :","runs:
  using: ""composite""
  steps:
    - run: $GITHUB_ACTION_PATH/script.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
97,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: success()
      run: echo ""This step runs only if the previous steps were successful.""
",0
98,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Example: Using contexts This step only runs when the event type is a pull_request and the event action is unassigned .","steps:
  - run: echo This event is a pull request that had an assignee removed.
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
      run: echo ""This step runs only for unassigned pull requests.""
",0
99,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Example: Using contexts This step only runs when the event type is a pull_request and the event action is unassigned . Example: Using status check functions The my backup step only runs when the previous step of a composite action fails. For more information, see Evaluate expressions in workflows and actions .","steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
      run: echo ""This step runs on pull_request with unassigned action""
    - name: My Backup Step
      if: failure()
      run: echo ""This step runs if the previous step fails""
",0
100,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].uses,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag number. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required.","runs:
  using: ""composite""
  steps:
    # Reference a specific commit
    - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
    # Reference the major version of a release
    - uses: actions/checkout@v4
    # Reference a specific version
    - uses: actions/checkout@v4.2.0
    # Reference a branch
    - uses: actions/checkout@main
    # References a subdirectory in a public GitHub repository at a specific branch, ref, or SHA
    - uses: actions/aws/ec2@main
    # References a local action
    - uses: ./.github/actions/my-action
    # References a docker public registry action
    - uses: docker://gcr.io/cloud-builders/gradle
    # Reference a docker image published on docker hub
    - uses: docker://alpine:3.8","runs:
  using: ""composite""
  steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v2
      with:
        node-version: '14'
    - run: npm install
    - run: npm test
",0
101,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].with,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional A map of the input parameters defined by the action. Each input parameter is a key/value pair. For more information, see Example: Specifying inputs .","runs:
  using: ""composite""
  steps:
    - name: My first step
      uses: actions/hello_world@main
      with:
        first_name: Mona
        middle_name: The
        last_name: Octocat","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
102,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - Example: Using a Dockerfile in your repository,Required Configures the image used for the Docker container action.,"runs:
  using: 'docker'
  image: 'Dockerfile'","runs:
  using: 'docker'
  image: 'Dockerfile'
",0
103,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - Example: Using public Docker registry container,Required Configures the image used for the Docker container action.,"runs:
  using: 'docker'
  image: 'docker://debian:stretch-slim'","runs:
  using: 'docker'
  image: 'docker://<public-docker-registry-image>'
",0
104,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.pre-entrypoint,"Required Configures the image used for the Docker container action. Optional Allows you to run a script before the entrypoint action begins. For example, you can use pre-entrypoint: to run a prerequisite setup script. GitHub Actions uses docker run to launch this action, and runs the script inside a new container that uses the same base image. This means that the runtime state is different from the main entrypoint container, and any states you require must be accessed in either the workspace, HOME , or as a STATE_ variable. The pre-entrypoint: action always runs by default but you can override this using runs.pre-if . The runtime specified with the using syntax will execute this file. In this example, the pre-entrypoint: action runs a script called setup.sh :","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  pre-entrypoint: 'setup.sh'
  entrypoint: 'main.sh'","runs:
  using: 'docker'
  image: 'your-docker-image'
  pre-entrypoint: 'setup.sh'
",0
105,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.post-entrypoint,"Required Configures the image used for the Docker container action. Optional Allows you to run a cleanup script once the runs.entrypoint action has completed. GitHub Actions uses docker run to launch this action. Because GitHub Actions runs the script inside a new container using the same base image, the runtime state is different from the main entrypoint container. You can access any state you need in either the workspace, HOME , or as a STATE_ variable. The post-entrypoint: action always runs by default but you can override this using runs.post-if .","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  entrypoint: 'main.sh'
  post-entrypoint: 'cleanup.sh'","runs:
  post-entrypoint: cleanup-script.sh
",0
106,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.args - Example: Defining arguments for the Docker container,"Required Configures the image used for the Docker container action. Optional An array of strings that define the inputs for a Docker container. Inputs can include hardcoded strings. GitHub passes the args to the container's ENTRYPOINT when the container starts up. The args are used in place of the CMD instruction in a Dockerfile . If you use CMD in your Dockerfile , use the guidelines ordered by preference: If you need to pass environment variables into an action, make sure your action runs a command shell to perform variable substitution. For example, if your entrypoint attribute is set to ""sh -c"" , args will be run in a command shell. Alternatively, if your Dockerfile uses an ENTRYPOINT to run the same command ( ""sh -c"" ), args will execute in a command shell. For more information about using the CMD instruction with GitHub Actions, see Dockerfile support for GitHub Actions .","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.greeting }}
    - 'foo'
    - 'bar'","runs:
  using: 'docker'
  image: 'docker://your-docker-image'
  args: ['your', 'arguments', 'here']
",0
107,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - branding - Example: Configuring branding for an action,Optional You can use a color and Feather icon to create a badge to personalize and distinguish your action. Badges are shown next to your action name in GitHub Marketplace .,"branding:
  icon: 'award'
  color: 'green'","branding:
  color: ""blue""
  icon: ""zap""
",0
108,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Specifying a .NET version - Using multiple .NET versions,"To use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use the setup-dotnet action. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries to PATH . These changes will persist for the remainder of the job. The setup-dotnet action is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it to PATH . For more information, see the setup-dotnet action.","name: dotnet package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: [ '3.1.x', '6.0.x' ]

    steps:
      - uses: actions/checkout@v4
      - name: Setup dotnet ${{ matrix.dotnet-version }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.dotnet-version }}
      # You can test your matrix by printing the current dotnet version
      - name: Display dotnet version
        run: dotnet --version","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: [ '3.1.x', '5.0.x', '6.0.x' ]
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    - name: Build with dotnet
      run: dotnet build
    - name: Test with dotnet
      run: dotnet test
",0
109,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Specifying a .NET version - Using a specific .NET version,"To use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use the setup-dotnet action. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries to PATH . These changes will persist for the remainder of the job. The setup-dotnet action is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it to PATH . For more information, see the setup-dotnet action. You can configure your job to use a specific version of .NET, such as 6.0.22 . Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of .NET 6.","- name: Setup .NET 6.x
      uses: actions/setup-dotnet@v4
      with:
        # Semantic version range syntax or exact version of a dotnet version
        dotnet-version: '6.x'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 6.0.x
      - run: dotnet build
      - run: dotnet test
",0
110,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Installing dependencies,"GitHub-hosted runners have the NuGet package manager installed. You can use the dotnet CLI to install dependencies from the NuGet package registry before building and testing your code. For example, the YAML below installs the Newtonsoft package.","steps:
- uses: actions/checkout@v4
- name: Setup dotnet
  uses: actions/setup-dotnet@v4
  with:
    dotnet-version: '6.0.x'
- name: Install dependencies
  run: dotnet add package Newtonsoft.Json --version 12.0.1","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup .NET
        uses: actions/setup-dotnet@v2
        with:
          dotnet-version: '6.0.x'
      - name: Install dependencies
        run: dotnet add package Newtonsoft.Json
      - name: Build
        run: dotnet build --configuration Release
      - name: Test
        run: dotnet test --no-build --verbosity normal
",0
111,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Installing dependencies - Caching dependencies,"GitHub-hosted runners have the NuGet package manager installed. You can use the dotnet CLI to install dependencies from the NuGet package registry before building and testing your code. For example, the YAML below installs the Newtonsoft package. You can cache NuGet dependencies for future workflows using the optional cache input. For example, the YAML below caches the NuGet global-packages folder, and then installs the Newtonsoft package. A second optional input, cache-dependency-path , can be used to specify the path to a dependency file: packages.lock.json . For more information, see Caching dependencies to speed up workflows .","steps:
- uses: actions/checkout@v4
- name: Setup dotnet
  uses: actions/setup-dotnet@v4
  with:
    dotnet-version: '6.x'
    cache: true
- name: Install dependencies
  run: dotnet add package Newtonsoft.Json --version 12.0.1","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: '6.0.x'
    - name: Cache NuGet packages
      uses: actions/cache@v2
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Install dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Test
      run: dotnet test --no-build --verbosity normal
",0
112,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Building and testing your code,You can use the same commands that you use locally to build and test your code. This example demonstrates how to use dotnet build and dotnet test in a job:,"steps:
- uses: actions/checkout@v4
- name: Setup dotnet
  uses: actions/setup-dotnet@v4
  with:
    dotnet-version: '6.0.x'
- name: Install dependencies
  run: dotnet restore
- name: Build
  run: dotnet build --no-restore
- name: Test with the dotnet CLI
  run: dotnet test --no-build","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.x'
      - name: Build
        run: dotnet build
      - name: Test
        run: dotnet test
",0
113,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Packaging workflow data as artifacts,"After a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the upload-artifact action to upload test results. For more information, see Storing and sharing data from a workflow .","name: dotnet package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: [ '3.1.x', '6.0.x' ]

      steps:
        - uses: actions/checkout@v4
        - name: Setup dotnet
          uses: actions/setup-dotnet@v4
          with:
            dotnet-version: ${{ matrix.dotnet-version }}
        - name: Install dependencies
          run: dotnet restore
        - name: Test with dotnet
          run: dotnet test --no-restore --logger trx --results-directory ""TestResults-${{ matrix.dotnet-version }}""
        - name: Upload dotnet test results
          uses: actions/upload-artifact@v4
          with:
            name: dotnet-results-${{ matrix.dotnet-version }}
            path: TestResults-${{ matrix.dotnet-version }}
          # Use always() to always run this step to publish test results when there are test failures
          if: ${{ always() }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: '6.0.x'
    - name: Build with dotnet
      run: dotnet build --configuration Release
    - name: Test with dotnet
      run: dotnet test --logger ""trx;LogFileName=test_results.trx""
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: '**/*.trx'
",0
114,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net,Building and testing .NET - Publishing to package registries,You can configure your workflow to publish your .NET package to a package registry when your CI tests pass. You can use repository secrets to store any tokens or credentials needed to publish your binary. The following example creates and publishes a package to GitHub Packages using dotnet core cli .,"name: Upload dotnet package

on:
  release:
    types: [created]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x' # SDK Version to use.
          source-url: https://nuget.pkg.github.com/<owner>/index.json
        env:
          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}
      - run: dotnet build --configuration Release <my project>
      - name: Create the package
        run: dotnet pack --configuration Release <my project>
      - name: Publish the package to GPR
        run: dotnet nuget push <my project>/bin/Release/*.nupkg","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: '6.0.x'
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --configuration Release --no-restore
    - name: Test
      run: dotnet test --no-restore --verbosity normal
    - name: Publish to GitHub Packages
      run: dotnet nuget push '**/*.nupkg' --source 'github'
      env:
        NUGET_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
",0
115,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: PostgreSQL service example
on: push

jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to PostgreSQL
        # Runs a script that creates a PostgreSQL table, populates
        # the table with data, and then retrieves the data.
        run: node client.js
        # Environment variables used by the `client.js` script to create a new PostgreSQL table.
        env:
          # The hostname used to communicate with the PostgreSQL service container
          POSTGRES_HOST: postgres
          # The default PostgreSQL port
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: user
          POSTGRES_PASSWORD: password
          POSTGRES_DB: mydb
        options: --health-cmd=""pg_isready"" --health-interval=10s --health-timeout=5s --health-retries=5
    steps:
    - name: Check PostgreSQL service
      run: |
        until pg_isready -h postgres; do
          echo ""Waiting for PostgreSQL...""
          sleep 2
        done
",0
116,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs in containers - Configuring the runner job for jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. This workflow configures a job that runs in the node:20-bookworm-slim container and uses the ubuntu-latest GitHub-hosted runner as the Docker host for the container. For more information about the node:20-bookworm-slim container, see the node image on Docker Hub. The workflow configures a service container with the label postgres . All services must run in a container, so each service requires that you specify the container image . This example uses the postgres container image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see the postgres image on Docker Hub.","jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: node:20-bookworm-slim
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd=""pg_isready -U postgres""
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
",0
117,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs in containers - Configuring the steps for jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to PostgreSQL
    # Runs a script that creates a PostgreSQL table, populates
    # the table with data, and then retrieves the data.
    run: node client.js
    # Environment variable used by the `client.js` script to create
    # a new PostgreSQL client.
    env:
      # The hostname used to communicate with the PostgreSQL service container
      POSTGRES_HOST: postgres
      # The default PostgreSQL port
      POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: user
          POSTGRES_PASSWORD: password
          POSTGRES_DB: mydb
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
      - name: Connect to PostgreSQL
        run: |
          apt-get update
          apt-get install -y postgresql-client
          psql -h postgres -U user -d mydb -c ""SELECT 1;""
        env:
          PGPASSWORD: password
",0
118,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: PostgreSQL Service Example
on: push

jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps tcp port 5432 on service container to the host
          - 5432:5432

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to PostgreSQL
        # Runs a script that creates a PostgreSQL table, populates
        # the table with data, and then retrieves the data
        run: node client.js
        # Environment variables used by the `client.js` script to create
        # a new PostgreSQL table.
        env:
          # The hostname used to communicate with the PostgreSQL service container
          POSTGRES_HOST: localhost
          # The default PostgreSQL port
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
    steps:
      - name: Check out repository
        uses: actions/checkout@v3
      - name: Run a command
        run: |
          echo ""PostgreSQL is running on localhost:5432""
",0
119,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs directly on the runner machine - Configuring the runner job for jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The example uses the ubuntu-latest GitHub-hosted runner as the Docker host. The workflow configures a service container with the label postgres . All services must run in a container, so each service requires that you specify the container image . This example uses the postgres container image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see the postgres image on Docker Hub. The workflow maps port 5432 on the PostgreSQL service container to the Docker host. For more information about the ports keyword, see About service containers .","jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps tcp port 5432 on service container to the host
          - 5432:5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd=""pg_isready -U postgres""
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    steps:
      - name: Check PostgreSQL service
        run: |
          until pg_isready -h localhost -p 5432 -U postgres; do
            echo ""Waiting for PostgreSQL...""
            sleep 2
          done
",0
120,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs directly on the runner machine - Configuring the steps for jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to PostgreSQL
    # Runs a script that creates a PostgreSQL table, populates
    # the table with data, and then retrieves the data
    run: node client.js
    # Environment variables used by the `client.js` script to create
    # a new PostgreSQL table.
    env:
      # The hostname used to communicate with the PostgreSQL service container
      POSTGRES_HOST: localhost
      # The default PostgreSQL port
      POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""PostgreSQL service is running on localhost:5432""
",0
121,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - About workflow triggers - Triggering a workflow from a workflow,"Workflow triggers are events that cause a workflow to run. These events can be: For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened. Workflow triggers are defined with the on key. For more information, see Workflow syntax for GitHub Actions . The following steps occur to trigger a workflow run: An event occurs on your repository. The event has an associated commit SHA and Git ref. GitHub searches the .github/workflows directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event. A workflow run is triggered for any workflows that have on: values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run. Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) environment variables in the runner environment. For more information, see Store information in variables . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. For more information, see Automatic token authentication . If you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of GITHUB_TOKEN to trigger events that require a token. If you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow . If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see Managing your personal access tokens . For more information about storing secrets, see Using secrets in GitHub Actions . To minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs. For example, the following workflow uses a personal access token (stored as a secret called MY_TOKEN ) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed.","on:
  issues:
    types:
      - opened

jobs:
  label_issue:
    runs-on: ubuntu-latest
    steps:
      - env:
          GH_TOKEN: ${{ secrets.MY_TOKEN }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          gh issue edit $ISSUE_URL --add-label ""triage""","jobs:
  add_label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Add label to issue
        env:
          GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}
        run: gh issue edit ${{ github.event.issue.number }} --add-label ""new-label""
",0
122,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - About workflow triggers - Triggering a workflow from a workflow,"Workflow triggers are events that cause a workflow to run. These events can be: For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened. Workflow triggers are defined with the on key. For more information, see Workflow syntax for GitHub Actions . The following steps occur to trigger a workflow run: An event occurs on your repository. The event has an associated commit SHA and Git ref. GitHub searches the .github/workflows directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event. A workflow run is triggered for any workflows that have on: values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run. Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) environment variables in the runner environment. For more information, see Store information in variables . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. For more information, see Automatic token authentication . If you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of GITHUB_TOKEN to trigger events that require a token. If you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow . If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see Managing your personal access tokens . For more information about storing secrets, see Using secrets in GitHub Actions . To minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs. For example, the following workflow uses a personal access token (stored as a secret called MY_TOKEN ) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed. Conversely, the following workflow uses GITHUB_TOKEN to add a label to an issue. It will not trigger any workflows that run when a label is added.","on:
  issues:
    types:
      - opened

jobs:
  label_issue:
    runs-on: ubuntu-latest
    steps:
      - env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          gh issue edit $ISSUE_URL --add-label ""triage""","jobs:
  add_label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Add label with personal access token
        env:
          GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}
        run: gh issue edit 1 --add-label ""bug""
",0
123,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using events to trigger workflows - Using a single event,"Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows . For example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:",on: push,"on: push
",0
124,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using events to trigger workflows - Using multiple events,"Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows . You can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:","on: [push, fork]","on:
  push:
    branches:
      - '**'
  fork:
",0
125,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using events to trigger workflows - Using activity types and filters with multiple events,"Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows . You can use activity types and filters to further control when your workflow will run. For more information, see Using event activity types and Using filters . If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon ( : ) to all events, including events without configuration. For example, a workflow with the following on value will run when:","on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:","on:
  push:
  pull_request:
    types: [opened, closed]
  issues:
    types: [opened, edited]
",0
126,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using event activity types,"Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.","on:
  label:
    types:
      - created","on:
  label:
    types: [created]
",0
127,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using event activity types,"Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted. If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.","on:
  issues:
    types:
      - opened
      - labeled","on:
  issues:
    types: [opened, labeled]
",0
128,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.","on:
  push:
    branches:
      - main
      - 'releases/**'","on:
  push:
    branches:
      - 'main'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
129,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for pull request events - Example: Including branches,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'","pull_request:
  branches:
    - 'main'
    - 'release/*'
",0
130,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for pull request events - Example: Excluding branches,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'","pull_request:
  branches-ignore:
    - 'main'
    - 'release/*'
",0
131,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for pull request events - Example: Including and excluding branches,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. The order that you define patterns matters. The following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona , but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","pull_request:
  branches:
    - releases/10
    - releases/beta/mona
    - '!releases/**-alpha'
",0
132,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches or tags for push events - Example: Including branches and tags,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*","on:
  push:
    branches:
      - 'main'
      - 'release/*'
    tags:
      - 'v1.*'
      - 'v2.*'
",0
133,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches or tags for push events - Example: Excluding branches and tags,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*","on:
  push:
    branches-ignore:
      - 'main'
      - 'release/*'
    tags-ignore:
      - 'v1.*'
",0
134,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches or tags for push events - Example: Including and excluding branches and tags,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead. The order that you define patterns matters. The following workflow will run on pushes to releases/10 or releases/beta/mona , but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  push:
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/**-alpha'
",0
135,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific paths for pull request or push events - Example: Including paths,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . If at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file ( .js ).","on:
  push:
    paths:
      - '**.js'","on:
  push:
    paths:
      - '**/*.js'
  pull_request:
    paths:
      - '**/*.js'
",0
136,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific paths for pull request or push events - Example: Excluding paths,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . When all the path names match patterns in paths-ignore , the workflow will not run. If any path names do not match patterns in paths-ignore , even if some path names match the patterns, the workflow will run. A workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.","on:
  push:
    paths-ignore:
      - 'docs/**'","on:
  push:
    paths-ignore:
      - 'docs/**'
",0
137,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific paths for pull request or push events - Example: Including and excluding paths,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . You cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. If you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead. This example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.","on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'","on:
  push:
    paths:
      - sub-project/**
      - '!sub-project/docs/**'
",0
138,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for workflow run events,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - releases/**
",0
139,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for workflow run events,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches-ignore:
      - ""canary""","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - ""releases/*""
    branches-ignore:
      - ""canary""
",0
140,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for workflow run events,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary : You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. The order that you define patterns matters. For example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha , releases/beta/3-alpha , or main .","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","workflow_run:
  workflows: [""Build""]
  branches:
    - releases/10
    - releases/beta/mona
    - '!releases/10-alpha'
    - '!releases/beta/3-alpha'
    - '!main'
",0
141,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Defining inputs for manually triggered workflows,"When using the workflow_dispatch event, you can optionally specify inputs that are passed to the workflow. This trigger only receives events when the workflow file is on the default branch.
The triggered workflow receives the inputs in the inputs context. For more information, see Contexts . Note    The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.The maximum number of top-level properties forinputsis 10.The maximum payload forinputsis 65,535 characters. Note","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
      print_tags:
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    if: ${{ inputs.print_tags }} 
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }}","on:
  workflow_dispatch:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        default: 'default_value'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""Input value: ${{ inputs.example_input }}""
",0
142,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using event information - Viewing all properties of an event,"Information about the event that triggered a workflow run is available in the github.event context. The properties in the github.event context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label. Reference the webhook event documentation for common properties and example payloads. For more information, see Webhook events and payloads . You can also print the entire github.event context to see what properties are available for the event that triggered your workflow:","jobs:
  print_context:
    runs-on: ubuntu-latest
    steps:
      - env:
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
        run: |
          echo $EVENT_CONTEXT","jobs:
  print-event:
    runs-on: ubuntu-latest
    steps:
      - name: Print github.event context
        env:
          EVENT_CONTEXT: ${{ toJson(github.event) }}
        run: echo ""$EVENT_CONTEXT""
",0
143,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Using event information - Accessing and using event properties,"Information about the event that triggered a workflow run is available in the github.event context. The properties in the github.event context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label. You can use the github.event context in your workflow. For example, the following workflow runs when a pull request that changes package*.json , .github/CODEOWNERS , or .github/workflows/** is opened. If the pull request author ( github.event.pull_request.user.login ) is not octobot or dependabot[bot] , then the workflow uses the GitHub CLI to label and comment on the pull request ( github.event.pull_request.number ).","on:
  pull_request:
    types:
      - opened
    paths:
      - '.github/workflows/**'
      - '.github/CODEOWNERS'
      - 'package*.json'

jobs:
  triage:
    if: >-
      github.event.pull_request.user.login != 'octobot' &&
      github.event.pull_request.user.login != 'dependabot[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: ""Comment about changes we can't accept""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR: ${{ github.event.pull_request.html_url }}
        run: |
          gh pr edit $PR --add-label 'invalid'
          gh pr comment $PR --body 'It looks like you edited `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**`. We do not allow contributions to these files. Please review our [contributing guidelines](https://github.com/octo-org/octo-repo/blob/main/CONTRIBUTING.md) for what contributions are accepted.'","on:
  pull_request:
    types: [opened]
    paths:
      - 'package*.json'
      - '.github/CODEOWNERS'
      - '.github/workflows/**'

jobs:
  label_and_comment:
    runs-on: ubuntu-latest
    steps:
      - name: Check PR author
        if: ${{ github.event.pull_request.user.login != 'octobot' && github.event.pull_request.user.login != 'dependabot[bot]' }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body ""Thank you for your contribution!""
          gh pr edit ${{ github.event.pull_request.number }} --add-label ""needs review""
",0
144,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Further controlling how your workflow will run - Using conditionals - Example using a value in the event payload,"If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run. You can use conditionals to further control whether jobs or steps in your workflow will run. For example, if you want the workflow to run when a specific label is added to an issue, you can trigger on the issues labeled event activity type and use a conditional to check what label triggered the workflow. The following workflow will run when any label is added to an issue in the workflow's repository, but the run_if_label_matches job will only execute if the label is named bug .","on:
  issues:
    types:
      - labeled

jobs:
  run_if_label_matches:
    if: github.event.label.name == 'bug'
    runs-on: ubuntu-latest
    steps:
      - run: echo 'The label was bug'","on:
  issues:
    types: [labeled]

jobs:
  run_if_label_matches:
    if: contains(github.event.label.name, 'bug')
    runs-on: ubuntu-latest
    steps:
      - name: Run a script
        run: echo ""The 'bug' label was added to an issue.""
",0
145,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Further controlling how your workflow will run - Using conditionals - Example using event type,"If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run. You can use conditionals to further control whether jobs or steps in your workflow will run. For example, if you want to run different jobs or steps depending on what event triggered the workflow, you can use a conditional to check whether a specific event type exists in the event context. The following workflow will run whenever an issue or pull request is closed. If the workflow ran because an issue was closed, the github.event context will contain a value for issue but not for pull_request . Therefore, the if_issue step will run but the if_pr step will not run. Conversely, if the workflow ran because a pull request was closed, the if_pr step will run but the if_issue step will not run.","on:
  issues:
    types:
      - closed
  pull_request:
    types:
      - closed

jobs:
  state_event_type:
    runs-on: ubuntu-latest
    steps:
    - name: if_issue
      if: github.event.issue
      run: |
        echo An issue was closed
    - name: if_pr
      if: github.event.pull_request
      run: |
        echo A pull request was closed","jobs:
  conditional-job:
    runs-on: ubuntu-latest
    steps:
      - name: if_issue
        if: ${{ github.event.issue }}
        run: echo ""An issue was closed.""
      - name: if_pr
        if: ${{ github.event.pull_request }}
        run: echo ""A pull request was closed.""
",0
146,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow,Triggering a workflow - Further controlling how your workflow will run - Using environments to manually trigger workflow jobs,"If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run. If you want to manually trigger a specific job in a workflow, you can use an environment that requires approval from a specific team or user. First, configure an environment with required reviewers. For more information, see Managing environments for deployment . Then, reference the environment name in a job in your workflow using the environment: key. Any job referencing the environment will not run until at least one reviewer approves the job. For example, the following workflow will run whenever there is a push to main. The build job will always run. The publish job will only run after the build job successfully completes (due to needs: [build] ) and after all of the rules (including required reviewers) for the environment called production pass (due to environment: production ).","on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: build
        run: |
          echo 'building'

  publish:
    needs: [build]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: publish
        run: |
          echo 'publishing'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building...""

  publish:
    runs-on: ubuntu-latest
    needs: [build]
    environment: production
    steps:
      - run: echo ""Publishing...""
",0
147,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - inputs - Example: Specifying inputs,"Optional Input parameters allow you to specify data that the action expects to use during runtime. GitHub stores input parameters as environment variables. We recommend using lowercase input ids. This example configures two inputs: num-octocats and octocat-eye-color . The num-octocats input is not required and will default to a value of 1 . octocat-eye-color is required and has no default value. Note  Actions usingrequired: truewill not automatically return an error if the input is not specified. Note Actions using required: true will not automatically return an error if the input is not specified. Workflow files that use this action can use the with keyword to set an input value for octocat-eye-color . For more information about the with syntax, see Workflow syntax for GitHub Actions .","inputs:
  num-octocats:
    description: 'Number of Octocats'
    required: false
    default: '1'
  octocat-eye-color:
    description: 'Eye color of the Octocats'
    required: true","inputs:
  num-octocats:
    description: 'Number of octocats'
    required: false
    default: 1
  octocat-eye-color:
    description: 'Eye color of the octocat'
    required: true
",0
148,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - outputs for Docker container and JavaScript actions - Example: Declaring outputs for Docker container and JavaScript actions,"Optional Output parameters allow you to declare data that an action sets. Actions that run later in a workflow can use the output data set in previously run actions. For example, if you had an action that performed the addition of two inputs (x + y = z), the action could output the sum (z) for other actions to use as an input. Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. If you don't declare an output in your action metadata file, you can still set outputs and use them in a workflow. For more information on setting outputs in an action, see Workflow commands for GitHub Actions .","outputs:
  sum: # id of the output
    description: 'The sum of the inputs'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run Docker action
        uses: ./path/to/docker-action
        id: docker-action
        with:
          input1: value1
          input2: value2

      - name: Use Docker action output
        run: echo ""Output from Docker action: ${{ steps.docker-action.outputs.output_name }}""

      - name: Run JavaScript action
        uses: ./path/to/javascript-action
        id: js-action
        with:
          input1: value1
          input2: value2

      - name: Use JavaScript action output
        run: echo ""Output from JavaScript action: ${{ steps.js-action.outputs.output_name }}""
",0
149,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - outputs for composite actions - Example: Declaring outputs for composite actions,"Optional  outputs use the same parameters as outputs.<output_id> and outputs.<output_id>.description (see outputs for Docker container and JavaScript actions ), but also includes the value token. Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.","outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-id }}
runs:
  using: ""composite""
  steps:
    - id: random-number-generator
      run: echo ""random-id=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash","outputs:
  example_output:
    description: ""An example output for a composite action""
    value: ${{ steps.step_id.outputs.output_name }}
",0
150,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - Example: Using Node.js v20,Required Configures the path to the action's code and the runtime used to execute the code.,"runs:
  using: 'node20'
  main: 'main.js'","runs:
  using: 'node20'
  main: 'index.js'
",0
151,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.pre,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to run a script at the start of a job, before the main: action begins. For example, you can use pre: to run a prerequisite setup script. The runtime specified with the using syntax will execute this file. The pre: action always runs by default but you can override this using runs.pre-if . Note  runs.preis not supported for local actions. Note runs.pre is not supported for local actions. In this example, the pre: action runs a script called setup.js :","runs:
  using: 'node20'
  pre: 'setup.js'
  main: 'index.js'
  post: 'cleanup.js'","runs:
  using: 'node12'
  main: 'index.js'
  pre: 'setup.js'
",0
152,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.pre-if,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to define conditions for the pre: action execution. The pre: action will only run if the conditions in pre-if are met. If not set, then pre-if defaults to always() . In pre-if , status check functions evaluate against the job's status, not the action's own status. Note that the step context is unavailable, as no steps have run yet. In this example, cleanup.js only runs on Linux-based runners:","pre: 'cleanup.js'
  pre-if: runner.os == 'linux'","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run pre-action
        uses: actions/javascript-action@v1
        with:
          pre: cleanup.js
        pre-if: runner.os == 'Linux'
",0
153,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.post,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to run a script at the end of a job, once the main: action has completed. For example, you can use post: to terminate certain processes or remove unneeded files. The runtime specified with the using syntax will execute this file. In this example, the post: action runs a script called cleanup.js :","runs:
  using: 'node20'
  main: 'index.js'
  post: 'cleanup.js'","runs:
  using: 'node12'
  main: 'index.js'
  post: 'cleanup.js'
",0
154,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.post-if,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to define conditions for the post: action execution. The post: action will only run if the conditions in post-if are met. If not set, then post-if defaults to always() . In post-if , status check functions evaluate against the job's status, not the action's own status. For example, this cleanup.js will only run on Linux-based runners:","post: 'cleanup.js'
  post-if: runner.os == 'linux'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run main action
        uses: ./path-to-action
      - name: Cleanup
        if: runner.os == 'Linux'
        run: node cleanup.js
",0
155,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].run,Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional The command you want to run. This can be inline or a script in your action repository:,"runs:
  using: ""composite""
  steps:
    - run: ${{ github.action_path }}/test/script.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
156,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].run,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional The command you want to run. This can be inline or a script in your action repository: Alternatively, you can use $GITHUB_ACTION_PATH :","runs:
  using: ""composite""
  steps:
    - run: $GITHUB_ACTION_PATH/script.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
157,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: success()
      run: echo ""This step runs only if the previous steps were successful.""
",0
158,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Example: Using contexts This step only runs when the event type is a pull_request and the event action is unassigned .","steps:
  - run: echo This event is a pull request that had an assignee removed.
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}","runs:
  using: ""composite""
  steps:
    - if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
      run: echo ""This step runs only for unassigned pull_request events.""
",0
159,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Example: Using contexts This step only runs when the event type is a pull_request and the event action is unassigned . Example: Using status check functions The my backup step only runs when the previous step of a composite action fails. For more information, see Evaluate expressions in workflows and actions .","steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
      run: echo ""This step runs on pull_request with unassigned action""
    - name: My Backup Step
      if: failure()
      run: echo ""This step runs if the previous step fails""
",0
160,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].uses,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag number. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required.","runs:
  using: ""composite""
  steps:
    # Reference a specific commit
    - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
    # Reference the major version of a release
    - uses: actions/checkout@v4
    # Reference a specific version
    - uses: actions/checkout@v4.2.0
    # Reference a branch
    - uses: actions/checkout@main
    # References a subdirectory in a public GitHub repository at a specific branch, ref, or SHA
    - uses: actions/aws/ec2@main
    # References a local action
    - uses: ./.github/actions/my-action
    # References a docker public registry action
    - uses: docker://gcr.io/cloud-builders/gradle
    # Reference a docker image published on docker hub
    - uses: docker://alpine:3.8","runs:
  using: ""composite""
  steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v2
      with:
        node-version: '14'
    - run: npm install
    - run: npm test
",0
161,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].with,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional A map of the input parameters defined by the action. Each input parameter is a key/value pair. For more information, see Example: Specifying inputs .","runs:
  using: ""composite""
  steps:
    - name: My first step
      uses: actions/hello_world@main
      with:
        first_name: Mona
        middle_name: The
        last_name: Octocat","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
162,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for Docker container actions - Example: Using a Dockerfile in your repository,Required Configures the image used for the Docker container action.,"runs:
  using: 'docker'
  image: 'Dockerfile'","runs:
  using: 'docker'
  image: 'Dockerfile'
",0
163,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for Docker container actions - Example: Using public Docker registry container,Required Configures the image used for the Docker container action.,"runs:
  using: 'docker'
  image: 'docker://debian:stretch-slim'","runs:
  using: 'docker'
  image: 'docker://<public-docker-registry-image>'
",0
164,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.pre-entrypoint,"Required Configures the image used for the Docker container action. Optional Allows you to run a script before the entrypoint action begins. For example, you can use pre-entrypoint: to run a prerequisite setup script. GitHub Actions uses docker run to launch this action, and runs the script inside a new container that uses the same base image. This means that the runtime state is different from the main entrypoint container, and any states you require must be accessed in either the workspace, HOME , or as a STATE_ variable. The pre-entrypoint: action always runs by default but you can override this using runs.pre-if . The runtime specified with the using syntax will execute this file. In this example, the pre-entrypoint: action runs a script called setup.sh :","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  pre-entrypoint: 'setup.sh'
  entrypoint: 'main.sh'","runs:
  using: 'docker'
  image: 'your-docker-image'
  pre-entrypoint: 'setup.sh'
",0
165,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.post-entrypoint,"Required Configures the image used for the Docker container action. Optional Allows you to run a cleanup script once the runs.entrypoint action has completed. GitHub Actions uses docker run to launch this action. Because GitHub Actions runs the script inside a new container using the same base image, the runtime state is different from the main entrypoint container. You can access any state you need in either the workspace, HOME , or as a STATE_ variable. The post-entrypoint: action always runs by default but you can override this using runs.post-if .","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  entrypoint: 'main.sh'
  post-entrypoint: 'cleanup.sh'","runs:
  using: 'docker'
  image: 'your-docker-image'
  post-entrypoint: 'your-cleanup-script.sh'
",0
166,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.args - Example: Defining arguments for the Docker container,"Required Configures the image used for the Docker container action. Optional An array of strings that define the inputs for a Docker container. Inputs can include hardcoded strings. GitHub passes the args to the container's ENTRYPOINT when the container starts up. The args are used in place of the CMD instruction in a Dockerfile . If you use CMD in your Dockerfile , use the guidelines ordered by preference: If you need to pass environment variables into an action, make sure your action runs a command shell to perform variable substitution. For example, if your entrypoint attribute is set to ""sh -c"" , args will be run in a command shell. Alternatively, if your Dockerfile uses an ENTRYPOINT to run the same command ( ""sh -c"" ), args will execute in a command shell. For more information about using the CMD instruction with GitHub Actions, see Dockerfile support for GitHub Actions .","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.greeting }}
    - 'foo'
    - 'bar'","runs:
  using: 'docker'
  image: 'Dockerfile'
  args: ['arg1', 'arg2', 'arg3']
",0
167,https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions,Metadata syntax for GitHub Actions - branding - Example: Configuring branding for an action,Optional You can use a color and Feather icon to create a badge to personalize and distinguish your action. Badges are shown next to your action name in GitHub Marketplace .,"branding:
  icon: 'award'
  color: 'green'","branding:
  color: blue
  icon: zap
",0
168,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job,Choosing the runner for a job - Overview,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu :","runs-on: [self-hosted, linux, x64, gpu]","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
169,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job,Choosing the runner for a job - Overview,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example:","on:
  workflow_dispatch:
    inputs:
      chosen-os:
        required: true
        type: choice
        options:
        - Ubuntu
        - macOS

jobs:
  test:
    runs-on: [self-hosted, ""${{ inputs.chosen-os }}""]
    steps:
    - run: echo Hello world!","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
170,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job,Choosing the runner for a job - Choosing GitHub-hosted runners - Standard GitHub-hosted runners for  private repositories - Example: Specifying an operating system,"If you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by runs-on . The value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables. For more information, see About GitHub-hosted runners . For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions . In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners . Note  The-latestrunner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor. Note The -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor. Warning  Beta and Deprecated Images are provided ""as-is"", ""with all faults"" and ""as available"" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support. Warning Beta and Deprecated Images are provided ""as-is"", ""with all faults"" and ""as available"" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.",runs-on: ubuntu-latest,"jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
171,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job,Choosing the runner for a job - Choosing self-hosted runners - Example: Using labels for runner selection,"To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels. Self-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted . You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify. Note that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.","runs-on: [self-hosted, linux]","jobs:
  example-job:
    runs-on: [self-hosted, linux, x64]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
172,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job,Choosing the runner for a job - Choosing runners in a group - Example: Using groups to control where jobs are run,"You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels. Runner groups can only have larger runners or self-hosted runners as members. In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
173,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job,Choosing the runner for a job - Choosing runners in a group - Example: Combining groups and labels,"You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels. Runner groups can only have larger runners or self-hosted runners as members. When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
174,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow,Using jobs in a workflow - Setting an ID for a job - Example: Creating jobs,"Use jobs.<job_id> to give your job a unique identifier. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, - , or _ . In this example, two jobs have been created, and their job_id values are my_first_job and my_second_job .","jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

  my_second_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
175,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow,Using jobs in a workflow - Defining prerequisite jobs - Example: Requiring successful dependent jobs,"Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if .","jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building project""

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo ""Running tests""

  deploy:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - run: echo ""Deploying application""
",0
176,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow,Using jobs in a workflow - Defining prerequisite jobs - Example: Not requiring successful dependent jobs,"Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if .","jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Job 1""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ""Job 2""

  job3:
    runs-on: ubuntu-latest
    needs: job2
    if: always()
    steps:
      - run: echo ""Job 3""
",0
177,https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions,Deploying with GitHub Actions - Triggering your deployment,"You can use a variety of events to trigger your deployment workflow. Some of the most common are: pull_request , push , and workflow_dispatch . For example, a workflow with the following triggers runs whenever:","on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:","on:
  pull_request:
  push:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    - name: Deploy
      run: echo ""Deploying application...""
",0
178,https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions,Deploying with GitHub Actions - Using concurrency,"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see Control the concurrency of workflows and jobs . Note  concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. Note concurrency and environment are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. For example, when the following workflow runs, it will be paused with the status pending if any job or workflow that uses the production concurrency group is in progress. It will also cancel any job or workflow that uses the production concurrency group and has the status pending . This means that there will be a maximum of one running and one pending job or workflow in that uses the production concurrency group.","name: Deployment

concurrency: production

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying application""
",0
179,https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions,Deploying with GitHub Actions - Using concurrency,"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see Control the concurrency of workflows and jobs . Note  concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. Note concurrency and environment are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. For example, when the following workflow runs, it will be paused with the status pending if any job or workflow that uses the production concurrency group is in progress. It will also cancel any job or workflow that uses the production concurrency group and has the status pending . This means that there will be a maximum of one running and one pending job or workflow in that uses the production concurrency group. You can also specify concurrency at the job level. This will allow other jobs in the workflow to proceed even if the concurrent job is pending .","name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    concurrency: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying application""
",0
180,https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions,Deploying with GitHub Actions - Using concurrency,"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see Control the concurrency of workflows and jobs . Note  concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. Note concurrency and environment are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. For example, when the following workflow runs, it will be paused with the status pending if any job or workflow that uses the production concurrency group is in progress. It will also cancel any job or workflow that uses the production concurrency group and has the status pending . This means that there will be a maximum of one running and one pending job or workflow in that uses the production concurrency group. You can also specify concurrency at the job level. This will allow other jobs in the workflow to proceed even if the concurrent job is pending . You can also use cancel-in-progress to cancel any currently running job or workflow in the same concurrency group.","name: Deployment

concurrency:
  group: production
  cancel-in-progress: true

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: production
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying to production""
",0
181,https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-wireguard-to-create-a-network-overlay,Using WireGuard to create a network overlay - Example: Configuring WireGuard,"This example workflow configures WireGuard to connect to a private service. For this example, the WireGuard instance running in the private network has this configuration: The WireGuard instance in the GitHub Actions runner has this configuration:","name: WireGuard example

on:
  workflow_dispatch:

jobs:
  wireguard_example:
    runs-on: ubuntu-latest
    steps:
      - run: sudo apt install wireguard

      - run: echo ""${{ secrets.WIREGUARD_PRIVATE_KEY }}"" > privatekey

      - run: sudo ip link add dev wg0 type wireguard

      - run: sudo ip address add dev wg0 192.168.1.2 peer 192.168.1.1

      - run: sudo wg set wg0 listen-port 48123 private-key privatekey peer examplepubkey1234... allowed-ips 0.0.0.0/0 endpoint 1.2.3.4:56789

      - run: sudo ip link set up dev wg0

      - run: curl -vvv http://192.168.1.1","jobs:
  configure-wireguard:
    runs-on: ubuntu-latest
    steps:
      - name: Install WireGuard
        run: sudo apt-get update && sudo apt-get install -y wireguard

      - name: Configure WireGuard
        run: |
          echo ""[Interface]
          PrivateKey = <runner-private-key>
          Address = <runner-ip-address>/24

          [Peer]
          PublicKey = <private-network-public-key>
          Endpoint = <private-network-endpoint>
          AllowedIPs = <private-network-allowed-ips>"" | sudo tee /etc/wireguard/wg0.conf

      - name: Start WireGuard
        run: sudo wg-quick up wg0
",0
182,https://docs.github.com/en/actions/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: Redis container example
on: push

jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to Redis
        # Runs a script that creates a Redis client, populates
        # the client with data, and retrieves data
        run: node client.js
        # Environment variable used by the `client.js` script to create a new Redis client.
        env:
          # The hostname used to communicate with the Redis service container
          REDIS_HOST: redis
          # The default Redis port
          REDIS_PORT: 6379","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      redis:
        image: redis:latest
        options: --name redis-service
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Test Redis connection
        run: |
          apt-get update
          apt-get install -y redis-tools
          redis-cli -h redis-service ping
",0
183,https://docs.github.com/en/actions/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs in containers - Configuring the container job,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. This workflow configures a job that runs in the node:20-bookworm-slim container and uses the ubuntu-latest GitHub-hosted runner as the Docker host for the container. For more information about the node:20-bookworm-slim container, see the node image on Docker Hub. The workflow configures a service container with the label redis . All services must run in a container, so each service requires that you specify the container image . This example uses the redis container image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g. redis:6 . For more information, see the redis image on Docker Hub.","jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: node:20-bookworm-slim
    services:
      redis:
        image: redis:6
        options: --health-cmd ""redis-cli ping"" --health-interval 10s --health-timeout 5s --health-retries 3
",0
184,https://docs.github.com/en/actions/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs in containers - Configuring the steps for the container job,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to Redis
    # Runs a script that creates a Redis client, populates
    # the client with data, and retrieves data
    run: node client.js
    # Environment variable used by the `client.js` script to create a new Redis client.
    env:
      # The hostname used to communicate with the Redis service container
      REDIS_HOST: redis
      # The default Redis port
      REDIS_PORT: 6379","jobs:
  container-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      redis:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run Redis CLI
        run: |
          apt-get update
          apt-get install -y redis-tools
          redis-cli -h redis ping
",0
185,https://docs.github.com/en/actions/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: Redis runner example
on: push

jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps port 6379 on service container to the host
          - 6379:6379

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to Redis
        # Runs a script that creates a Redis client, populates
        # the client with data, and retrieves data
        run: node client.js
        # Environment variable used by the `client.js` script to create
        # a new Redis client.
        env:
          # The hostname used to communicate with the Redis service container
          REDIS_HOST: localhost
          # The default Redis port
          REDIS_PORT: 6379","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run Redis command
        run: |
          redis-cli -h localhost -p 6379 ping
",0
186,https://docs.github.com/en/actions/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs directly on the runner machine - Configuring the runner job,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The example uses the ubuntu-latest GitHub-hosted runner as the Docker host. The workflow configures a service container with the label redis . All services must run in a container, so each service requires that you specify the container image . This example uses the redis container image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g. redis:6 . For more information, see the redis image on Docker Hub. The workflow maps port 6379 on the Redis service container to the Docker host. For more information about the ports keyword, see About service containers .","jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps port 6379 on service container to the host
          - 6379:6379","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:6
        ports:
          - 6379:6379
        options: >-
          --health-cmd ""redis-cli ping || exit 1""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 3
    steps:
      - name: Check Redis service
        run: |
          echo ""Pinging Redis service...""
          redis-cli -h localhost -p 6379 ping
",0
187,https://docs.github.com/en/actions/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs directly on the runner machine - Configuring the steps for the runner job,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to Redis
    # Runs a script that creates a Redis client, populates
    # the client with data, and retrieves data
    run: node client.js
    # Environment variable used by the `client.js` script to create
    # a new Redis client.
    env:
      # The hostname used to communicate with the Redis service container
      REDIS_HOST: localhost
      # The default Redis port
      REDIS_PORT: 6379","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running job on the runner machine""
",0
188,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write

jobs:
  request-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Authenticate with Vault
        uses: hashicorp/vault-action@v2.4.0
        with:
          method: oidc
          role: my-role
          url: https://my-vault-instance.com
",0
189,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write

jobs:
  request-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Request secret from Vault
        uses: hashicorp/vault-action@v2.4.0
        with:
          url: https://vault.example.com
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: secret/data/myapp/config
",0
190,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. The hashicorp/vault-action action receives a JWT from the GitHub OIDC provider, and then requests an access token from your HashiCorp Vault instance to retrieve secrets. For more information, see the HashiCorp Vault GitHub Action documentation . This example demonstrates how to create a job that requests a secret from HashiCorp Vault.","jobs:
  retrieve-secret:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Retrieve secret from Vault
        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b
        with:
          method: jwt
          url: VAULT-URL
          namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only
          role: ROLE-NAME
          secrets: SECRET-PATH

      - name: Use secret from Vault
        run: |
          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.","jobs:
  request-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Configure OIDC
        uses: hashicorp/vault-action@v2
        with:
          method: jwt
          role: my-role
          jwt: ${{ secrets.GITHUB_TOKEN }}
          url: https://my-vault-instance.com
      - name: Retrieve secret
        id: vault
        uses: hashicorp/vault-action@v2
        with:
          url: https://my-vault-instance.com
          method: jwt
          role: my-role
          jwt: ${{ steps.configure-oidc.outputs.jwt }}
          secrets: path/to/secret
",0
191,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Revoking the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. By default, the Vault server will automatically revoke access tokens when their TTL is expired, so you don't have to manually revoke the access tokens. However, if you do want to revoke access tokens immediately after your job has completed or failed, you can manually revoke the issued token using the Vault API .","jobs:
  retrieve-secret:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Retrieve secret from Vault
        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b
        with:
          exportToken: true
          method: jwt
          url: VAULT-URL
          role: ROLE-NAME
          secrets: SECRET-PATH

      - name: Use secret from Vault
        run: |
          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.

      - name: Revoke token
        # This step always runs at the end regardless of the previous steps result
        if: always()
        run: |
          curl -X POST -sv -H ""X-Vault-Token: ${{ env.VAULT_TOKEN }}"" \
            VAULT-URL/v1/auth/token/revoke-self","jobs:
  oidc-vault:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Authenticate with Vault using OIDC
        id: oidc-auth
        uses: hashicorp/vault-action@v2.4.0
        with:
          method: oidc
          role: my-role
          oidc_discovery_url: https://token.actions.githubusercontent.com
          oidc_discovery_token: ${{ secrets.GITHUB_TOKEN }}
          vault_address: https://vault.example.com

      - name: Request secret from Vault
        id: get-secret
        uses: hashicorp/vault-action@v2.4.0
        with:
          url: ${{ steps.oidc-auth.outputs.vault_address }}
          method: token
          token: ${{ steps.oidc-auth.outputs.token }}
          path: secret/data/my-secret
          field: my-secret-key

      - name: Revoke Vault token
        run: |
          curl --request POST \
            --header ""X-Vault-Token: ${{ steps.oidc-auth.outputs.token }}"" \
            ${{ steps.oidc-auth.outputs.vault_address }}/v1/auth/token/revoke-self
",0
192,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - About contexts - Determining when to use contexts,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects. Contexts, objects, and properties will vary significantly under different workflow run conditions. For example, the matrix context is only populated for jobs in a matrix . You can access contexts using the expression syntax. For more information, see Evaluate expressions in workflows and actions . ${{ <context> }} Warning  When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions . As part of an expression, you can access context information using one of two syntaxes. In order to use property dereference syntax, the property name must start with a letter or _ and contain only alphanumeric characters, - , or _ . If you attempt to dereference a nonexistent property, it will evaluate to an empty string. GitHub Actions includes a collection of variables called contexts and a similar collection of variables called default variables . These variables are intended for use at different points in the workflow: The following example demonstrates how these different types of variables can be used together in a job:","name: CI
on: push
jobs:
  prod-check:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Deploying to production server on branch $GITHUB_REF""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Print context information
        run: echo ""Job ID: ${{ github.run_id }}""
      - name: Print matrix value
        if: ${{ matrix != null }}
        run: echo ""Matrix value: ${{ matrix.some_value }}""
",0
193,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - About contexts - Example: printing context information to the log,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects. Contexts, objects, and properties will vary significantly under different workflow run conditions. For example, the matrix context is only populated for jobs in a matrix . You can access contexts using the expression syntax. For more information, see Evaluate expressions in workflows and actions . ${{ <context> }} Warning  When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions . As part of an expression, you can access context information using one of two syntaxes. In order to use property dereference syntax, the property name must start with a letter or _ and contain only alphanumeric characters, - , or _ . If you attempt to dereference a nonexistent property, it will evaluate to an empty string. You can print the contents of contexts to the log for debugging. The toJSON function is required to pretty-print JSON objects to the log. Warning  When using the wholegithubcontext, be mindful that it includes sensitive information such asgithub.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context. When using the whole github context, be mindful that it includes sensitive information such as github.token . GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.","name: Context testing
on: push

jobs:
  dump_contexts_to_log:
    runs-on: ubuntu-latest
    steps:
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo ""$GITHUB_CONTEXT""
      - name: Dump job context
        env:
          JOB_CONTEXT: ${{ toJson(job) }}
        run: echo ""$JOB_CONTEXT""
      - name: Dump steps context
        env:
          STEPS_CONTEXT: ${{ toJson(steps) }}
        run: echo ""$STEPS_CONTEXT""
      - name: Dump runner context
        env:
          RUNNER_CONTEXT: ${{ toJson(runner) }}
        run: echo ""$RUNNER_CONTEXT""
      - name: Dump strategy context
        env:
          STRATEGY_CONTEXT: ${{ toJson(strategy) }}
        run: echo ""$STRATEGY_CONTEXT""
      - name: Dump matrix context
        env:
          MATRIX_CONTEXT: ${{ toJson(matrix) }}
        run: echo ""$MATRIX_CONTEXT""","jobs:
  print-context:
    runs-on: ubuntu-latest
    steps:
      - name: Print GitHub context
        run: echo ""${{ toJSON(github) }}""
      - name: Print job context
        run: echo ""${{ toJSON(job) }}""
      - name: Print runner context
        run: echo ""${{ toJSON(runner) }}""
      - name: Print steps context
        run: echo ""${{ toJSON(steps) }}""
      - name: Print strategy context
        run: echo ""${{ toJSON(strategy) }}""
      - name: Print matrix context
        run: echo ""${{ toJSON(matrix) }}""
",0
194,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - github context - Example usage of the github context,"The github context contains information about the workflow run and the event that triggered the run. You can also read most of the github context data in environment variables. For more information about environment variables, see Store information in variables . Warning  When using the wholegithubcontext, be mindful that it includes sensitive information such asgithub.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When using the whole github context, be mindful that it includes sensitive information such as github.token . GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions . This example workflow uses the github.event_name context to run a job only if the workflow run was triggered by the pull_request event.","name: Run CI
on: [push, pull_request]

jobs:
  normal_ci:
    runs-on: ubuntu-latest
    steps:
      - name: Run normal CI
        run: echo ""Running normal CI""

  pull_request_ci:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - name: Run PR CI
        run: echo ""Running PR only CI""","jobs:
  example_job:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
195,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - env context - Example usage of the env context,"The env context contains variables that have been set in a workflow, job, or step. It does not contain variables inherited by the runner process. For more information about setting variables in your workflow, see Workflow syntax for GitHub Actions . You can retrieve the values of variables stored in env context and use these values in your workflow file. You can use the env context in any key in a workflow step except for the id and uses keys. For more information on the step syntax, see Workflow syntax for GitHub Actions . If you want to use the value of a variable inside a runner, use the runner operating system's normal method for reading environment variables. This example workflow shows variables being set in the env context at the workflow, job, and step levels. The ${{ env.VARIABLE-NAME }} syntax is then used to retrieve variable values within individual steps in the workflow. When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.","name: Hi Mascot
on: push
env:
  mascot: Mona
  super_duper_var: totally_awesome

jobs:
  windows_job:
    runs-on: windows-latest
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Mona
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Octocat
        env:
          mascot: Octocat
  linux_job:
    runs-on: ubuntu-latest
    env:
      mascot: Tux
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Tux","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      WORKFLOW_VAR: workflow_value
    steps:
      - name: Set job-level environment variable
        run: echo ""JOB_VAR=job_value"" >> $GITHUB_ENV
      - name: Step 1
        env:
          STEP_VAR: step_value
        run: echo ""Workflow variable: ${{ env.WORKFLOW_VAR }}, Job variable: ${{ env.JOB_VAR }}, Step variable: ${{ env.STEP_VAR }}""
      - name: Step 2
        run: echo ""Workflow variable: ${{ env.WORKFLOW_VAR }}, Job variable: ${{ env.JOB_VAR }}""
",0
196,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - vars context - Example usage of the vars context,"Note  Configuration variables for GitHub Actions are in public preview and subject to change. Note Configuration variables for GitHub Actions are in public preview and subject to change. The vars context contains custom configuration variables set at the organization, repository, and environment levels. For more information about defining configuration variables for use in multiple workflows, see Store information in variables . This example workflow shows how configuration variables set at the repository, environment, or organization levels are automatically available using the vars context. Note  Configuration variables at the environment level are automatically available after their environment is declared by the runner. Configuration variables at the environment level are automatically available after their environment is declared by the runner. If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string. The following example shows using configuration variables with the vars context across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels.","on:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo ""repository variable : $REPOSITORY_VAR""
        echo ""organization variable : $ORGANIZATION_VAR""
        echo ""overridden variable : $OVERRIDE_VAR""
        echo ""variable from shell environment : $env_var""
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Print configuration variables
        run: |
          echo ""Repository variable: ${{ vars.repository_variable }}""
          echo ""Organization variable: ${{ vars.organization_variable }}""
          echo ""Environment variable: ${{ vars.environment_variable }}""
",0
197,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - job context - Example usage of the job context,"The job context contains information about the currently running job. This example workflow configures a PostgreSQL service container, and automatically maps port 5432 in the service container to a randomly chosen available port on the host. The job context is used to access the number of the port that was assigned on the host.","name: PostgreSQL Service Example
on: push
jobs:
  postgres-job:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
        ports:
          # Maps TCP port 5432 in the service container to a randomly chosen available port on the host.
          - 5432

    steps:
      - run: pg_isready -h localhost -p ${{ job.services.postgres.ports[5432] }}
      - run: echo ""Run tests against Postgres""","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432/tcp
    steps:
      - name: Check assigned port
        run: echo ""PostgreSQL is running on port ${{ job.services.postgres.ports['5432'] }}""
",0
198,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - jobs context - Example usage of the jobs context,"The jobs context is only available in reusable workflows, and can only be used to set outputs for a reusable workflow. For more information, see Reusing workflows . This example reusable workflow uses the jobs context to set outputs for the reusable workflow. Note how the outputs flow up from the steps, to the job, then to the workflow_call trigger. For more information, see Reusing workflows .","name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: ""The first output string""
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: ""The second output string""
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo ""firstword=hello"" >> $GITHUB_OUTPUT
      - id: step2
        run: echo ""secondword=world"" >> $GITHUB_OUTPUT","jobs:
  example_job:
    runs-on: ubuntu-latest
    outputs:
      example_output: ${{ steps.example_step.outputs.step_output }}
    steps:
      - id: example_step
        run: echo ""step_output=Hello World"" >> $GITHUB_ENV

on:
  workflow_call:
    outputs:
      example_output:
        description: 'An example output from the reusable workflow'
        value: ${{ jobs.example_job.outputs.example_output }}
",0
199,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - steps context - Example usage of the steps context,"The steps context contains information about the steps in the current job that have an id specified and have already run. This example workflow generates a random number as an output in one step, and a later step uses the steps context to read the value of that output.","name: Generate random failure
on: push
jobs:
  randomly-failing-job:
    runs-on: ubuntu-latest
    steps:
      - name: Generate 0 or 1
        id: generate_number
        run: echo ""random_number=$(($RANDOM % 2))"" >> $GITHUB_OUTPUT
      - name: Pass or fail
        run: |
          if [[ ${{ steps.generate_number.outputs.random_number }} == 0 ]]; then exit 0; else exit 1; fi","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - id: generate_random
        run: echo ""::set-output name=random_number::$(shuf -i 1-100 -n 1)""
      - run: echo ""The random number is ${{ steps.generate_random.outputs.random_number }}""
",0
200,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - runner context - Example usage of the runner context,"The runner context contains information about the runner that is executing the current job. This example workflow uses the runner context to set the path to the temporary directory to write logs, and if the workflow fails, it uploads those logs as artifact.","name: Build
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build with logs
        run: |
          mkdir ${{ runner.temp }}/build_logs
          echo ""Logs from building"" > ${{ runner.temp }}/build_logs/build.logs
          exit 1
      - name: Upload logs on fail
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: Build failure logs
          path: ${{ runner.temp }}/build_logs","jobs:
  log-job:
    runs-on: ubuntu-latest
    steps:
      - name: Create log directory
        run: mkdir -p ${{ runner.temp }}/logs

      - name: Write log
        run: echo ""Log entry"" > ${{ runner.temp }}/logs/log.txt

      - name: Upload logs if job fails
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: logs
          path: ${{ runner.temp }}/logs
",0
201,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - secrets context - Example usage of the secrets context,"The secrets context contains the names and values of secrets that are available to a workflow run. The secrets context is not available for composite actions due to security reasons. If you want to pass a secret to a composite action, you need to do it explicitly as an input. For more information about secrets, see Using secrets in GitHub Actions . GITHUB_TOKEN is a secret that is automatically created for every workflow run, and is always included in the secrets context. For more information, see Automatic token authentication . Warning  If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally. Warning If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally. This example workflow uses the GitHub CLI , which requires the GITHUB_TOKEN as the value for the GH_TOKEN input parameter:","name: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title ""Issue title"" --body ""Issue body""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install GitHub CLI
        run: sudo apt-get install -y gh
      - name: Use GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh auth status
",0
202,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - strategy context - Example usage of the strategy context,"For workflows with a matrix, the strategy context contains information about the matrix execution strategy for the current job. This example workflow uses the strategy.job-index property to set a unique name for a log file for each job in a matrix.","name: Test strategy
on: push

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [1, 2]
        node: [14, 16]
    steps:
      - run: echo ""Mock test logs"" > test-job-${{ strategy.job-index }}.txt
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: Build log for job ${{ strategy.job-index }}
          path: test-job-${{ strategy.job-index }}.txt","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Create log file
        run: echo ""Log for job index ${{ strategy.job-index }}"" > log-${{ strategy.job-index }}.txt
",0
203,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - matrix context - Example usage of the matrix context,"For workflows with a matrix, the matrix context contains the matrix properties defined in the workflow file that apply to the current job. For example, if you configure a matrix with the os and node keys, the matrix context object includes the os and node properties with the values that are being used for the current job. There are no standard properties in the matrix context, only those which are defined in the workflow file. This example workflow creates a matrix with os and node keys. It uses the matrix.os property to set the runner type for each job, and uses the matrix.node property to set the Node.js version for each job.","name: Test matrix
on: push

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - name: Output node version
        run: node --version","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node: [14, 16, 18]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
204,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - needs context - Example usage of the needs context,"The needs context contains outputs from all jobs that are defined as a direct dependency of the current job. Note that this doesn't include implicitly dependent jobs (for example, dependent jobs of a dependent job). For more information on defining job dependencies, see Workflow syntax for GitHub Actions . This example workflow has three jobs: a build job that does a build, a deploy job that requires the build job, and a debug job that requires both the build and deploy jobs and runs only if there is a failure in the workflow. The deploy job also uses the needs context to access an output from the build job.","name: Build and deploy
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.build_step.outputs.build_id }}
    steps:
      - name: Build
        id: build_step
        run: echo ""build_id=$RANDOM"" >> $GITHUB_OUTPUT
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Deploying build ${{ needs.build.outputs.build_id }}""
  debug:
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: ${{ failure() }}
    steps:
      - run: echo ""Failed to build and deploy""","jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build_output: ${{ steps.build_step.outputs.some_output }}
    steps:
      - name: Build
        id: build_step
        run: echo ""some_output=build_result"" >> $GITHUB_ENV

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy
        run: echo ""Using build output: ${{ needs.build.outputs.build_output }}""

  debug:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: failure()
    steps:
      - name: Debug
        run: echo ""Debugging due to failure""
",0
205,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - inputs context - Example usage of the inputs context in a reusable workflow,"The inputs context contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow. For reusable workflows, the input names and types are defined in the workflow_call event configuration of a reusable workflow, and the input values are passed from jobs.<job_id>.with in an external workflow that calls the reusable workflow. For manually triggered workflows, the inputs are defined in the workflow_dispatch event configuration of a workflow. The properties in the inputs context are defined in the workflow file. They are only available in a reusable workflow or in a workflow triggered by the workflow_dispatch event This example reusable workflow uses the inputs context to get the values of the build_id , deploy_target , and perform_deploy inputs that were passed to the reusable workflow from the caller workflow.","name: Reusable deploy workflow
on:
  workflow_call:
    inputs:
      build_id:
        required: true
        type: number
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo ""Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}""","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Access inputs
        run: echo ""Build ID: ${{ inputs.build_id }}, Deploy Target: ${{ inputs.deploy_target }}, Perform Deploy: ${{ inputs.perform_deploy }}""
",0
206,https://docs.github.com/en/actions/learn-github-actions/contexts,Accessing contextual information about workflow runs - inputs context - Example usage of the inputs context in a manually triggered workflow,"The inputs context contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow. For reusable workflows, the input names and types are defined in the workflow_call event configuration of a reusable workflow, and the input values are passed from jobs.<job_id>.with in an external workflow that calls the reusable workflow. For manually triggered workflows, the inputs are defined in the workflow_dispatch event configuration of a workflow. The properties in the inputs context are defined in the workflow file. They are only available in a reusable workflow or in a workflow triggered by the workflow_dispatch event This example workflow triggered by a workflow_dispatch event uses the inputs context to get the values of the build_id , deploy_target , and perform_deploy inputs that were passed to the workflow.","on:
  workflow_dispatch:
    inputs:
      build_id:
        required: true
        type: string
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo ""Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}""","on:
  workflow_dispatch:
    inputs:
      build_id:
        description: 'The ID of the build'
        required: true
        type: string
      deploy_target:
        description: 'The target environment for deployment'
        required: true
        type: string
      perform_deploy:
        description: 'Whether to perform deployment'
        required: true
        type: boolean

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print inputs
        run: |
          echo ""Build ID: ${{ inputs.build_id }}""
          echo ""Deploy Target: ${{ inputs.deploy_target }}""
          echo ""Perform Deploy: ${{ inputs.perform_deploy }}""
",0
207,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3,Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3 - Step 1: Configuring your builds - Building with artifact attestations,"First, we need to build with both artifact attestations and a reusable workflow. The reusable workflow you use to build your software must also generate artifact attestations to establish build provenance. For more information, see Using artifact attestations to establish provenance for builds . When you use a reusable workflow to generate artifact attestations, both the calling workflow and the reusable workflow need to have the following permissions.","permissions:
  attestations: write
  contents: read
  id-token: write","permissions:
  contents: read
  id-token: write
  packages: read
  actions: read
  checks: read
  deployments: read
  issues: read
  discussions: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read

jobs:
  build:
    uses: ./.github/workflows/reusable-build-workflow.yml
    with:
      generate-attestations: true
",0
208,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions?learn=create_actions&learnProduct=actions,About custom actions - Using release management for actions - Using tags for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions: This example demonstrates how a user can reference a major release tag:","steps:
    - uses: actions/javascript-action@v1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: example/action@v1
",0
209,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions?learn=create_actions&learnProduct=actions,About custom actions - Using release management for actions - Using tags for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions: This example demonstrates how a user can reference a major release tag: This example demonstrates how a user can reference a specific patch release tag:","steps:
    - uses: actions/javascript-action@v1.0.1","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: example/action@v1
      - uses: example/action@v1.0.1
",0
210,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions?learn=create_actions&learnProduct=actions,About custom actions - Using release management for actions - Using branches for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. If you prefer to use branch names for release management, this example demonstrates how to reference a named branch:","steps:
    - uses: actions/javascript-action@v1-beta","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
      - uses: owner/repo@branch-name
",0
211,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions?learn=create_actions&learnProduct=actions,About custom actions - Using release management for actions - Using a commit's SHA for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. Each Git commit receives a calculated SHA value, which is unique and immutable. Your action's users might prefer to rely on a commit's SHA value, as this approach can be more reliable than specifying a tag, which could be deleted or moved. However, this means that users will not receive further updates made to the action. You must use a commit's full SHA value, and not an abbreviated value.","steps:
    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@<full-commit-SHA>
",0
212,https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners,About GitHub-hosted runners - Using a GitHub-hosted runner,"To use a GitHub-hosted runner, create a job and use runs-on to specify the type of runner that will process the job, such as ubuntu-latest , windows-latest , or macos-latest . For the full list of runner types, see About GitHub-hosted runners . If you have repo: write access to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, see Viewing available runners for a repository . When the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned. The following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners. The following example workflow has two jobs, named Run-npm-on-Ubuntu and Run-PSScriptAnalyzer-on-Windows . When this workflow is triggered, GitHub provisions a new virtual machine for each job.","name: Run commands on different operating systems
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  Run-npm-on-Ubuntu:
    name: Run npm on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm help

  Run-PSScriptAnalyzer-on-Windows:
    name: Run PSScriptAnalyzer on Windows
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install PSScriptAnalyzer module
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module PSScriptAnalyzer -ErrorAction Stop
      - name: Get list of rules
        shell: pwsh
        run: |
          Get-ScriptAnalyzerRule","jobs:
  Run-npm-on-Ubuntu:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm test

  Run-PSScriptAnalyzer-on-Windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install PSScriptAnalyzer
        run: Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
      - name: Run PSScriptAnalyzer
        run: Invoke-ScriptAnalyzer -Path ./scripts
",0
213,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/adding-scripts-to-your-workflow,Adding scripts to your workflow,"You can use GitHub Actions workflows to run scripts. You can use a GitHub Actions workflow to run scripts and shell commands, which are then executed on the assigned runner. This example demonstrates how to use therunkeyword to execute the commandnpm install -g batson the runner. To use a workflow to run a script stored in your repository you must first check out the repository to the runner. Having done this, you can use therunkeyword to run the script on the runner. The following example runs two scripts, each in a separate job step. The location of the scripts on the runner is specified by setting a default working directory for run commands. For more information, seeSetting a default shell and working directory. Any scripts that you want a workflow job to run must be executable. You can do this either within the workflow by passing the script as an argument to the interpreter that will run the script - for example,run: bash script.sh- or by making the file itself executable. You can give the file the execute permission by using the commandgit update-index --chmod=+x PATH/TO/YOUR/script.shlocally, then committing and pushing the file to the repository. Alternatively, for workflows that are run on Linux and Mac runners, you can add a command to give the file the execute permission in the workflow job, prior to running the script: For more information about therunkeyword, seeWorkflow syntax for GitHub Actions. You can use a GitHub Actions workflow to run scripts and shell commands, which are then executed on the assigned runner. This example demonstrates how to use the run keyword to execute the command npm install -g bats on the runner.","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - run: npm install -g bats","jobs:
  run-scripts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: npm install -g bats
      - run: chmod +x PATH/TO/YOUR/script1.sh
      - run: ./PATH/TO/YOUR/script1.sh
      - run: chmod +x PATH/TO/YOUR/script2.sh
      - run: ./PATH/TO/YOUR/script2.sh
",0
214,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/adding-scripts-to-your-workflow,Adding scripts to your workflow,"To use a workflow to run a script stored in your repository you must first check out the repository to the runner. Having done this, you can use the run keyword to run the script on the runner. The following example runs two scripts, each in a separate job step. The location of the scripts on the runner is specified by setting a default working directory for run commands. For more information, see Setting a default shell and working directory .","jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./scripts
    steps:
      - name: Check out the repository to the runner
        uses: actions/checkout@v4  
      - name: Run a script
        run: ./my-script.sh
      - name: Run another script
        run: ./my-other-script.sh","jobs:
  run-scripts:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./scripts
    steps:
      - uses: actions/checkout@v2
      - run: ./script1.sh
      - run: ./script2.sh
",0
215,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/adding-scripts-to-your-workflow,Adding scripts to your workflow,"Any scripts that you want a workflow job to run must be executable. You can do this either within the workflow by passing the script as an argument to the interpreter that will run the script - for example, run: bash script.sh - or by making the file itself executable. You can give the file the execute permission by using the command git update-index --chmod=+x PATH/TO/YOUR/script.sh locally, then committing and pushing the file to the repository. Alternatively, for workflows that are run on Linux and Mac runners, you can add a command to give the file the execute permission in the workflow job, prior to running the script:","jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./scripts
    steps:
      - name: Check out the repository to the runner
        uses: actions/checkout@v4  
      - name: Make the script files executable
        run: chmod +x my-script.sh my-other-script.sh
      - name: Run the scripts
        run: |
          ./my-script.sh
          ./my-other-script.sh","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Make script executable
        run: chmod +x PATH/TO/YOUR/script.sh
      - name: Run script
        run: ./PATH/TO/YOUR/script.sh
",0
216,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-google-kubernetes-engine,Deploying to Google Kubernetes Engine - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build a container image and push it to GCR. It then uses the Kubernetes tools (such as kubectl and kustomize ) to pull the image into the cluster deployment. Under the env key, change the value of GKE_CLUSTER to the name of your cluster, GKE_ZONE to your cluster zone, DEPLOYMENT_NAME to the name of your deployment, and IMAGE to the name of your image. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and Deploy to GKE

on:
  push:
    branches:
      - main

env:
  PROJECT_ID: ${{ secrets.GKE_PROJECT }}
  GKE_CLUSTER: cluster-1    # Add your cluster name here.
  GKE_ZONE: us-central1-c   # Add your cluster zone here.
  DEPLOYMENT_NAME: gke-test # Add your deployment name here.
  IMAGE: static-site

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    # Setup gcloud CLI
    - uses: google-github-actions/setup-gcloud@1bee7de035d65ec5da40a31f8589e240eba8fde5
      with:
        service_account_key: ${{ secrets.GKE_SA_KEY }}
        project_id: ${{ secrets.GKE_PROJECT }}

    # Configure Docker to use the gcloud command-line tool as a credential
    # helper for authentication
    - run: |-
        gcloud --quiet auth configure-docker

    # Get the GKE credentials so we can deploy to the cluster
    - uses: google-github-actions/get-gke-credentials@db150f2cc60d1716e61922b832eae71d2a45938f
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        credentials: ${{ secrets.GKE_SA_KEY }}

    # Build the Docker image
    - name: Build
      run: |-
        docker build \
          --tag ""gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA"" \
          --build-arg GITHUB_SHA=""$GITHUB_SHA"" \
          --build-arg GITHUB_REF=""$GITHUB_REF"" \
          .

    # Push the Docker image to Google Container Registry
    - name: Publish
      run: |-
        docker push ""gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA""

    # Set up kustomize
    - name: Set up Kustomize
      run: |-
        curl -sfLo kustomize https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    # Deploy the Docker image to the GKE cluster
    - name: Deploy
      run: |-
        ./kustomize edit set image gcr.io/PROJECT_ID/IMAGE:TAG=gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA
        ./kustomize build . | kubectl apply -f -
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl get services -o wide","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
      with:
        version: 'latest'
        service_account_key: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: Configure Docker
      run: gcloud auth configure-docker

    - name: Build and push Docker image
      run: |
        docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.IMAGE }}:$GITHUB_SHA .
        docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.IMAGE }}:$GITHUB_SHA

    - name: Set up Kustomize
      run: |
        curl -s ""https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh""  | bash
        sudo mv kustomize /usr/local/bin

    - name: Deploy to GKE
      env:
        GKE_CLUSTER: your-cluster-name
        GKE_ZONE: your-cluster-zone
        DEPLOYMENT_NAME: your-deployment-name
        IMAGE: your-image-name
      run: |
        gcloud container clusters get-credentials $GKE_CLUSTER --zone $GKE_ZONE
        kubectl set image deployment/$DEPLOYMENT_NAME $DEPLOYMENT_NAME=gcr.io/${{ secrets.GCP_PROJECT_ID }}/${{ env.IMAGE }}:$GITHUB_SHA
",0
217,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions .","steps:
  - name: Hello world action
    with: # Set the secret as an input
      super_secret: ${{ secrets.SuperSecret }}
    env: # Or as an environment variable
      super_secret: ${{ secrets.SuperSecret }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Use secret as environment variable
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}
        run: echo ""Using secret in the workflow""

      - name: Authenticate with cloud provider using OIDC
        uses: actions/oidc-auth@v1
        with:
          provider: my-cloud-provider
          role: my-cloud-role
",0
218,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Bash,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: bash
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$SUPER_SECRET""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret in Bash
        env:
          SUPER_SECRET: ${{ secrets.SuperSecret }}
        run: echo ""The secret is $SUPER_SECRET""
",0
219,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow - Example using PowerShell,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: pwsh
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$env:SUPER_SECRET""","jobs:
  example:
    runs-on: ubuntu-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run PowerShell script
        shell: pwsh
        run: |
          Write-Host ""The secret is $env:SUPER_SECRET""
",0
220,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Cmd.exe,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: cmd
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""%SUPER_SECRET%""","jobs:
  example:
    runs-on: windows-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run command
        run: |
          echo %SUPER_SECRET%
        shell: cmd
",0
221,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Limits for secrets - Storing large secrets,"You can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets. A workflow created in a repository can access the following number of secrets: Secrets are limited to 48 KB in size. To store larger secrets, see the Storing large secrets workaround below. To use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can use gpg to encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see the gpg manpage . Warning  Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Warning Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Run the following command from your terminal to encrypt the file containing your secret using gpg and the AES256 cipher algorithm. In this example, my_secret.json is the file containing the secret. You will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value. Create a new secret that contains the passphrase. For example, create a new secret with the name LARGE_SECRET_PASSPHRASE and set the value of the secret to the passphrase you used in the step above. Copy your encrypted file to a path in your repository and commit it. In this example, the encrypted file is my_secret.json.gpg . Warning  Make sure to copy the encryptedmy_secret.json.gpgfile ending with the.gpgfile extension, andnotthe unencryptedmy_secret.jsonfile. Make sure to copy the encrypted my_secret.json.gpg file ending with the .gpg file extension, and not the unencrypted my_secret.json file. Create a shell script in your repository to decrypt the secret file. In this example, the script is named decrypt_secret.sh . Ensure your shell script is executable before checking it in to your repository. In your GitHub Actions workflow, use a step to call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use the actions/checkout action. Reference your shell script using the run command relative to the root of your repository.","name: Workflows with large secrets

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Decrypt large secret
        run: ./decrypt_secret.sh
        env:
          LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      # This command is just an example to show your secret being printed
      # Ensure you remove any print statements of your secrets. GitHub does
      # not hide secrets that use this workaround.
      - name: Test printing your secret (Remove this step in production)
        run: cat $HOME/secrets/my_secret.json","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Decrypt secret
      env:
        PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      run: |
        gpg --quiet --batch --yes --decrypt --passphrase=""$PASSPHRASE"" --output my_secret.json my_secret.json.gpg
        ./decrypt_secret.sh
",0
222,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Storing Base64 binary blobs as secrets,"You can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, see Using secrets in GitHub Actions . Note  Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Note Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Use base64 to encode your file into a Base64 string. For example: On macOS, you could run: On Linux, you could run: Create a secret that contains the Base64 string. For example: To access the Base64 string from your runner, pipe the secret to base64 --decode . For example:","name: Retrieve Base64 secret
on:
  push:
    branches: [ octo-branch ]
jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Retrieve the secret and decode it to a file
        env:
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
        run: |
          echo $CERTIFICATE_BASE64 | base64 --decode > cert.der
      - name: Show certificate information
        run: |
          openssl x509 -in cert.der -inform DER -text -noout","jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Decode Base64 secret
        run: echo ""${{ secrets.BASE64_SECRET }}"" | base64 --decode > decoded_file
",0
223,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Using a matrix strategy,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] :","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
224,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a single-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify a single variable to create a single-dimension matrix. For example, the following workflow defines the variable version with the values [10, 12, 14] . The workflow will run three jobs, one for each value in the variable. Each job will access the version value through the matrix.version context and pass the value as node-version to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
225,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
226,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s.","matrix:
  os:
    - ubuntu-latest
    - macos-latest
  node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
227,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s. This matrix produces 4 jobs with corresponding contexts.","- matrix.os: ubuntu-latest
  matrix.node.version: 14
- matrix.os: ubuntu-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
  matrix.node.version: 14
- matrix.os: macos-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
",0
228,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using contexts to create matrices,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs . For example, the following workflow triggers on the repository_dispatch event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix version variable will have a value of [12, 14, 16] . For more information about the repository_dispatch trigger, see Events that trigger workflows .","on:
  repository_dispatch:
    types:
      - test
 
jobs:
  example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        version: [12, 14, 16]
        os: [ubuntu-latest, windows-latest]
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
229,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Expanding or adding matrix configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix:","strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [12, 14]
        include:
          - os: ubuntu-latest
            node: 16
            custom: true
          - os: windows-latest
            node: 16
            custom: true
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
230,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Expanding or adding matrix configurations - Example: Expanding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, the following workflow will run four jobs, one for each combination of os and node . When the job for the os value of windows-latest and node value of 16 runs, an additional variable called npm with the value of 6 will be included in the job.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
231,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Expanding or adding matrix configurations - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 .","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [14, 16]
        include:
          - os: windows-latest
            version: 17
    steps:
      - run: echo ""Running on OS ${{ matrix.os }} with version ${{ matrix.version }}""
",0
232,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Expanding or adding matrix configurations - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 . If you don't specify any matrix variables, all configurations under include will run. For example, the following workflow would run two jobs, one for each include entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.","jobs:
  includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: ""production""
            datacenter: ""site-a""
          - site: ""staging""
            datacenter: ""site-b""","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        version: [16, 18]
        include:
          - os: windows-latest
            version: 17
          - os: ubuntu-latest
            version: 20
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
233,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Excluding matrix configurations,"To remove specific configurations defined in the matrix, use jobs.<job_id>.strategy.matrix.exclude . An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches {os: macos-latest, version: 12, environment: production} , and the two excluded jobs that match {os: windows-latest, version: 16} .","strategy:
  matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [12, 14, 16]
        environment: [development, production]
        exclude:
          - os: macos-latest
            version: 12
            environment: production
          - os: windows-latest
            version: 16
    steps:
      - run: echo ""Running on ${{ matrix.os }} with version ${{ matrix.version }} in ${{ matrix.environment }} environment""
",0
234,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Example: Using an output to define two matrices,"You can use the output from one job to define matrices for multiple jobs. For example, the following workflow demonstrates how to define a matrix of values in one job, use that matrix in a second jobs to produce artifacts, and then consume those artifacts in a third job. Each artifact is associated with a value from the matrix.","name: shared matrix
on:
  push:
  workflow_dispatch:

jobs:
  define-matrix:
    runs-on: ubuntu-latest

    outputs:
      colors: ${{ steps.colors.outputs.colors }}

    steps:
      - name: Define Colors
        id: colors
        run: |
          echo 'colors=[""red"", ""green"", ""blue""]' >> ""$GITHUB_OUTPUT""

  produce-artifacts:
    runs-on: ubuntu-latest
    needs: define-matrix
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
      - name: Define Color
        env:
          color: ${{ matrix.color }}
        run: |
          echo ""$color"" > color
      - name: Produce Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.color }}
          path: color

  consume-artifacts:
    runs-on: ubuntu-latest
    needs:
    - define-matrix
    - produce-artifacts
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
    - name: Retrieve Artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.color }}

    - name: Report Color
      run: |
        cat color","jobs:
  define-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo ""::set-output name=matrix::{\""include\"":[{\""value\"":\""a\""},{\""value\"":\""b\""}]}""

  produce-artifacts:
    runs-on: ubuntu-latest
    needs: define-matrix
    strategy:
      matrix: ${{ fromJson(needs.define-matrix.outputs.matrix) }}
    steps:
      - run: echo ""Producing artifact for value: ${{ matrix.value }}""
      - run: echo ""artifact-${{ matrix.value }}"" > artifact.txt
      - uses: actions/upload-artifact@v3
        with:
          name: artifact-${{ matrix.value }}
          path: artifact.txt

  consume-artifacts:
    runs-on: ubuntu-latest
    needs: produce-artifacts
    steps:
      - uses: actions/download-artifact@v3
        with:
          name: artifact-a
      - uses: actions/download-artifact@v3
        with:
          name: artifact-b
      - run: cat artifact-a/artifact.txt
      - run: cat artifact-b/artifact.txt
",0
235,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Handling failures,"You can control how job failures are handled with jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error . jobs.<job_id>.strategy.fail-fast applies to the entire matrix. If jobs.<job_id>.strategy.fail-fast is set to true or its expression evaluates to true , GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to true . jobs.<job_id>.continue-on-error applies to a single job. If jobs.<job_id>.continue-on-error is true , other jobs in the matrix will continue running even if the job with jobs.<job_id>.continue-on-error: true fails. You can use jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error together. For example, the following workflow will start four jobs. For each job, continue-on-error is determined by the value of matrix.experimental . If any of the jobs with continue-on-error: false fail, all jobs that are in progress or queued will be cancelled. If the job with continue-on-error: true fails, the other jobs will not be affected.","jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true","jobs:
  build:
    strategy:
      matrix:
        experimental: [true, false]
      fail-fast: true
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    steps:
      - run: echo ""Running job with experimental=${{ matrix.experimental }}""
",0
236,https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs,Running variations of jobs in a workflow - Defining the maximum number of concurrent jobs,"By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a matrix job strategy, use jobs.<job_id>.strategy.max-parallel . For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.","jobs:
  example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  example-job:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 2
      matrix:
        version: [1, 2, 3]
        os: [ubuntu-latest, windows-latest]
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on version ${{ matrix.version }} and OS ${{ matrix.os }}""
",0
237,https://docs.github.com/en/actions/using-jobs/setting-default-values-for-jobs,Setting a default shell and working directory - Setting default shell and working directory - Example: Set the default shell and working directory,"You can use defaults.run to provide default shell and working-directory options for all run steps in a workflow. You can also set default settings for run that are only available to a job. For more information, see jobs.<job_id>.defaults.run . You cannot use contexts or expressions in this keyword. When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","defaults:
  run:
    shell: bash
    working-directory: ./scripts","jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./my-directory
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
238,https://docs.github.com/en/actions/using-jobs/setting-default-values-for-jobs,Setting a default shell and working directory - Setting default shell and working directory for a job - Example: Setting default run step options for a job,"Use jobs.<job_id>.defaults.run to provide default shell and working-directory to all run steps in the job. You can provide default shell and working-directory options for all run steps in a job. You can also set default settings for run for the entire workflow. For more information, see defaults.run . These can be overriden at the jobs.<job_id>.defaults.run and jobs.<job_id>.steps[*].run levels. When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","jobs:
  job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts","jobs:
  example_job:
    defaults:
      run:
        shell: bash
        working-directory: ./my-directory
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
239,https://docs.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added,Commenting on an issue when a label is added - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Add comment
on:
  issues:
    types:
      - labeled
jobs:
  add-comment:
    if: github.event.label.name == 'help wanted'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Add comment
        run: gh issue comment ""$NUMBER"" --body ""$BODY""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          NUMBER: ${{ github.event.issue.number }}
          BODY: >
            This issue is available for anyone to work on.
            **Make sure to reference this issue in your pull request.**
            :sparkles: Thank you for your contribution! :sparkles:","on:
  issues:
    types: [labeled]

jobs:
  comment_on_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Comment on issue
        uses: actions/github-script@v6
        with:
          script: |
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'A label was added to this issue.'
            })
",0
240,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure,Configuring OpenID Connect in Azure - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
241,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure,Configuring OpenID Connect in Azure - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
",0
242,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure,Configuring OpenID Connect in Azure - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The azure/login action receives a JWT from the GitHub OIDC provider, and then requests an access token from Azure. For more information, see the azure/login documentation. The following example exchanges an OIDC ID token with Azure to receive an access token, which can then be used to access cloud resources.","name: Run Azure Login with OIDC
on: [push]

permissions:
  id-token: write
  contents: read
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 'Az CLI login'
        uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: 'Run az commands'
        run: |
          az account show
          az group list","jobs:
  oidc:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Login to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          federated-credentials: ${{ secrets.AZURE_FEDERATED_CREDENTIALS }}
",0
243,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container,Running jobs in a container - Overview - Example: Running a job within a container,"Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. Note The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell .","name: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: node:14
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
244,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container,Running jobs in a container - Overview - Example: Running a job within a container,"Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. Note The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell . When you only specify a container image, you can omit the image keyword.","jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container: node:18","jobs:
  example-job:
    runs-on: ubuntu-latest
    container: node:14
    steps:
      - run: echo ""Running inside a container""
",0
245,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container,Running jobs in a container - Defining credentials for a container registry - Example: Defining credentials for a container registry,"If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password . The credentials are the same values that you would provide to the docker login command.","container:
  image: ghcr.io/owner/image
  credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: my-container-image:latest
      credentials:
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
",0
246,https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container,Running jobs in a container - Mounting volumes in a container - Example: Mounting volumes in a container,"Use jobs.<job_id>.container.volumes to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host. To specify a volume, you specify the source and destination path: <source>:<destinationPath> . The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.","volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
      volumes:
        - /host/path:/container/path
    steps:
      - name: Check mounted volume
        run: ls /container/path
",0
247,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
248,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run hello world action
        uses: OWNER/REPO@SHA
        with:
          who-to-greet: ""Your Name""
",0
249,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - name: Run goodbye script
      shell: bash
      run: ./goodbye.sh
",0
250,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Specifying the Ruby version,"The easiest way to specify a Ruby version is by using the ruby/setup-ruby action provided by the Ruby organization on GitHub. The action adds any supported Ruby version to PATH for each job run in a workflow. For more information and available Ruby versions, see ruby/setup-ruby . Using Ruby's ruby/setup-ruby action is the recommended way of using Ruby with GitHub Actions because it ensures consistent behavior across different runners and different versions of Ruby. The setup-ruby action takes a Ruby version as an input and configures that version on the runner.","steps:
- uses: actions/checkout@v4
- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
  with:
    ruby-version: '3.1' # Not needed with a .ruby-version file
- run: bundle install
- run: bundle exec rake","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.0'
      - run: bundle install
      - run: bundle exec rake test
",0
251,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Testing with multiple versions of Ruby,"You can add a matrix strategy to run your workflow with more than one version of Ruby. For example, you can test your code against the latest patch releases of versions 3.1, 3.0, and 2.7.","strategy:
  matrix:
    ruby-version: ['3.1', '3.0', '2.7']","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: [3.1, 3.0, 2.7]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ matrix.ruby-version }}
    - name: Install dependencies
      run: bundle install
    - name: Run tests
      run: bundle exec rake test
",0
252,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Testing with multiple versions of Ruby,"You can add a matrix strategy to run your workflow with more than one version of Ruby. For example, you can test your code against the latest patch releases of versions 3.1, 3.0, and 2.7. Each version of Ruby specified in the ruby-version array creates a job that runs the same steps. The ${{ matrix.ruby-version }} context is used to access the current job's version. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs . The full updated workflow with a matrix strategy could look like this:","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Ruby CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        ruby-version: ['3.1', '3.0', '2.7']

    steps:
      - uses: actions/checkout@v4
      - name: Set up Ruby ${{ matrix.ruby-version }}
        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
        with:
          ruby-version: ${{ matrix.ruby-version }}
      - name: Install dependencies
        run: bundle install
      - name: Run tests
        run: bundle exec rake","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: [3.1, 3.0, 2.7]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ matrix.ruby-version }}
    - name: Install dependencies
      run: bundle install
    - name: Run tests
      run: bundle exec rake test
",0
253,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Installing dependencies with Bundler,"The setup-ruby action will automatically install bundler for you. The version is determined by your gemfile.lock file. If no version is present in your lockfile, then the latest compatible version will be installed.","steps:
- uses: actions/checkout@v4
- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
  with:
    ruby-version: '3.1'
- run: bundle install","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: ruby/setup-ruby@v1
      - run: bundle install
      - run: bundle exec rake test
",0
254,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Installing dependencies with Bundler - Caching dependencies,"The setup-ruby action will automatically install bundler for you. The version is determined by your gemfile.lock file. If no version is present in your lockfile, then the latest compatible version will be installed. The setup-ruby actions provides a method to automatically handle the caching of your gems between runs. To enable caching, set the following.","steps:
- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
  with:
    bundler-cache: true","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - run: bundle install
      - run: bundle exec rake test
",0
255,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Installing dependencies with Bundler - Caching dependencies,"The setup-ruby action will automatically install bundler for you. The version is determined by your gemfile.lock file. If no version is present in your lockfile, then the latest compatible version will be installed. The setup-ruby actions provides a method to automatically handle the caching of your gems between runs. To enable caching, set the following. This will configure bundler to install your gems to vendor/cache . For each successful run of your workflow, this folder will be cached by GitHub Actions and re-downloaded for subsequent workflow runs. A hash of your gemfile.lock and the Ruby version are used as the cache key. If you install any new gems, or change a version, the cache will be invalidated and bundler will do a fresh install. Caching without setup-ruby For greater control over caching, you can use the actions/cache action directly. For more information, see Caching dependencies to speed up workflows .","steps:
- uses: actions/cache@v4
  with:
    path: vendor/bundle
    key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}
    restore-keys: |
      ${{ runner.os }}-gems-
- name: Bundle install
  run: |
    bundle config path vendor/bundle
    bundle install --jobs 4 --retry 3","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: ruby/setup-ruby@v1
      with:
        bundler-cache: true
    - name: Install dependencies
      run: bundle install --path vendor/cache
    - name: Run tests
      run: bundle exec rake test
",0
256,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Installing dependencies with Bundler - Caching dependencies,"The setup-ruby action will automatically install bundler for you. The version is determined by your gemfile.lock file. If no version is present in your lockfile, then the latest compatible version will be installed. The setup-ruby actions provides a method to automatically handle the caching of your gems between runs. To enable caching, set the following. This will configure bundler to install your gems to vendor/cache . For each successful run of your workflow, this folder will be cached by GitHub Actions and re-downloaded for subsequent workflow runs. A hash of your gemfile.lock and the Ruby version are used as the cache key. If you install any new gems, or change a version, the cache will be invalidated and bundler will do a fresh install. Caching without setup-ruby For greater control over caching, you can use the actions/cache action directly. For more information, see Caching dependencies to speed up workflows . If you're using a matrix build, you will want to include the matrix variables in your cache key. For example, if you have a matrix strategy for different ruby versions ( matrix.ruby-version ) and different operating systems ( matrix.os ), your workflow steps might look like this:","steps:
- uses: actions/cache@v4
  with:
    path: vendor/bundle
    key: bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-${{ hashFiles('**/Gemfile.lock') }}
    restore-keys: |
      bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-
- name: Bundle install
  run: |
    bundle config path vendor/bundle
    bundle install --jobs 4 --retry 3","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby-version: [2.7, 3.0]
        os: [ubuntu-latest, macos-latest]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ matrix.ruby-version }}
    - name: Cache gems
      uses: actions/cache@v3
      with:
        path: vendor/cache
        key: ${{ runner.os }}-gems-${{ matrix.ruby-version }}-${{ hashFiles('**/Gemfile.lock') }}
        restore-keys: |
          ${{ runner.os }}-gems-${{ matrix.ruby-version }}-
    - name: Install dependencies
      run: bundle install --path vendor/cache
    - name: Run tests
      run: bundle exec rake test
",0
257,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Matrix testing your code,"The following example matrix tests all stable releases and head versions of MRI, JRuby and TruffleRuby on Ubuntu and macOS.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Matrix Testing

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}-latest
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu, macos]
        ruby: [2.5, 2.6, 2.7, head, debug, jruby, jruby-head, truffleruby, truffleruby-head]
    continue-on-error: ${{ endsWith(matrix.ruby, 'head') || matrix.ruby == 'debug' }}
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
        with:
          ruby-version: ${{ matrix.ruby }}
      - run: bundle install
      - run: bundle exec rake","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        ruby: [2.7, 3.0, 3.1, head, jruby, truffleruby]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ matrix.ruby }}
    - name: Install dependencies
      run: bundle install
    - name: Run tests
      run: bundle exec rake test
",0
258,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Linting your code,"The following example installs rubocop and uses it to lint all files. For more information, see RuboCop . You can configure Rubocop to decide on the specific linting rules.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Linting

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
        with:
          ruby-version: '2.6'
      - run: bundle install
      - name: Rubocop
        run: rubocop -f github","jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
      - name: Install RuboCop
        run: gem install rubocop
      - name: Run RuboCop
        run: rubocop
",0
259,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby,Building and testing Ruby - Publishing Gems,You can configure your workflow to publish your Ruby package to any package registry you'd like when your CI tests pass. You can store any access tokens or credentials needed to publish your package using repository secrets. The following example creates and publishes a package to GitHub Package Registry and RubyGems .,"# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Ruby Gem

on:
  # Manually publish
  workflow_dispatch:
  # Alternatively, publish whenever changes are merged to the `main` branch.
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    name: Build + Publish
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read

    steps:
      - uses: actions/checkout@v4
      - name: Set up Ruby 2.6
        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
        with:
          ruby-version: '2.6'
      - run: bundle install

      - name: Publish to GPR
        run: |
          mkdir -p $HOME/.gem
          touch $HOME/.gem/credentials
          chmod 0600 $HOME/.gem/credentials
          printf -- ""---\n:github: ${GEM_HOST_API_KEY}\n"" > $HOME/.gem/credentials
          gem build *.gemspec
          gem push --KEY github --host https://rubygems.pkg.github.com/${OWNER} *.gem
        env:
          GEM_HOST_API_KEY: ""Bearer ${{secrets.GITHUB_TOKEN}}""
          OWNER: ${{ github.repository_owner }}

      - name: Publish to RubyGems
        run: |
          mkdir -p $HOME/.gem
          touch $HOME/.gem/credentials
          chmod 0600 $HOME/.gem/credentials
          printf -- ""---\n:rubygems_api_key: ${GEM_HOST_API_KEY}\n"" > $HOME/.gem/credentials
          gem build *.gemspec
          gem push *.gem
        env:
          GEM_HOST_API_KEY: ""${{secrets.RUBYGEMS_AUTH_TOKEN}}""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '2.7'
    - name: Install dependencies
      run: bundle install
    - name: Run tests
      run: bundle exec rake test
    - name: Publish to GitHub Packages
      if: success()
      env:
        RUBYGEMS_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gem build my-gem.gemspec
        gem push --key github --host https://rubygems.pkg.github.com/OWNER my-gem-0.1.0.gem
    - name: Publish to RubyGems
      if: success()
      env:
        RUBYGEMS_AUTH_TOKEN: ${{ secrets.RUBYGEMS_AUTH_TOKEN }}
      run: |
        gem build my-gem.gemspec
        gem push my-gem-0.1.0.gem
",0
260,https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller,Enforcing artifact attestations with a Kubernetes admission controller - Getting started with Kubernetes admission controller - Enable the policy in your namespace,"To set up an admission controller for enforcing GitHub artifact attestations, you need to: Warning  This policy will not be enforced until you specify which namespaces it should apply to. Warning This policy will not be enforced until you specify which namespaces it should apply to. Each namespace in your cluster can independently enforce policies. To enable enforcement in a namespace, you can add the following label to the namespace:","metadata:
  labels:
    policy.sigstore.dev/include: ""true""","jobs:
  enforce-artifact-attestations:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Kubernetes admission controller
        run: |
          kubectl label namespace <your-namespace> policy-enforcement=enabled
",0
261,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services,Configuring OpenID Connect in Amazon Web Services - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
262,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services,Configuring OpenID Connect in Amazon Web Services - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
",0
263,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services,Configuring OpenID Connect in Amazon Web Services - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: The aws-actions/configure-aws-credentials action receives a JWT from the GitHub OIDC provider, and then requests an access token from AWS. For more information, see the AWS documentation .","# Sample workflow to access AWS resources when workflow is tied to branch
# The workflow Creates static website using aws s3
name: AWS example workflow
on:
  push
env:
  BUCKET_NAME : ""BUCKET-NAME""
  AWS_REGION : ""AWS-REGION""
# permission can be added at job level or workflow level
permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read    # This is required for actions/checkout
jobs:
  S3PackageUpload:
    runs-on: ubuntu-latest
    steps:
      - name: Git clone the repository
        uses: actions/checkout@v4
      - name: configure aws credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ROLE-TO-ASSUME
          role-session-name: samplerolesession
          aws-region: ${{ env.AWS_REGION }}
      # Upload a file to AWS s3
      - name: Copy index.html to s3
        run: |
          aws s3 cp ./index.html s3://${{ env.BUCKET_NAME }}/","jobs:
  oidc:
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::123456789012:role/example-role
          aws-region: us-east-1
",0
264,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - run-name - Example of run-name,"The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's ""Actions"" tab. If run-name is omitted or is only whitespace, then the run name is set to event-specific information for the workflow run. For example, for a workflow triggered by a push or pull_request event, it is set as the commit message or the title of the pull request. This value can include expressions and can reference the github and inputs contexts.",run-name: Deploy to ${{ inputs.deploy_target }} by @${{ github.actor }},"run-name: Example of run-name
",0
265,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using a single event,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. For example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:",on: push,"on: push
",0
266,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using multiple events,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. You can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:","on: [push, fork]","on:
  push:
  fork:
",0
267,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using activity types,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.","on:
  label:
    types:
      - created","on:
  issue_comment:
    types: [created, edited, deleted]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
268,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using activity types,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted. If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.","on:
  issues:
    types:
      - opened
      - labeled","on:
  issues:
    types: [opened, labeled]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
269,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using filters,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.","on:
  push:
    branches:
      - main
      - 'releases/**'","on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
270,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using activity types and filters with multiple events,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon ( : ) to all events, including events without configuration. For example, a workflow with the following on value will run when:","on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:","on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
  pull_request:
    branches:
      - main
  schedule:
    - cron: '0 0 * * 0'
",0
271,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<event_name>.types,"Use on.<event_name>.types to define the type of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the label is triggered when a label is created , edited , or deleted . The types keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the types keyword is unnecessary. You can use an array of event types . For more information about each event and their activity types, see Events that trigger workflows .","on:
  label:
    types: [created, edited]","on:
  label:
    types: [created, edited, deleted]
",0
272,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<pull_request|pull_request_target>.<branches|branches-ignore> - Example: Including branches,"When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'","on:
  pull_request:
    branches:
      - 'main'
      - 'release/*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
273,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<pull_request|pull_request_target>.<branches|branches-ignore> - Example: Excluding branches,"When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'","on:
  pull_request:
    branches-ignore:
      - 'main'
      - 'release/*'
",0
274,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<pull_request|pull_request_target>.<branches|branches-ignore> - Example: Including and excluding branches,"When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. The order that you define patterns matters. The following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona , but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  pull_request:
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/**-alpha'
",0
275,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.push.<branches|tags|branches-ignore|tags-ignore> - Example: Including branches and tags,"When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*","on:
  push:
    branches:
      - 'main'
      - 'release/*'
    tags:
      - 'v*'
",0
276,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.push.<branches|tags|branches-ignore|tags-ignore> - Example: Excluding branches and tags,"When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*","on:
  push:
    branches-ignore:
      - 'main'
      - 'release/*'
    tags-ignore:
      - 'v1.*'
",0
277,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.push.<branches|tags|branches-ignore|tags-ignore> - Example: Including and excluding branches and tags,"When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead. The order that you define patterns matters. The following workflow will run on pushes to releases/10 or releases/beta/mona , but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  push:
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/**-alpha'
",0
278,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<push|pull_request|pull_request_target>.<paths|paths-ignore> - Example: Including paths,"When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . If at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file ( .js ).","on:
  push:
    paths:
      - '**.js'","on:
  push:
    paths:
      - '*.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
",0
279,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<push|pull_request|pull_request_target>.<paths|paths-ignore> - Example: Excluding paths,"When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . When all the path names match patterns in paths-ignore , the workflow will not run. If any path names do not match patterns in paths-ignore , even if some path names match the patterns, the workflow will run. A workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.","on:
  push:
    paths-ignore:
      - 'docs/**'","on:
  push:
    paths-ignore:
      - 'docs/**'
",0
280,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<push|pull_request|pull_request_target>.<paths|paths-ignore> - Example: Including and excluding paths,"When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . You cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. If you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead. This example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.","on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'","on:
  push:
    paths:
      - sub-project/**
      - '!sub-project/docs/**'
",0
281,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.schedule,You can use on.schedule to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC:,"on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'","on:
  schedule:
    - cron: '30 5,17 * * *'
",0
282,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.schedule,"You can use on.schedule to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC: A single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.","on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo ""This step will be skipped on Monday and Wednesday""
      - name: Every time
        run: echo ""This step will always run""","on:
  schedule:
    - cron: '30 5 * * 1-4'
jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: ${{ !(github.event.schedule == '30 5 * * 1' || github.event.schedule == '30 5 * * 3') }}
        run: echo ""This step runs on Tuesday and Thursday""
      - name: Always runs
        run: echo ""This step runs every scheduled day""
",0
283,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_call.inputs - Example of on.workflow_call.inputs,"When using the workflow_call keyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow. For more information about the workflow_call keyword, see Events that trigger workflows . In addition to the standard input parameters that are available, on.workflow_call.inputs requires a type parameter. For more information, see on.workflow_call.inputs.<input_id>.type . If a default parameter is not set, the default value of the input is false for a boolean, 0 for a number, and """" for a string. Within the called workflow, you can use the inputs context to refer to an input. For more information, see Accessing contextual information about workflow runs . If a caller workflow passes an input that is not specified in the called workflow, this results in an error.","on:
  workflow_call:
    inputs:
      username:
        description: 'A username passed from the caller workflow'
        default: 'john-doe'
        required: false
        type: string

jobs:
  print-username:
    runs-on: ubuntu-latest

    steps:
      - name: Print the input name to STDOUT
        run: echo The username is ${{ inputs.username }}","on:
  workflow_call:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        type: string
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""Input value: ${{ inputs.example_input }}""
",0
284,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_call.outputs - Example of on.workflow_call.outputs,"A map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optional description, and a value. The value must be set to the value of an output from a job within the called workflow. In the example below, two outputs are defined for this reusable workflow: workflow_output1 and workflow_output2 . These are mapped to outputs called job_output1 and job_output2 , both from a job called my_job .","on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      workflow_output1:
        description: ""The first job output""
        value: ${{ jobs.my_job.outputs.job_output1 }}
      workflow_output2:
        description: ""The second job output""
        value: ${{ jobs.my_job.outputs.job_output2 }}","on:
  workflow_call:
    outputs:
      workflow_output1:
        description: 'Description for workflow_output1'
        value: ${{ jobs.my_job.outputs.job_output1 }}
      workflow_output2:
        description: 'Description for workflow_output2'
        value: ${{ jobs.my_job.outputs.job_output2 }}
",0
285,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_call.secrets - Example of on.workflow_call.secrets,"A map of the secrets that can be used in the called workflow. Within the called workflow, you can use the secrets context to refer to a secret. Note  If you are passing the secret to a nested reusable workflow, then you must usejobs.<job_id>.secretsagain to pass the secret. For more information, seeReusing workflows. Note If you are passing the secret to a nested reusable workflow, then you must use jobs.<job_id>.secrets again to pass the secret. For more information, see Reusing workflows . If a caller workflow passes a secret that is not specified in the called workflow, this results in an error.","on:
  workflow_call:
    secrets:
      access-token:
        description: 'A token passed from the caller workflow'
        required: false

jobs:

  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
    # passing the secret to an action
      - name: Pass the received secret to an action
        uses: ./.github/actions/my-action
        with:
          token: ${{ secrets.access-token }}

  # passing the secret to a nested reusable workflow
  pass-secret-to-workflow:
    uses: ./.github/workflows/my-workflow
    secrets:
       token: ${{ secrets.access-token }}","on:
  workflow_call:
    secrets:
      MY_SECRET:
jobs:
  my_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret
        run: echo ${{ secrets.MY_SECRET }}
",0
286,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_run.<branches|branches-ignore>,"When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - releases/**
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
287,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_run.<branches|branches-ignore>,"When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches-ignore:
      - ""canary""","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - ""releases/*""
    branches-ignore:
      - ""canary""
",0
288,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_run.<branches|branches-ignore>,"When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary : You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. The order that you define patterns matters. For example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha , releases/beta/3-alpha , or main .","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/10-alpha'
      - '!releases/beta/3-alpha'
      - '!main'
",0
289,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_dispatch.inputs - Example of on.workflow_dispatch.inputs,"The triggered workflow receives the inputs in the inputs context. For more information, see Contexts . Note    The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.The maximum number of top-level properties forinputsis 10.The maximum payload forinputsis 65,535 characters. Note","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
      print_tags:
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    if: ${{ inputs.print_tags }} 
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }}","on:
  workflow_dispatch:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        default: 'default_value'
        type: string

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""Input value: ${{ github.event.inputs.example_input }}""
",0
290,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key.","permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none","permissions:
  contents: read
  issues: write
  pull-requests: none
",0
291,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: read-all,"permissions:
  contents: write
",0
292,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: write-all,"permissions:
  contents: write
",0
293,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions:",permissions: {},"permissions: {}
",0
294,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Setting the GITHUB_TOKEN permissions for all jobs in a workflow - Example: Setting the GITHUB_TOKEN permissions for an entire workflow,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can specify permissions at the top level of a workflow, so that the setting applies to all jobs in the workflow. This example shows permissions being set for the GITHUB_TOKEN that will apply to all jobs in the workflow. All permissions are granted read access.","name: ""My workflow""

on: [ push ]

permissions: read-all

jobs:
  ...","permissions:
  actions: read
  checks: read
  contents: read
  deployments: read
  issues: read
  packages: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read
",0
295,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - env - Example of env,"A map of variables that are available to the steps of all jobs in the workflow. You can also set variables that are only available to the steps of a single job or to a single step. For more information, see jobs.<job_id>.env and jobs.<job_id>.steps[*].env . Variables in the env map cannot be defined in terms of other variables in the map. When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.","env:
  SERVER: production","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      GLOBAL_VAR: global_value
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Print global variable
        run: echo $GLOBAL_VAR
      - name: Set job-specific variable
        env:
          JOB_VAR: job_value
        run: echo $JOB_VAR
      - name: Set step-specific variable
        env:
          STEP_VAR: step_value
        run: echo $STEP_VAR
",0
296,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - defaults.run - Example: Set the default shell and working directory,"You can use defaults.run to provide default shell and working-directory options for all run steps in a workflow. You can also set default settings for run that are only available to a job. For more information, see jobs.<job_id>.defaults.run . You cannot use contexts or expressions in this keyword. When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","defaults:
  run:
    shell: bash
    working-directory: ./scripts","jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./my-directory
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: ./script.sh
",0
297,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using concurrency and the default behavior,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:","on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true
",0
298,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using concurrency and the default behavior,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch: You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:","on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example-group
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
299,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Concurrency groups,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.","jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
300,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Concurrency groups,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled. Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:","on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job-1 in staging_environment concurrency group""
",0
301,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using concurrency to cancel any in-progress job or run,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true :","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true
",0
302,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using a fallback value,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true","jobs:
  example_job:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.head_ref || github.run_id }}
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
303,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Only cancel in-progress jobs or runs for the current workflow,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow. To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}
      cancel-in-progress: true
",0
304,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Only cancel in-progress jobs on specific branches,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches. To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: ${{ !startsWith(github.ref, 'refs/heads/release/') }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job""
",0
305,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id> - Example: Creating jobs,"Use jobs.<job_id> to give your job a unique identifier. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, - , or _ . In this example, two jobs have been created, and their job_id values are my_first_job and my_second_job .","jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

  my_second_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
306,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key.","permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none","jobs:
  example_job:
    permissions:
      contents: read
      issues: write
",0
307,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: read-all,"jobs:
  example_job:
    permissions:
      contents: read
      issues: write
",0
308,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: write-all,"jobs:
  example_job:
    permissions:
      contents: read
      issues: write
",0
309,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions:",permissions: {},"jobs:
  example_job:
    permissions:
      contents: read
      issues: write
",0
310,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes - Example: Setting the GITHUB_TOKEN permissions for one job in a workflow,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions: This example shows permissions being set for the GITHUB_TOKEN that will only apply to the job named stale . Write access is granted for the issues and pull-requests permissions. All other permissions will have no access.","jobs:
  stale:
    runs-on: ubuntu-latest

    permissions:
      issues: write
      pull-requests: write

    steps:
      - uses: actions/stale@v9","jobs:
  stale:
    permissions:
      issues: write
      pull-requests: write
",0
311,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.needs - Example: Requiring successful dependent jobs,"Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if .","jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Job 1""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ""Job 2""

  job3:
    runs-on: ubuntu-latest
    needs: job2
    steps:
      - run: echo ""Job 3""
",0
312,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.needs - Example: Not requiring successful dependent jobs,"Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if .","jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Job 1""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    if: always()
    steps:
      - run: echo ""Job 2""
",0
313,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.if,"You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . Note  Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied. Note The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","jobs:
  example_job:
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
314,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.if - Example: Only run job for specific repository,"You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . Note  Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied. Note The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . This example uses if to control when the production-deploy job can run. It will only run if the repository is named octo-repo-prod and is within the octo-org organization. Otherwise, the job will be marked as skipped .","name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats","jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
315,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu :","runs-on: [self-hosted, linux, x64, gpu]","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
316,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example:","on:
  workflow_dispatch:
    inputs:
      chosen-os:
        required: true
        type: choice
        options:
        - Ubuntu
        - macOS

jobs:
  test:
    runs-on: [self-hosted, ""${{ inputs.chosen-os }}""]
    steps:
    - run: echo Hello world!","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
317,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Standard GitHub-hosted runners for  private repositories - Example: Specifying an operating system,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions . In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners . Note  The-latestrunner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor. The -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor. Warning  Beta and Deprecated Images are provided ""as-is"", ""with all faults"" and ""as available"" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support. Warning Beta and Deprecated Images are provided ""as-is"", ""with all faults"" and ""as available"" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.",runs-on: ubuntu-latest,"jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
318,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Choosing self-hosted runners - Example: Using labels for runner selection,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels. Self-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted . You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify. Note that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.","runs-on: [self-hosted, linux]","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
319,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Choosing runners in a group - Example: Using groups to control where jobs are run,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels. Runner groups can only have larger runners or self-hosted runners as members. In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
320,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Choosing runners in a group - Example: Combining groups and labels,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels. Runner groups can only have larger runners or self-hosted runners as members. When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example_job:
    runs-on: [ubuntu-runners, ubuntu-20.04-16core]
",0
321,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using a single environment name,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .",environment: staging_environment,"jobs:
  example_job:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
322,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using environment name and URL,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .","environment:
  name: production_environment
  url: https://github.com","jobs:
  example_job:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
323,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using output as URL,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .","environment:
  name: production_environment
  url: ${{ steps.step_id.outputs.url_output }}","jobs:
  example_job:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
324,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using an expression as environment name,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .","environment:
  name: ${{ github.ref_name }}","jobs:
  example_job:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
325,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:","on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example-group
      cancel-in-progress: true
",0
326,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch: You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:","on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example-group
      cancel-in-progress: true
",0
327,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.","jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
328,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled. Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:","on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
329,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using concurrency to cancel any in-progress job or run,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true :","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example_group
      cancel-in-progress: true
",0
330,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using a fallback value,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.head_ref || github.run_id }}
      cancel-in-progress: true
",0
331,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Only cancel in-progress jobs or runs for the current workflow,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow. To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}
      cancel-in-progress: true
",0
332,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Only cancel in-progress jobs on specific branches,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches. To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: ${{ !startsWith(github.ref, 'refs/heads/release/') }}
",0
333,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.outputs - Example: Defining outputs for a job,"You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs . Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions. If an output is skipped because it may contain a secret, you will see the following warning message: ""Skip output {output.Key} since it may contain secret."" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows . To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs .","jobs:
  job1:
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      output1: ${{ steps.step1.outputs.test }}
      output2: ${{ steps.step2.outputs.test }}
    steps:
      - id: step1
        run: echo ""test=hello"" >> ""$GITHUB_OUTPUT""
      - id: step2
        run: echo ""test=world"" >> ""$GITHUB_OUTPUT""
  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - env:
          OUTPUT1: ${{needs.job1.outputs.output1}}
          OUTPUT2: ${{needs.job1.outputs.output2}}
        run: echo ""$OUTPUT1 $OUTPUT2""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""output_value=Hello World"" >> $GITHUB_ENV
    outputs:
      output_key: ${{ steps.run.outputs.output_value }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Use output from build
        run: echo ""The output is ${{ needs.build.outputs.output_key }}""
",0
334,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.outputs - Using Job Outputs in a Matrix Job,"You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs . Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions. If an output is skipped because it may contain a secret, you will see the following warning message: ""Skip output {output.Key} since it may contain secret."" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows . To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs . Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.","jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      output_1: ${{ steps.gen_output.outputs.output_1 }}
      output_2: ${{ steps.gen_output.outputs.output_2 }}
      output_3: ${{ steps.gen_output.outputs.output_3 }}
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - name: Generate output
        id: gen_output
        run: |
          version=""${{ matrix.version }}""
          echo ""output_${version}=${version}"" >> ""$GITHUB_OUTPUT""
  job2:
    runs-on: ubuntu-latest
    needs: [job1]
    steps:
      # Will show
      # {
      #   ""output_1"": ""1"",
      #   ""output_2"": ""2"",
      #   ""output_3"": ""3""
      # }
      - run: echo '${{ toJSON(needs.job1.outputs) }}'","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [10, 12, 14]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set output
        id: set-output
        run: echo ""node-version=${{ matrix.node }}"" >> $GITHUB_ENV
    outputs:
      node-version: ${{ steps.set-output.outputs.node-version }}

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Use node version
        run: echo ""Using Node.js version ${{ needs.build.outputs.node-version }}""
",0
335,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.env - Example of jobs.<job_id>.env,"A map of variables that are available to all steps in the job. You can set variables for the entire workflow or an individual step. For more information, see env and jobs.<job_id>.steps[*].env . When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.","jobs:
  job1:
    env:
      FIRST_NAME: Mona","jobs:
  example_job:
    runs-on: ubuntu-latest
    env:
      JOB_VARIABLE: job_value
    steps:
      - name: Print job variable
        run: echo $JOB_VARIABLE
",0
336,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.defaults.run.working-directory - Example: Setting default run step options for a job,"Use working-directory to define the working directory for the shell for a step. This keyword can reference several contexts. For more information, see Contexts . Tip  Ensure theworking-directoryyou assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow. Tip Ensure the working-directory you assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","jobs:
  job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts","jobs:
  example-job:
    defaults:
      run:
        working-directory: ./my-directory
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: ./script.sh
",0
337,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps - Example of jobs.<job_id>.steps,"A job contains a sequence of tasks called steps . Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job. GitHub only displays the first 1,000 checks, however, you can run an unlimited number of steps as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and Usage limits for self-hosted runners for self-hosted runner usage limits.","name: Greeting from Mona

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - name: Print a greeting
        env:
          MY_VAR: Hi there! My name is
          FIRST_NAME: Mona
          MIDDLE_NAME: The
          LAST_NAME: Octocat
        run: |
          echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
338,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script if condition is met
        if: success() && github.event_name == 'push'
        run: echo ""This runs only on push events and if the previous step succeeded.""
",0
339,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if - Example: Using contexts,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . This step only runs when the event type is a pull_request and the event action is unassigned .","steps:
  - name: My first step
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}
    run: echo This event is a pull request that had an assignee removed.","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Example Step
        if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
        run: echo ""This step runs only when a pull request is unassigned.""
",0
340,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if - Example: Using status check functions,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . The my backup step only runs when the previous step of a job fails. For more information, see Evaluate expressions in workflows and actions .","steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: My Backup Step
        if: failure()
        run: echo ""This step runs only if the previous step fails""
",0
341,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if - Example: Using secrets,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string.","name: Run a step if a secret has been set
on: push
jobs:
  my-jobname:
    runs-on: ubuntu-latest
    env:
      super_secret: ${{ secrets.SuperSecret }}
    steps:
      - if: ${{ env.super_secret != '' }}
        run: echo 'This step will only run if the secret has a value set.'
      - if: ${{ env.super_secret == '' }}
        run: echo 'This step will only run if the secret does not have a value set.'","jobs:
  example_job:
    runs-on: ubuntu-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run step if secret is set
        if: env.SUPER_SECRET != ''
        run: echo ""Secret is set""
",0
342,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using versioned actions,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on .","steps:
  # Reference a specific commit
  - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
  # Reference the major version of a release
  - uses: actions/checkout@v4
  # Reference a specific version
  - uses: actions/checkout@v4.2.0
  # Reference a branch
  - uses: actions/checkout@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '14'
",0
343,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a public action,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . {owner}/{repo}@{ref} You can specify a branch, ref, or SHA in a public GitHub repository.","jobs:
  my_first_job:
    steps:
      - name: My first step
        # Uses the default branch of a public repository
        uses: actions/heroku@main
      - name: My second step
        # Uses a specific version tag of a public repository
        uses: actions/aws@v2.0.1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
",0
344,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a public action in a subdirectory,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . {owner}/{repo}/{path}@{ref} A subdirectory in a public GitHub repository at a specific branch, ref, or SHA.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/aws/ec2@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: owner/repo/path@ref
",0
345,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using an action in the same repository as the workflow,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . ./path/to/dir The path to the directory that contains the action in your workflow's repository. You must check out your repository before using the action. Example repository file structure: The path is relative ( ./ ) to the default working directory ( github.workspace , $GITHUB_WORKSPACE ). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated. Example workflow file:","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Run local action
        uses: ./path/to/dir
",0
346,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a Docker Hub action,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . docker://{image}:{tag} A Docker image published on Docker Hub .","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://{image}:{tag}
",0
347,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using the GitHub Packages Container registry,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . docker://{host}/{image}:{tag} A public Docker image in the GitHub Packages Container registry.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://ghcr.io/OWNER/IMAGE_NAME","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://ghcr.io/owner/repo:tag
",0
348,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a Docker public registry action,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . docker://{host}/{image}:{tag} A Docker image in a public registry. This example uses the Google Container Registry at gcr.io .","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://gcr.io/cloud-builders/gradle","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://gcr.io/my-image:latest
",0
349,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using an action inside a different private repository than the workflow,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . Your workflow must checkout the private repository and reference the action locally. Generate a personal access token and add the token as a secret. For more information, see Managing your personal access tokens and Using secrets in GitHub Actions . Replace PERSONAL_ACCESS_TOKEN in the example with the name of your secret.","jobs:
  my_first_job:
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          repository: octocat/my-private-repo
          ref: v1.0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          path: ./.github/actions/my-private-repo
      - name: Run my action
        uses: ./.github/actions/my-private-repo/my-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
      - name: Use action from private repository
        uses: owner/repo-name/path/to/action@v1
",0
350,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].run,"Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a name , the step name will default to the text specified in the run command. Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see jobs.<job_id>.steps[*].shell . Each run keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example: A single-line command:",#NAME?,"jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
351,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].run,"Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a name , the step name will default to the text specified in the run command. Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see jobs.<job_id>.steps[*].shell . Each run keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example: A single-line command: A multi-line command:","- name: Clean install dependencies and build
  run: |
    npm ci
    npm run build","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This is a single-line command""
      - run: |
          echo ""This is a multi-line command""
          echo ""Each line runs in the same shell""
",0
352,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].working-directory,"Using the working-directory keyword, you can specify the working directory of where to run the command.","- name: Clean temp directory
  run: rm -rf *
  working-directory: ./temp","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script
        run: ./script.sh
        working-directory: ./scripts
",0
353,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running a command using Bash,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: bash
    run: echo $PATH","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run a command using Bash
        run: echo ""Hello, World!""
        shell: bash
",0
354,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running a command using Windows cmd,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: cmd
    run: echo %PATH%","jobs:
  example_job:
    runs-on: windows-latest
    steps:
      - run: echo Hello, World!
        shell: cmd
",0
355,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running a command using PowerShell Core,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: pwsh
    run: echo ${env:PATH}","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run a command using PowerShell Core
        run: |
          Write-Host ""Hello, PowerShell Core!""
        shell: pwsh
",0
356,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Using PowerShell Desktop to run a command,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: powershell
    run: echo ${env:PATH}","jobs:
  example_job:
    runs-on: windows-latest
    steps:
      - run: Write-Host ""Hello, PowerShell!""
        shell: pwsh
",0
357,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running an inline Python script,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: python
    run: |
      import os
      print(os.environ['PATH'])","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run inline Python script
        shell: python
        run: |
          print(""Hello, World!"")
",0
358,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Custom shell,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell . You can set the shell value to a template string using command [options] {0} [more_options] . GitHub interprets the first whitespace-delimited word of the string as the command, and inserts the file name for the temporary script at {0} . For example:","steps:
  - name: Display the environment variables and their values
    shell: perl {0}
    run: |
      print %ENV","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
        shell: bash -c ""{0}""
",0
359,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].with - Example of jobs.<job_id>.steps[*].with,"A map of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed with INPUT_ and converted to upper case. Input parameters defined for a Docker container must use args . For more information, see jobs.<job_id>.steps[*].with.args . Defines the three input parameters ( first_name , middle_name , and last_name ) defined by the hello_world action. These input variables will be accessible to the hello-world action as INPUT_FIRST_NAME , INPUT_MIDDLE_NAME , and INPUT_LAST_NAME environment variables.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/hello_world@main
        with:
          first_name: Mona
          middle_name: The
          last_name: Octocat","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Hello World Action
        uses: actions/hello-world@v1
        with:
          first_name: John
          middle_name: F.
          last_name: Doe
",0
360,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].with.args - Example of jobs.<job_id>.steps[*].with.args,"A string that defines the inputs for a Docker container. GitHub passes the args to the container's ENTRYPOINT when the container starts up. An array of strings is not supported by this parameter. A single argument that includes spaces should be surrounded by double quotes """" .","steps:
  - name: Explain why this job ran
    uses: octo-org/action-name@main
    with:
      entrypoint: /bin/echo
      args: The ${{ github.event_name }} event triggered this step.","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run Docker container with args
        uses: docker://alpine:latest
        with:
          args: ""echo Hello, World""
",0
361,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].with.entrypoint - Example of jobs.<job_id>.steps[*].with.entrypoint,"Overrides the Docker ENTRYPOINT in the Dockerfile , or sets it if one wasn't already specified. Unlike the Docker ENTRYPOINT instruction which has a shell and exec form, entrypoint keyword accepts only a single string defining the executable to be run.","steps:
  - name: Run a custom command
    uses: octo-org/action-name@main
    with:
      entrypoint: /a/different/executable","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run Docker container with custom entrypoint
        uses: docker://alpine:latest
        with:
          entrypoint: ""/bin/sh""
",0
362,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].env - Example of jobs.<job_id>.steps[*].env,"Sets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job. For more information, see env and jobs.<job_id>.env . When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes. Public actions may specify expected variables in the README file. If you are setting a secret or sensitive value, such as a password or token, you must set secrets using the secrets context. For more information, see Accessing contextual information about workflow runs .","steps:
  - name: My first action
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      FIRST_NAME: Mona
      LAST_NAME: Octocat","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Example Step
        env:
          EXAMPLE_VAR: example_value
        run: echo $EXAMPLE_VAR
",0
363,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] :","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  build:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
",0
364,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a single-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify a single variable to create a single-dimension matrix. For example, the following workflow defines the variable version with the values [10, 12, 14] . The workflow will run three jobs, one for each value in the variable. Each job will access the version value through the matrix.version context and pass the value as node-version to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
365,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
366,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s.","matrix:
  os:
    - ubuntu-latest
    - macos-latest
  node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
",0
367,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s. This matrix produces 4 jobs with corresponding contexts.","- matrix.os: ubuntu-latest
  matrix.node.version: 14
- matrix.os: ubuntu-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
  matrix.node.version: 14
- matrix.os: macos-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
368,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using contexts to create matrices,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs . For example, the following workflow triggers on the repository_dispatch event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix version variable will have a value of [12, 14, 16] . For more information about the repository_dispatch trigger, see Events that trigger workflows .","on:
  repository_dispatch:
    types:
      - test
 
jobs:
  example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        version: [12, 14, 16]
        os: [ubuntu-latest, windows-latest]
",0
369,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix:","strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
          - os: windows-latest
            node: 14
          - os: ubuntu-latest
            node: 16
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
370,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include - Example: Expanding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, the following workflow will run four jobs, one for each combination of os and node . When the job for the os value of windows-latest and node value of 16 runs, an additional variable called npm with the value of 6 will be included in the job.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
371,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 .","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [14, 16, 18]
        include:
          - os: windows-latest
            version: 17
",0
372,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 . If you don't specify any matrix variables, all configurations under include will run. For example, the following workflow would run two jobs, one for each include entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.","jobs:
  includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: ""production""
            datacenter: ""site-a""
          - site: ""staging""
            datacenter: ""site-b""","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            version: 16
          - os: windows-latest
            version: 17
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
373,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.exclude,"To remove specific configurations defined in the matrix, use jobs.<job_id>.strategy.matrix.exclude . An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches {os: macos-latest, version: 12, environment: production} , and the two excluded jobs that match {os: windows-latest, version: 16} .","strategy:
  matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [12, 14, 16]
        environment: [development, production]
        exclude:
          - os: macos-latest
            version: 12
            environment: production
          - os: windows-latest
            version: 16
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on ${{ matrix.os }} with version ${{ matrix.version }} in ${{ matrix.environment }} environment""
",0
374,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.fail-fast,"You can control how job failures are handled with jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error . jobs.<job_id>.strategy.fail-fast applies to the entire matrix. If jobs.<job_id>.strategy.fail-fast is set to true or its expression evaluates to true , GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to true . jobs.<job_id>.continue-on-error applies to a single job. If jobs.<job_id>.continue-on-error is true , other jobs in the matrix will continue running even if the job with jobs.<job_id>.continue-on-error: true fails. You can use jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error together. For example, the following workflow will start four jobs. For each job, continue-on-error is determined by the value of matrix.experimental . If any of the jobs with continue-on-error: false fail, all jobs that are in progress or queued will be cancelled. If the job with continue-on-error: true fails, the other jobs will not be affected.","jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true","jobs:
  example:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        experimental: [true, false]
    steps:
    - name: Run a command
      run: echo ""Running job""
    continue-on-error: ${{ matrix.experimental }}
",0
375,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.max-parallel,"By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a matrix job strategy, use jobs.<job_id>.strategy.max-parallel . For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.","jobs:
  example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  example-job:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node: [12, 14]
      max-parallel: 2
    runs-on: ${{ matrix.os }}
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
376,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.continue-on-error - Example: Preventing a specific failing matrix job from failing a workflow run,"Prevents a workflow run from failing when a job fails. Set to true to allow a workflow run to pass when this job fails. You can allow specific jobs in a job matrix to fail without failing the workflow run. For example, if you wanted to only allow an experimental job with node set to 15 to fail without failing the workflow run.","runs-on: ${{ matrix.os }}
continue-on-error: ${{ matrix.experimental }}
strategy:
  fail-fast: false
  matrix:
    node: [13, 14]
    os: [macos-latest, ubuntu-latest]
    experimental: [false]
    include:
      - node: 15
        os: ubuntu-latest
        experimental: true","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [12, 14, 15]
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - run: npm install
      - run: npm test
    continue-on-error: ${{ matrix.node == 15 }}
",0
377,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container - Example: Running a job within a container,"Note  If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:  If you are using GitHub-hosted runners, you must use an Ubuntu runner.If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed. Note If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner: Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell .","name: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:20.04
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
378,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container - Example: Running a job within a container,"Note  If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:  If you are using GitHub-hosted runners, you must use an Ubuntu runner.If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed. Note If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner: Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell . When you only specify a container image, you can omit the image keyword.","jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container: node:18","jobs:
  example-job:
    runs-on: ubuntu-latest
    container: node:14
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script
        run: echo ""Hello, world!""
",0
379,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container.credentials - Example: Defining credentials for a container registry,"If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password . The credentials are the same values that you would provide to the docker login command.","container:
  image: ghcr.io/owner/image
  credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: my-container-image:latest
      credentials:
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
380,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container.volumes - Example: Mounting volumes in a container,"Use jobs.<job_id>.container.volumes to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host. To specify a volume, you specify the source and destination path: <source>:<destinationPath> . The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.","volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
      volumes:
        - /host/path:/container/path
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run a command
        run: echo ""Hello, World!""
",0
381,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services - Example: Using localhost,"Note  If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:  If you are using GitHub-hosted runners, you must use an Ubuntu runner.If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed. Note If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner: Used to host service containers for a job in a workflow. Service containers are useful for creating databases or cache services like Redis. The runner automatically creates a Docker network and manages the life cycle of the service containers. If you configure your job to run in a container, or your step uses container actions, you don't need to map ports to access the service or action. Docker automatically exposes all ports between containers on the same Docker user-defined bridge network. You can directly reference the service container by its hostname. The hostname is automatically mapped to the label name you configure for the service in the workflow. If you configure the job to run directly on the runner machine and your step doesn't use a container action, you must map any required Docker service container ports to the Docker host (the runner machine). You can access the service container using localhost and the mapped port. For more information about the differences between networking service containers, see About service containers . This example creates two services: nginx and redis. When you specify the container port but not the host port, the container port is randomly assigned to a free port on the host. GitHub sets the assigned host port in the ${{job.services.<service_name>.ports}} context. In this example, you can access the service host ports using the ${{ job.services.nginx.ports['80'] }} and ${{ job.services.redis.ports['6379'] }} contexts.","services:
  nginx:
    image: nginx
    # Map port 8080 on the Docker host to port 80 on the nginx container
    ports:
      - 8080:80
  redis:
    image: redis
    # Map random free TCP port on Docker host to port 6379 on redis container
    ports:
      - 6379/tcp
steps:
  - run: |
      echo ""Redis available on 127.0.0.1:${{ job.services.redis.ports['6379'] }}""
      echo ""Nginx available on 127.0.0.1:${{ job.services.nginx.ports['80'] }}""","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      nginx:
        image: nginx:latest
        ports:
          - 80
      redis:
        image: redis:latest
        ports:
          - 6379
    steps:
      - name: Check nginx and redis ports
        run: |
          echo ""Nginx is running on port ${{ job.services.nginx.ports['80'] }}""
          echo ""Redis is running on port ${{ job.services.redis.ports['6379'] }}""
",0
382,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services.<service_id>.image,"The Docker image to use as the service container to run the action. The value can be the Docker Hub image name or a registry name. If jobs.<job_id>.services.<service_id>.image is assigned an empty string, the service will not start. You can use this to set up conditional services, similar to the following example.","services:
  nginx:
    image: ${{ options.nginx == true && 'nginx' || '' }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      my-service:
        image: ''
",0
383,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services.<service_id>.credentials - Example of jobs.<job_id>.services.<service_id>.credentials,"If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password . The credentials are the same values that you would provide to the docker login command.","services:
  myservice1:
    image: ghcr.io/owner/myservice1
    credentials:
      username: ${{ github.actor }}
      password: ${{ secrets.github_token }}
  myservice2:
    image: dockerhub_org/myservice2
    credentials:
      username: ${{ secrets.DOCKER_USER }}
      password: ${{ secrets.DOCKER_PASSWORD }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      example-service:
        image: example-image:latest
        credentials:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
",0
384,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services.<service_id>.volumes - Example of jobs.<job_id>.services.<service_id>.volumes,"Sets an array of volumes for the service container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host. To specify a volume, you specify the source and destination path: <source>:<destinationPath> . The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.","volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      example-service:
        image: nginx:latest
        volumes:
          - /host/path:/container/path
",0
385,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.uses - Example of jobs.<job_id>.uses,"The location and version of a reusable workflow file to run as a job. Use one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword.","jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1","jobs:
  example_job:
    uses: owner/repo/.github/workflows/workflow.yml@commit_sha
",0
386,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.with - Example of jobs.<job_id>.with,"When a job is used to call a reusable workflow, you can use with to provide a map of inputs that are passed to the called workflow. Any inputs that you pass must match the input specifications defined in the called workflow. Unlike jobs.<job_id>.steps[*].with , the inputs you pass with jobs.<job_id>.with are not available as environment variables in the called workflow. Instead, you can reference the inputs by using the inputs context.","jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    with:
      username: mona","jobs:
  example_job:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@main
    with:
      input1: value1
      input2: value2
",0
387,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.secrets - Example of jobs.<job_id>.secrets,"When a job is used to call a reusable workflow, you can use secrets to provide a map of secrets that are passed to the called workflow. Any secrets that you pass must match the names defined in the called workflow.","jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    secrets:
      access-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}","jobs:
  example_job:
    uses: ./.github/workflows/reusable-workflow.yml
    secrets:
      SECRET_NAME: ${{ secrets.SECRET_NAME }}
",0
388,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.secrets.inherit - Example of jobs.<job_id>.secrets.inherit,"Use the inherit keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The inherit keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.","on:
  workflow_dispatch:

jobs:
  pass-secrets-to-workflow:
    uses: ./.github/workflows/called-workflow.yml
    secrets: inherit","jobs:
  example_job:
    secrets:
      inherit: true
",0
389,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.secrets.inherit - Example of jobs.<job_id>.secrets.inherit,"Use the inherit keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The inherit keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.","on:
  workflow_call:

jobs:
  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
      - name: Use a repo or org secret from the calling workflow.
        run: echo ${{ secrets.CALLING_WORKFLOW_SECRET }}","jobs:
  example_job:
    secrets:
      inherit: true
",0
390,https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - Filter pattern cheat sheet,"You can use special characters in path, branch, and tag filters. The characters * , [ , and ! are special characters in YAML. If you start a pattern with * , [ , or ! , you must enclose the pattern in quotes. Also, if you use a flow sequence with a pattern containing [ and/or ] , the pattern must be enclosed in quotes.","# Valid
paths:
  - '**/README.md'

# Invalid - creates a parse error that
# prevents your workflow from running.
paths:
  - **/README.md

# Valid
branches: [ main, 'release/v[0-9].[0-9]' ]

# Invalid - creates a parse error
branches: [ main, release/v[0-9].[0-9] ]","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
391,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Using a matrix - Travis CI syntax for a matrix,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions both support a matrix, allowing you to perform testing using combinations of operating systems and software packages. For more information, see Running variations of jobs in a workflow . Below is an example comparing the syntax for each system.","matrix:
  include:
    - rvm: '2.5'
    - rvm: '2.6.3'","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node: [12, 14, 16]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: ${{ matrix.node }}
    - run: npm install
    - run: npm test
",0
392,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Using a matrix - GitHub Actions syntax for a matrix,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions both support a matrix, allowing you to perform testing using combinations of operating systems and software packages. For more information, see Running variations of jobs in a workflow . Below is an example comparing the syntax for each system.","jobs:
  build:
    strategy:
      matrix:
        ruby: ['2.5', '2.6.3']","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node: [12, 14, 16]
    steps:
    - uses: actions/checkout@v2
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: ${{ matrix.node }}
    - run: npm install
    - run: npm test
",0
393,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Targeting specific branches - Travis CI syntax for targeting specific branches,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions both allow you to target your CI to a specific branch. For more information, see Workflow syntax for GitHub Actions . Below is an example of the syntax for each system.","branches:
  only:
    - main
    - 'mona/octocat'","on:
  push:
    branches:
      - main
      - develop
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
394,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Targeting specific branches - GitHub Actions syntax for targeting specific branches,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions both allow you to target your CI to a specific branch. For more information, see Workflow syntax for GitHub Actions . Below is an example of the syntax for each system.","on:
  push:
    branches:
      - main
      - 'mona/octocat'","on:
  push:
    branches:
      - main
      - develop
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
395,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Checking out submodules - Travis CI syntax for checking out submodules,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions both allow you to control whether submodules are included in the repository clone. Below is an example of the syntax for each system.","git:
  submodules: false","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
",0
396,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Checking out submodules - GitHub Actions syntax for checking out submodules,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions both allow you to control whether submodules are included in the repository clone. Below is an example of the syntax for each system.","- uses: actions/checkout@v4
  with:
    submodules: false","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
",0
397,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Key similarities - Using environment variables in a matrix,"GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process. Travis CI and GitHub Actions can both add custom variables to a test matrix, which allows you to refer to the variable in a later step. In GitHub Actions, you can use the include key to add custom environment variables to a matrix. In this example, the matrix entries for node-version are each configured to use different values for the site and datacenter environment variables. The Echo site details step then uses env: ${{ matrix.env }} to refer to the custom variables:","name: Node.js CI
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
       include:
         - node-version: '14.x'
           site: ""prod""
           datacenter: ""site-a""
         - node-version: '16.x'
           site: ""dev""
           datacenter: ""site-b""
    steps:
      - name: Echo site details
        env:
          SITE: ${{ matrix.site }}
          DATACENTER: ${{ matrix.datacenter }}
        run: echo $SITE $DATACENTER","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - node-version: 14
            site: example1.com
            datacenter: us-east
          - node-version: 16
            site: example2.com
            datacenter: eu-west
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Echo site details
        run: echo ""Site: ${{ matrix.site }}, Datacenter: ${{ matrix.datacenter }}""
",0
398,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Executing scripts,"GitHub Actions can use run steps to run scripts or shell commands. To use a particular shell, you can specify the shell type when providing the path to the script. For more information, see Workflow syntax for GitHub Actions . For example:","steps:
  - name: Run build script
    run: ./.github/scripts/build.sh
    shell: bash","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run script
        run: ./your-script.sh
        shell: bash
",0
399,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Migrating syntax for conditionals and expressions,"To run jobs under conditional expressions, Travis CI and GitHub Actions share a similar if condition syntax. GitHub Actions lets you use the if conditional to prevent a job or step from running unless a condition is met. For more information, see Evaluate expressions in workflows and actions . This example demonstrates how an if conditional can control whether a step is executed:","jobs:
  conditional:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This step runs with str equals 'ABC' and num equals 123""
        if: env.str == 'ABC' && env.num == 123","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        if: ${{ condition }}
        run: echo ""This step runs if the condition is true""
",0
400,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Migrating phases to steps - Travis CI syntax for phases and steps,"Where Travis CI uses phases to run steps , GitHub Actions has steps which execute actions . You can find prebuilt actions in the GitHub Marketplace , or you can create your own actions. For more information, see Sharing automations . Below is an example of the syntax for each system.","language: python
python:
  - ""3.7""

script:
  - python script.py","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
401,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Migrating phases to steps - GitHub Actions syntax for steps and actions,"Where Travis CI uses phases to run steps , GitHub Actions has steps which execute actions . You can find prebuilt actions in the GitHub Marketplace , or you can create your own actions. For more information, see Sharing automations . Below is an example of the syntax for each system.","jobs:
  run_python:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: '3.7'
          architecture: 'x64'
      - run: python script.py","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
402,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Caching dependencies - Travis CI syntax for caching,Travis CI and GitHub Actions let you manually cache dependencies for later reuse. These examples demonstrate the cache syntax for each system.,"language: node_js
cache: npm","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Cache node modules
      uses: actions/cache@v2
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    - run: npm install
    - run: npm test
",0
403,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Caching dependencies - GitHub Actions syntax for caching,Travis CI and GitHub Actions let you manually cache dependencies for later reuse. These examples demonstrate the cache syntax for each system.,"- name: Cache node modules
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}
    restore-keys: v1-npm-deps-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Cache node modules
      uses: actions/cache@v2
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    - run: npm install
    - run: npm test
",0
404,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Examples of common tasks - Configuring environment variables - Travis CI syntax for an environment variable,This section compares how GitHub Actions and Travis CI perform common tasks. You can create custom environment variables in a GitHub Actions job.,"env:
  - MAVEN_PATH=""/usr/local/maven""","jobs:
  build:
    runs-on: ubuntu-latest
    env:
      CUSTOM_VAR: example_value
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo $CUSTOM_VAR
",0
405,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Examples of common tasks - Configuring environment variables - GitHub Actions workflow with an environment variable,This section compares how GitHub Actions and Travis CI perform common tasks. You can create custom environment variables in a GitHub Actions job.,"jobs:
  maven-build:
    env:
      MAVEN_PATH: '/usr/local/maven'","jobs:
  build:
    runs-on: ubuntu-latest
    env:
      CUSTOM_VAR: example_value
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Print environment variable
        run: echo $CUSTOM_VAR
",0
406,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Examples of common tasks - Building with Node.js - Travis CI for building with Node.js,This section compares how GitHub Actions and Travis CI perform common tasks.,"install:
  - npm install
script:
  - npm run build
  - npm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - run: npm install
    - run: npm test
",0
407,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions,Migrating from Travis CI to GitHub Actions - Examples of common tasks - Building with Node.js - GitHub Actions workflow for building with Node.js,This section compares how GitHub Actions and Travis CI perform common tasks.,"name: Node.js CI
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16.x'
      - run: npm install
      - run: npm run build
      - run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '14'
    - run: npm install
    - run: npm test
",0
408,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=webui,Using secrets in GitHub Actions - Using secrets in a workflow,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions .","steps:
  - name: Hello world action
    with: # Set the secret as an input
      super_secret: ${{ secrets.SuperSecret }}
    env: # Or as an environment variable
      super_secret: ${{ secrets.SuperSecret }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Use secret as environment variable
        run: echo ""Secret is ${{ secrets.MY_SECRET }}""
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}

      - name: Authenticate with cloud provider using OIDC
        uses: actions/oidc-auth@v1
        with:
          provider: my-cloud-provider
          audience: my-audience
",0
409,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=webui,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Bash,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: bash
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$SUPER_SECRET""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret in Bash
        env:
          SUPER_SECRET: ${{ secrets.SuperSecret }}
        run: echo ""The secret is $SUPER_SECRET""
",0
410,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=webui,Using secrets in GitHub Actions - Using secrets in a workflow - Example using PowerShell,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: pwsh
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$env:SUPER_SECRET""","jobs:
  example:
    runs-on: ubuntu-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run PowerShell script
        shell: pwsh
        run: |
          Write-Host ""The secret is $env:SUPER_SECRET""
",0
411,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=webui,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Cmd.exe,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: cmd
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""%SUPER_SECRET%""","jobs:
  example:
    runs-on: windows-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run command with secret
        run: |
          echo %SUPER_SECRET%
        shell: cmd
",0
412,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=webui,Using secrets in GitHub Actions - Limits for secrets - Storing large secrets,"You can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets. A workflow created in a repository can access the following number of secrets: Secrets are limited to 48 KB in size. To store larger secrets, see the Storing large secrets workaround below. To use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can use gpg to encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see the gpg manpage . Warning  Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Warning Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Run the following command from your terminal to encrypt the file containing your secret using gpg and the AES256 cipher algorithm. In this example, my_secret.json is the file containing the secret. You will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value. Create a new secret that contains the passphrase. For example, create a new secret with the name LARGE_SECRET_PASSPHRASE and set the value of the secret to the passphrase you used in the step above. Copy your encrypted file to a path in your repository and commit it. In this example, the encrypted file is my_secret.json.gpg . Warning  Make sure to copy the encryptedmy_secret.json.gpgfile ending with the.gpgfile extension, andnotthe unencryptedmy_secret.jsonfile. Make sure to copy the encrypted my_secret.json.gpg file ending with the .gpg file extension, and not the unencrypted my_secret.json file. Create a shell script in your repository to decrypt the secret file. In this example, the script is named decrypt_secret.sh . Ensure your shell script is executable before checking it in to your repository. In your GitHub Actions workflow, use a step to call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use the actions/checkout action. Reference your shell script using the run command relative to the root of your repository.","name: Workflows with large secrets

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Decrypt large secret
        run: ./decrypt_secret.sh
        env:
          LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      # This command is just an example to show your secret being printed
      # Ensure you remove any print statements of your secrets. GitHub does
      # not hide secrets that use this workaround.
      - name: Test printing your secret (Remove this step in production)
        run: cat $HOME/secrets/my_secret.json","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Decrypt secret
      env:
        PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      run: |
        gpg --quiet --batch --yes --decrypt --passphrase=""$PASSPHRASE"" --output my_secret.json my_secret.json.gpg
        chmod +x decrypt_secret.sh
        ./decrypt_secret.sh
",0
413,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=webui,Using secrets in GitHub Actions - Storing Base64 binary blobs as secrets,"You can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, see Using secrets in GitHub Actions . Note  Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Note Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Use base64 to encode your file into a Base64 string. For example: On macOS, you could run: On Linux, you could run: Create a secret that contains the Base64 string. For example: To access the Base64 string from your runner, pipe the secret to base64 --decode . For example:","name: Retrieve Base64 secret
on:
  push:
    branches: [ octo-branch ]
jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Retrieve the secret and decode it to a file
        env:
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
        run: |
          echo $CERTIFICATE_BASE64 | base64 --decode > cert.der
      - name: Show certificate information
        run: |
          openssl x509 -in cert.der -inform DER -text -noout","jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Decode Base64 secret
        run: echo ${{ secrets.BASE64_SECRET }} | base64 --decode > decoded_file
",0
414,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Using workflow commands to access toolkit functions - Example: Creating an annotation for an error,"The actions/toolkit includes a number of functions that can be executed as workflow commands. Use the :: syntax to run the workflow commands within your YAML file; these commands are then sent to the runner over stdout . For example, instead of using code to create an error annotation, as below: You can use the error command in your workflow to create the same error annotation:","- name: Create annotation for build error
        run: echo ""::error file=app.js,line=1::Missing semicolon""","jobs:
  create-error-annotation:
    runs-on: ubuntu-latest
    steps:
      - name: Create error annotation
        run: echo ""::error file=app.js,line=10,col=15::Syntax error""
",0
415,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Grouping log lines - Example: Grouping log lines,"Creates an expandable group in the log. To create a group, use the group command and specify a title . Anything you print to the log between the group and endgroup commands is nested inside an expandable entry in the log.","jobs:
  bash-example:
    runs-on: ubuntu-latest
    steps:
      - name: Group of log lines
        run: |
            echo ""::group::My title""
            echo ""Inside group""
            echo ""::endgroup::""","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Group log lines
        run: |
          echo ""::group::My expandable group""
          echo ""This is inside the group""
          echo ""Another line inside the group""
          echo ""::endgroup::""
",0
416,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking an environment variable,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. When you print the variable MY_NAME or the value ""Mona The Octocat"" in the log, you'll see ""***"" instead of ""Mona The Octocat"" .","jobs:
  bash-example:
    runs-on: ubuntu-latest
    env:
      MY_NAME: ""Mona The Octocat""
    steps:
      - name: bash-version
        run: echo ""::add-mask::$MY_NAME""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Mask environment variable
        run: |
          echo ""::add-mask::$MY_NAME""
          echo ""My name is $MY_NAME""
        env:
          MY_NAME: ""Mona The Octocat""
",0
417,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking a generated output within a single job,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you do not need to pass your secret from one job to another job, you can:","on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        run: |
          the_secret=$((RANDOM))
          echo ""::add-mask::$the_secret""
          echo ""secret-number=$the_secret"" >> ""$GITHUB_OUTPUT""
      - name: Use that secret output (protected by a mask)
        run: |
          echo ""the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Generate secret
        id: generate_secret
        run: echo ""SECRET_VALUE=super_secret_value"" >> $GITHUB_ENV

      - name: Mask secret
        run: echo ""::add-mask::$SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}

      - name: Print secret
        run: echo ""The secret is $SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}
",0
418,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking and passing a secret between jobs or workflows - Workflow,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you want to pass a masked secret between jobs or workflows, you should store the secret in a store and then retrieve it in the subsequent job or workflow. Note  This workflow uses an imaginary secret store,secret-store, which has imaginary commandsstore-secretandretrieve-secret.some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29is an imaginary action that installs thesecret-storeapplication and configures it to connect to aninstancewithcredentials. Note This workflow uses an imaginary secret store, secret-store , which has imaginary commands store-secret and retrieve-secret . some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29 is an imaginary action that installs the secret-store application and configures it to connect to an instance with credentials .","on: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    outputs:
      handle: ${{ steps.generate-secret.outputs.handle }}
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      id: generate-secret
      shell: bash
      run: |
        GENERATED_SECRET=$((RANDOM))
        echo ""::add-mask::$GENERATED_SECRET""
        SECRET_HANDLE=$(secret-store store-secret ""$GENERATED_SECRET"")
        echo ""handle=$SECRET_HANDLE"" >> ""$GITHUB_OUTPUT""
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: bash
      run: |
        SECRET_HANDLE=""${{ needs.secret-generator.outputs.handle }}""
        RETRIEVED_SECRET=$(secret-store retrieve-secret ""$SECRET_HANDLE"")
        echo ""::add-mask::$RETRIEVED_SECRET""
        echo ""We retrieved our masked secret: $RETRIEVED_SECRET""","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Store secret
        run: store-secret my_secret_value

  job2:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Retrieve secret
        run: retrieve-secret
",0
419,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Stopping and starting workflow commands - Example: Stopping and starting workflow commands,"Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command. For example, you could stop logging to output an entire script that has comments. To stop the processing of workflow commands, pass a unique token to stop-commands . To resume processing workflow commands, pass the same token that you used to stop workflow commands. Warning  Make sure the token you're using is randomly generated and unique for each run. Warning Make sure the token you're using is randomly generated and unique for each run.","jobs:
  workflow-command-job:
    runs-on: ubuntu-latest
    steps:
      - name: Disable workflow commands
        run: |
          echo '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          stopMarker=$(uuidgen)
          echo ""::stop-commands::$stopMarker""
          echo '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          echo ""::$stopMarker::""
          echo '::warning:: This is a warning again, because stop-commands has been turned off.'","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Stop workflow commands
        run: echo ""::stop-commands::${{ secrets.UNIQUE_TOKEN }}""

      - name: Log script
        run: |
          echo ""This is a script with comments""
          echo ""# This is a comment""
          echo ""echo Hello World""

      - name: Start workflow commands
        run: echo ""::${{ secrets.UNIQUE_TOKEN }}::""
",0
420,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how:","name: Example Workflow for Environment Files

on: push

jobs:
  set_and_use_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_ENV_VAR=myValue"" >> $GITHUB_ENV

      - name: Use environment variable
        run: |
          echo ""The value of MY_ENV_VAR is $MY_ENV_VAR""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variable
        run: echo ""MY_VAR=HelloWorld"" >> $GITHUB_ENV

      - name: Use environment variable
        run: echo ""The value of MY_VAR is $MY_VAR""
",0
421,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how: Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names:","steps:
  - name: Store build timestamp
    run: echo ""BUILD_TIME=$(date +'%T')"" >> $GITHUB_ENV

  - name: Deploy using stored timestamp
    run: echo ""Deploying at $BUILD_TIME""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    - name: Set environment variables
      run: |
        echo ""BUILD_TIMESTAMP=$(date +%Y%m%d%H%M%S)"" >> $GITHUB_ENV
        echo ""COMMIT_SHA=$(git rev-parse HEAD)"" >> $GITHUB_ENV
        echo ""ARTIFACT_NAME=my-artifact"" >> $GITHUB_ENV
    - name: Use environment variables
      run: |
        echo ""Build Timestamp: $BUILD_TIMESTAMP""
        echo ""Commit SHA: $COMMIT_SHA""
        echo ""Artifact Name: $ARTIFACT_NAME""
",0
422,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Setting an environment variable - Example of writing an environment variable to GITHUB_ENV,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable.","steps:
  - name: Set the value
    id: step_one
    run: |
      echo ""action_state=yellow"" >> ""$GITHUB_ENV""
  - name: Use the value
    id: step_two
    run: |
      printf '%s\n' ""$action_state"" # This will output 'yellow'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_VARIABLE=some_value"" >> $GITHUB_ENV
      - name: Use environment variable
        run: echo ""The value of MY_VARIABLE is $MY_VARIABLE""
",0
423,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Setting an environment variable - Multiline strings - Example of a multiline string,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable. For multiline strings, you may use a delimiter with the following syntax. Warning  Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. Warning Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. This example uses EOF as the delimiter, and sets the JSON_RESPONSE environment variable to the value of the curl response.","steps:
  - name: Set the value in bash
    id: step_one
    run: |
      {
        echo 'JSON_RESPONSE<<EOF'
        curl https://example.com
        echo EOF
      } >> ""$GITHUB_ENV""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set JSON_RESPONSE environment variable
        run: |
          echo ""JSON_RESPONSE<<EOF"" >> $GITHUB_ENV
          echo '{ ""status"": ""success"", ""data"": { ""id"": 123, ""name"": ""example"" } }' >> $GITHUB_ENV
          echo ""EOF"" >> $GITHUB_ENV
",0
424,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Setting an output parameter - Example of setting an output parameter,Sets a step's output parameter. Note that the step will need an id to be defined to later retrieve the output value. You can set multi-line output values with the same technique used in the Multiline strings section to define multi-line environment variables. This example demonstrates how to set the SELECTED_COLOR output parameter and later retrieve it:,"- name: Set color
        id: color-selector
        run: echo ""SELECTED_COLOR=green"" >> ""$GITHUB_OUTPUT""
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: echo ""The selected color is $SELECTED_COLOR""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - id: set-output
        run: echo ""SELECTED_COLOR=blue"" >> $GITHUB_ENV

      - run: echo ""The selected color is ${{ steps.set-output.outputs.SELECTED_COLOR }}""
",0
425,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Adding a job summary - Multiline Markdown content - Example of multiline Markdown content,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. For multiline Markdown content, you can use >> to continuously append content for the current step. With every append operation, a newline character is automatically added.","- name: Generate list using Markdown
  run: |
    echo ""This is the lead in sentence for the list"" >> $GITHUB_STEP_SUMMARY
    echo """" >> $GITHUB_STEP_SUMMARY # this is a blank line
    echo ""- Lets add a bullet point"" >> $GITHUB_STEP_SUMMARY
    echo ""- Lets add a second bullet point"" >> $GITHUB_STEP_SUMMARY
    echo ""- How about a third one?"" >> $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: |
          echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY
          echo ""This is a multiline"" >> $GITHUB_STEP_SUMMARY
          echo ""Markdown content"" >> $GITHUB_STEP_SUMMARY
",0
426,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Adding a job summary - Overwriting job summaries - Example of overwriting job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To clear all content for the current step, you can use > to overwrite any previously added content in Bash, or remove -Append in PowerShell","- name: Overwrite Markdown
  run: |
    echo ""Adding some Markdown content"" >> $GITHUB_STEP_SUMMARY
    echo ""There was an error, we need to clear the previous Markdown with some new content."" > $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" > $GITHUB_STEP_SUMMARY
      - name: Overwrite job summary
        run: echo ""## Overwritten Job Summary"" > $GITHUB_STEP_SUMMARY
",0
427,https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Adding a job summary - Removing job summaries - Example of removing job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To completely remove a summary for the current step, the file that GITHUB_STEP_SUMMARY references can be deleted.","- name: Delete all summary content
  run: |
    echo ""Adding Markdown content that we want to remove before the step ends"" >> $GITHUB_STEP_SUMMARY
    rm $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY

      - name: Remove job summary
        run: rm $GITHUB_STEP_SUMMARY
",0
428,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using tags for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions: This example demonstrates how a user can reference a major release tag:","steps:
    - uses: actions/javascript-action@v1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: example/action@v1
",0
429,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using tags for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions: This example demonstrates how a user can reference a major release tag: This example demonstrates how a user can reference a specific patch release tag:","steps:
    - uses: actions/javascript-action@v1.0.1","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: example/action@v1
      - uses: example/action@v1.0.1
",0
430,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using branches for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. If you prefer to use branch names for release management, this example demonstrates how to reference a named branch:","steps:
    - uses: actions/javascript-action@v1-beta","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
      - uses: owner/repo@branch-name
",0
431,https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions,About custom actions - Using release management for actions - Using a commit's SHA for release management,"This section explains how you can use release management to distribute updates to your actions in a predictable way. Each Git commit receives a calculated SHA value, which is unique and immutable. Your action's users might prefer to rely on a commit's SHA value, as this approach can be more reliable than specifying a tag, which could be deleted or moved. However, this means that users will not receive further updates made to the action. You must use a commit's full SHA value, and not an abbreviated value.","steps:
    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@<full-commit-SHA>
",0
432,https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action,Creating a JavaScript action - Creating an action metadata file,"Create a new file named action.yml in the hello-world-javascript-action directory with the following example code. For more information, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'node20'
  main: 'index.js'","name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:
    description: 'Who to greet'
    required: true
    default: 'World'
runs:
  using: 'node12'
  main: 'index.js'
",0
433,https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action,Creating a JavaScript action - Testing out your action in a workflow - Example using a public action,"Now you're ready to test your action out in a workflow. Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository . This example demonstrates how your new public action can be run from within an external repository. Copy the following YAML into a new file at .github/workflows/main.yml , and update the uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b line with your username and the name of the public repository you created above. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  test-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: your-username/your-repo-name@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: ""Your Name""
",0
434,https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action,Creating a JavaScript action - Testing out your action in a workflow - Example using a private action,"Now you're ready to test your action out in a workflow. Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository . Copy the workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run private action
        uses: ./  # This assumes the action is in the same repository
        with:
          who-to-greet: YourName
",0
435,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors,Troubleshooting Actions Runner Controller errors - Resources labels - Controller pod,"Labels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting. The following labels are applied to the controller pod.","app.kubernetes.io/component=controller-manager
app.kubernetes.io/instance=<controller installation name>
app.kubernetes.io/name=gha-runner-scale-set-controller
app.kubernetes.io/part-of=gha-runner-scale-set-controller
app.kubernetes.io/version=<chart version>","jobs:
  troubleshoot:
    runs-on: ubuntu-latest
    steps:
      - name: Check controller pod labels
        run: kubectl get pods -l app=actions-runner-controller -o jsonpath=""{.items[*].metadata.labels}""
",0
436,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors,Troubleshooting Actions Runner Controller errors - Resources labels - Listener pod,"Labels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting. The following labels are applied to listener pods.","actions.github.com/enterprise= # Will be populated if githubConfigUrl is an enterprise URL
actions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL
actions.github.com/repository= # Will be populated if githubConfigUrl is a repository URL
actions.github.com/scale-set-name= # Runners scale set name
actions.github.com/scale-set-namespace= # Runners namespace
app.kubernetes.io/component=runner-scale-set-listener
app.kubernetes.io/part-of=gha-runner-scale-set
app.kubernetes.io/version= # Chart version","jobs:
  troubleshoot:
    runs-on: ubuntu-latest
    steps:
      - name: Check listener pod labels
        run: kubectl get pods -l app=actions-runner-controller-listener -o json | jq '.items[].metadata.labels'
",0
437,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors,Troubleshooting Actions Runner Controller errors - Resources labels - Runner pod,"Labels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting. The following labels are applied to runner pods.","actions-ephemeral-runner= # True | False
actions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL
actions.github.com/scale-set-name= # Runners scale set name
actions.github.com/scale-set-namespace= # Runners namespace
app.kubernetes.io/component=runner
app.kubernetes.io/part-of=gha-runner-scale-set
app.kubernetes.io/version= # Chart version","jobs:
  troubleshoot:
    runs-on: ubuntu-latest
    steps:
      - name: Check runner pod labels
        run: kubectl get pods -l app=actions-runner -o jsonpath='{.items[*].metadata.labels}'
",0
438,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors,Troubleshooting Actions Runner Controller errors - Error: Access to the path /home/runner/_work/_tool is denied,"You may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume. To fix this, you can do one of the following things. Use a volume type that supports securityContext.fsGroup . hostPath volumes do not support this property, whereas local volumes and other types of volumes do support it. Update the fsGroup of your runner pod to match the GID of the runner. You can do this by updating the gha-runner-scale-set helm chart values to include the following. Replace VERSION with the version of the actions-runner container image you want to use.","spec:
    securityContext:
        fsGroup: 123
    containers:
    - name: runner
    image: ghcr.io/actions/actions-runner:latest
    command: [""/home/runner/run.sh""]","containers:
  - name: actions-runner
    image: ghcr.io/actions/runner:VERSION
    securityContext:
      fsGroup: 1000
",0
439,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors,Troubleshooting Actions Runner Controller errors - Error: Access to the path /home/runner/_work/_tool is denied,"You may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume. To fix this, you can do one of the following things. Use a volume type that supports securityContext.fsGroup . hostPath volumes do not support this property, whereas local volumes and other types of volumes do support it. Update the fsGroup of your runner pod to match the GID of the runner. You can do this by updating the gha-runner-scale-set helm chart values to include the following. Replace VERSION with the version of the actions-runner container image you want to use. If updating the securityContext of your runner pod is not a viable solution, you can work around the issue by using initContainers to change the mounted volume's ownership, as follows.","template:
spec:
    initContainers:
    - name: kube-init
    image: ghcr.io/actions/actions-runner:latest
    command: [""sudo"", ""chown"", ""-R"", ""1001:123"", ""/home/runner/_work""]
    volumeMounts:
        - name: work
        mountPath: /home/runner/_work
    containers:
    - name: runner
    image: ghcr.io/actions/actions-runner:latest
    command: [""/home/runner/run.sh""]","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    - name: Run init container to change volume ownership
      run: |
        kubectl patch statefulset <statefulset-name> \
          --patch '{""spec"": {""template"": {""spec"": {""initContainers"": [{""name"": ""init-volume-permissions"", ""image"": ""busybox"", ""command"": [""sh"", ""-c"", ""chown -R 1001:0 /home/runner/_work/_tool""], ""volumeMounts"": [{""name"": ""<volume-name>"", ""mountPath"": ""/home/runner/_work/_tool""}]}]}}}}'
",0
440,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Using workflow commands to access toolkit functions - Example: Creating an annotation for an error,"The actions/toolkit includes a number of functions that can be executed as workflow commands. Use the :: syntax to run the workflow commands within your YAML file; these commands are then sent to the runner over stdout . For example, instead of using code to create an error annotation, as below: You can use the error command in your workflow to create the same error annotation:","- name: Create annotation for build error
        run: Write-Output ""::error file=app.js,line=1::Missing semicolon""","jobs:
  create-error-annotation:
    runs-on: ubuntu-latest
    steps:
      - name: Create error annotation
        run: echo ""::error file=app.js,line=10,col=15::Syntax error""
",0
441,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Grouping log lines - Example: Grouping log lines,"Creates an expandable group in the log. To create a group, use the group command and specify a title . Anything you print to the log between the group and endgroup commands is nested inside an expandable entry in the log.","jobs:
  powershell-example:
    runs-on: windows-latest
    steps:
      - name: Group of log lines
        run: |
            Write-Output ""::group::My title""
            Write-Output ""Inside group""
            Write-Output ""::endgroup::""","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Group log lines
        run: |
          echo ""::group::My Log Group""
          echo ""This is inside the group""
          echo ""Another line inside the group""
          echo ""::endgroup::""
",0
442,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking an environment variable,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. When you print the variable MY_NAME or the value ""Mona The Octocat"" in the log, you'll see ""***"" instead of ""Mona The Octocat"" .","jobs:
  powershell-example:
    runs-on: windows-latest
    env:
      MY_NAME: ""Mona The Octocat""
    steps:
      - name: powershell-version
        run: Write-Output ""::add-mask::$env:MY_NAME""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Mask environment variable
        run: |
          echo ""::add-mask::$MY_NAME""
          echo ""My name is $MY_NAME""
        env:
          MY_NAME: ""Mona The Octocat""
",0
443,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking a generated output within a single job,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you do not need to pass your secret from one job to another job, you can:","on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        shell: pwsh
        run: |
          Set-Variable -Name TheSecret -Value (Get-Random)
          Write-Output ""::add-mask::$TheSecret""
          ""secret-number=$TheSecret"" >> $env:GITHUB_OUTPUT
      - name: Use that secret output (protected by a mask)
        shell: pwsh
        run: |
          Write-Output ""the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Generate secret
        id: generate_secret
        run: echo ""SECRET_VALUE=super_secret_value"" >> $GITHUB_ENV

      - name: Mask secret
        run: echo ""::add-mask::$SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}

      - name: Use secret
        run: echo ""The secret is $SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}
",0
444,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking and passing a secret between jobs or workflows - Workflow,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you want to pass a masked secret between jobs or workflows, you should store the secret in a store and then retrieve it in the subsequent job or workflow. Note  This workflow uses an imaginary secret store,secret-store, which has imaginary commandsstore-secretandretrieve-secret.some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29is an imaginary action that installs thesecret-storeapplication and configures it to connect to aninstancewithcredentials. Note This workflow uses an imaginary secret store, secret-store , which has imaginary commands store-secret and retrieve-secret . some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29 is an imaginary action that installs the secret-store application and configures it to connect to an instance with credentials .","on: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      shell: pwsh
      run: |
        Set-Variable -Name Generated_Secret -Value (Get-Random)
        Write-Output ""::add-mask::$Generated_Secret""
        Set-Variable -Name Secret_Handle -Value (Store-Secret ""$Generated_Secret"")
        ""handle=$Secret_Handle"" >> $env:GITHUB_OUTPUT
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: pwsh
      run: |
        Set-Variable -Name Secret_Handle -Value ""${{ needs.secret-generator.outputs.handle }}""
        Set-Variable -Name Retrieved_Secret -Value (Retrieve-Secret ""$Secret_Handle"")
        echo ""::add-mask::$Retrieved_Secret""
        echo ""We retrieved our masked secret: $Retrieved_Secret""","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Store secret
        run: echo ""my-secret-value"" | store-secret my-secret-key
      - name: Mask secret
        run: echo ""::add-mask::my-secret-value""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Retrieve secret
        run: retrieve-secret my-secret-key
",0
445,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Stopping and starting workflow commands - Example: Stopping and starting workflow commands,"Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command. For example, you could stop logging to output an entire script that has comments. To stop the processing of workflow commands, pass a unique token to stop-commands . To resume processing workflow commands, pass the same token that you used to stop workflow commands. Warning  Make sure the token you're using is randomly generated and unique for each run. Warning Make sure the token you're using is randomly generated and unique for each run.","jobs:
  workflow-command-job:
    runs-on: windows-latest
    steps:
      - name: Disable workflow commands
        run: |
          Write-Output '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          $stopMarker = New-Guid
          Write-Output ""::stop-commands::$stopMarker""
          Write-Output '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          Write-Output ""::$stopMarker::""
          Write-Output '::warning:: This is a warning again, because stop-commands has been turned off.'","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Stop workflow commands
        run: echo ""::stop-commands::${{ secrets.UNIQUE_TOKEN }}""

      - name: Log script
        run: |
          echo ""This is a script with comments""
          echo ""# This is a comment""
          echo ""echo Hello World""

      - name: Start workflow commands
        run: echo ""::${{ secrets.UNIQUE_TOKEN }}::""
",0
446,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how:","name: Example Workflow for Environment Files

on: push

jobs:
  set_and_use_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_ENV_VAR=myValue"" >> $GITHUB_ENV

      - name: Use environment variable
        run: |
          echo ""The value of MY_ENV_VAR is $MY_ENV_VAR""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variable
        run: echo ""MY_VAR=HelloWorld"" >> $GITHUB_ENV

      - name: Use environment variable
        run: echo $MY_VAR
",0
447,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how: Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names:","steps:
  - name: Store build timestamp
    run: echo ""BUILD_TIME=$(date +'%T')"" >> $GITHUB_ENV

  - name: Deploy using stored timestamp
    run: echo ""Deploying at $BUILD_TIME""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variables
        run: echo ""BUILD_TIMESTAMP=$(date +%Y%m%d%H%M%S)"" >> $GITHUB_ENV

      - name: Print environment variables
        run: echo ""Build timestamp is $BUILD_TIMESTAMP""
",0
448,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how: Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names: Note  PowerShell versions 5.1 and below (shell: powershell) do not use UTF-8 by default, so you must specify the UTF-8 encoding. For example: PowerShell Core versions 6 and higher (shell: pwsh) use UTF-8 by default. For example: Note PowerShell versions 5.1 and below ( shell: powershell ) do not use UTF-8 by default, so you must specify the UTF-8 encoding. For example:","jobs:
  legacy-powershell-example:
    runs-on: windows-latest
    steps:
      - shell: powershell
        run: |
          ""mypath"" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variable
        run: echo ""BUILD_TIMESTAMP=$(date)"" >> $GITHUB_ENV

      - name: Set commit SHA
        run: echo ""COMMIT_SHA=${{ github.sha }}"" >> $GITHUB_ENV

      - name: Set artifact name
        run: echo ""ARTIFACT_NAME=my-artifact"" >> $GITHUB_ENV

      - name: Display environment variables
        run: |
          echo ""Build Timestamp: $BUILD_TIMESTAMP""
          echo ""Commit SHA: $COMMIT_SHA""
          echo ""Artifact Name: $ARTIFACT_NAME""
",0
449,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how: Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names: Note  PowerShell versions 5.1 and below (shell: powershell) do not use UTF-8 by default, so you must specify the UTF-8 encoding. For example: PowerShell Core versions 6 and higher (shell: pwsh) use UTF-8 by default. For example: Note PowerShell versions 5.1 and below ( shell: powershell ) do not use UTF-8 by default, so you must specify the UTF-8 encoding. For example: PowerShell Core versions 6 and higher ( shell: pwsh ) use UTF-8 by default. For example:","jobs:
  powershell-core-example:
    runs-on: windows-latest
    steps:
      - shell: pwsh
        run: |
          ""mypath"" >> $env:GITHUB_PATH","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variable
        run: echo ""BUILD_TIMESTAMP=$(date)"" >> $GITHUB_ENV

      - name: Set commit SHA
        run: echo ""COMMIT_SHA=${{ github.sha }}"" >> $GITHUB_ENV

      - name: Set artifact name
        run: echo ""ARTIFACT_NAME=my-artifact"" >> $GITHUB_ENV

      - name: Display environment variables
        run: |
          echo ""Build Timestamp: $BUILD_TIMESTAMP""
          echo ""Commit SHA: $COMMIT_SHA""
          echo ""Artifact Name: $ARTIFACT_NAME""
",0
450,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Setting an environment variable - Example of writing an environment variable to GITHUB_ENV,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Using PowerShell version 6 and higher: Using PowerShell version 5.1 and below: Using PowerShell version 6 and higher: Using PowerShell version 5.1 and below: You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable.","steps:
  - name: Set the value
    id: step_one
    run: |
      ""action_state=yellow"" >> $env:GITHUB_ENV
  - name: Use the value
    id: step_two
    run: |
      Write-Output ""$env:action_state"" # This will output 'yellow'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_VARIABLE=some_value"" >> $GITHUB_ENV
",0
451,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Setting an environment variable - Multiline strings - Example of a multiline string,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Using PowerShell version 6 and higher: Using PowerShell version 5.1 and below: Using PowerShell version 6 and higher: Using PowerShell version 5.1 and below: You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable. For multiline strings, you may use a delimiter with the following syntax. Warning  Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. Warning Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. This example uses EOF as the delimiter, and sets the JSON_RESPONSE environment variable to the value of the curl response.","steps:
  - name: Set the value in pwsh
    id: step_one
    run: |
      $EOF = (New-Guid).Guid
      ""JSON_RESPONSE<<$EOF"" >> $env:GITHUB_ENV
      (Invoke-WebRequest -Uri ""https://example.com"").Content >> $env:GITHUB_ENV
      ""$EOF"" >> $env:GITHUB_ENV
    shell: pwsh","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set JSON_RESPONSE environment variable
        run: |
          echo ""JSON_RESPONSE<<EOF"" >> $GITHUB_ENV
          curl -s http://example.com/api/response
          EOF
",0
452,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Setting an output parameter - Example of setting an output parameter,Sets a step's output parameter. Note that the step will need an id to be defined to later retrieve the output value. You can set multi-line output values with the same technique used in the Multiline strings section to define multi-line environment variables. This example demonstrates how to set the SELECTED_COLOR output parameter and later retrieve it:,"- name: Set color
        id: color-selector
        run: |
            ""SELECTED_COLOR=green"" >> $env:GITHUB_OUTPUT
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: Write-Output ""The selected color is $env:SELECTED_COLOR""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - id: set-output
        run: echo ""SELECTED_COLOR=blue"" >> $GITHUB_ENV

      - run: echo ""The selected color is ${{ steps.set-output.outputs.SELECTED_COLOR }}""
",0
453,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Adding a job summary - Multiline Markdown content - Example of multiline Markdown content,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. For multiline Markdown content, you can use >> to continuously append content for the current step. With every append operation, a newline character is automatically added.","- name: Generate list using Markdown
  run: |
    ""This is the lead in sentence for the list"" >> $env:GITHUB_STEP_SUMMARY
    """" >> $env:GITHUB_STEP_SUMMARY # this is a blank line
    ""- Lets add a bullet point"" >> $env:GITHUB_STEP_SUMMARY
    ""- Lets add a second bullet point"" >> $env:GITHUB_STEP_SUMMARY
    ""- How about a third one?"" >> $env:GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: |
          echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY
          echo ""This is a multiline"" >> $GITHUB_STEP_SUMMARY
          echo ""Markdown content"" >> $GITHUB_STEP_SUMMARY
",0
454,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Adding a job summary - Overwriting job summaries - Example of overwriting job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To clear all content for the current step, you can use > to overwrite any previously added content in Bash, or remove -Append in PowerShell","- name: Overwrite Markdown
  run: |
    ""Adding some Markdown content"" >> $env:GITHUB_STEP_SUMMARY
    ""There was an error, we need to clear the previous Markdown with some new content."" >> $env:GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" > $GITHUB_STEP_SUMMARY
      - name: Overwrite job summary
        run: echo ""## Overwritten Job Summary"" > $GITHUB_STEP_SUMMARY
",0
455,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=powershell,Workflow commands for GitHub Actions - Adding a job summary - Removing job summaries - Example of removing job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To completely remove a summary for the current step, the file that GITHUB_STEP_SUMMARY references can be deleted.","- name: Delete all summary content
  run: |
    ""Adding Markdown content that we want to remove before the step ends"" >> $env:GITHUB_STEP_SUMMARY
    Remove-Item $env:GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY

      - name: Remove job summary
        run: rm $GITHUB_STEP_SUMMARY
",0
456,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-nodejs-to-azure-app-service,Deploying Node.js to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build, test, and deploy the Node.js project to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If the path to your project is not the repository root, change AZURE_WEBAPP_PACKAGE_PATH to your project path. If you use a version of Node.js other than 10.x , change NODE_VERSION to the version that you use. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

on:
  push:
    branches:
      - main

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name
  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root
  NODE_VERSION: '14.x'                # set this to the node version to use

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: npm install, build, and test
      run: |
        npm install
        npm run build --if-present
        npm run test --if-present
    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: .

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app

    - name: 'Deploy to Azure WebApp'
      id: deploy-to-webapp
      uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}","name: Node.js CI/CD

on:
  push:
    branches:
      - main

env:
  AZURE_WEBAPP_NAME: your-webapp-name
  AZURE_WEBAPP_PACKAGE_PATH: .
  NODE_VERSION: 14.x

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install dependencies
      run: npm install

    - name: Run tests
      run: npm test

    - name: Build project
      run: npm run build

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
",0
457,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/using-conditions-to-control-job-execution,Using conditions to control job execution - Overview,"Note  A job that is skipped will report its status as ""Success"". It will not prevent a pull request from merging, even if it is a required check. Note A job that is skipped will report its status as ""Success"". It will not prevent a pull request from merging, even if it is a required check. You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . Note  Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied. The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","jobs:
  example_job:
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
458,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/using-conditions-to-control-job-execution,Using conditions to control job execution - Overview - Example: Only run job for specific repository,"Note  A job that is skipped will report its status as ""Success"". It will not prevent a pull request from merging, even if it is a required check. Note A job that is skipped will report its status as ""Success"". It will not prevent a pull request from merging, even if it is a required check. You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . Note  Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied. The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . This example uses if to control when the production-deploy job can run. It will only run if the repository is named octo-repo-prod and is within the octo-org organization. Otherwise, the job will be marked as skipped .","name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats","jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
459,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform,Configuring OpenID Connect in Google Cloud Platform - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
460,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform,Configuring OpenID Connect in Google Cloud Platform - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
",0
461,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform,Configuring OpenID Connect in Google Cloud Platform - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The google-github-actions/auth action receives a JWT from the GitHub OIDC provider, and then requests an access token from GCP. For more information, see the GCP documentation . This example has a job called Get_OIDC_ID_token that uses actions to request a list of services from GCP. This action exchanges a GitHub OIDC token for a Google Cloud access token, using Workload Identity Federation .","name: List services in GCP
on:
  pull_request:
    branches:
      - main

permissions:
  id-token: write

jobs:
  Get_OIDC_ID_token:
    runs-on: ubuntu-latest
    steps:
    - id: 'auth'
      name: 'Authenticate to GCP'
      uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0'
      with:
          create_credentials_file: 'true'
          workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER'
          service_account: 'SERVICE-ACCOUNT'
    - id: 'gcloud'
      name: 'gcloud'
      run: |-
        gcloud auth login --brief --cred-file=""${{ steps.auth.outputs.credentials_file_path }}""
        gcloud services list","jobs:
  Get_OIDC_ID_token:
    runs-on: ubuntu-latest
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          token_format: access_token
          workload_identity_provider: 'projects/YOUR_PROJECT_NUMBER/locations/global/workloadIdentityPools/YOUR_POOL_ID/providers/YOUR_PROVIDER_ID'
          service_account: 'YOUR_SERVICE_ACCOUNT_EMAIL'
      - name: List GCP services
        run: gcloud services list
",0
462,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Adding an action to your workflow - Adding an action from the same repository,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in the same repository where your workflow file uses the action, you can reference the action with either the  {owner}/{repo}@{ref} or ./path/to/dir syntax in your workflow file. Example repository file structure: The path is relative ( ./ ) to the default working directory ( github.workspace , $GITHUB_WORKSPACE ). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated. Example workflow file:","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run local action
        uses: ./path/to/dir
",0
463,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Adding an action to your workflow - Adding an action from a different repository,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in a different repository than your workflow file, you can reference the action with the {owner}/{repo}@{ref} syntax in your workflow file. The action must be stored in a public repository.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/setup-node@v4","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run an action from another repository
        uses: owner/repo@ref
",0
464,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Adding an action to your workflow - Referencing a container on Docker Hub,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in a published Docker container image on Docker Hub, you must reference the action with the docker://{image}:{tag} syntax in your workflow file. To protect your code and data, we strongly recommend you verify the integrity of the Docker container image from Docker Hub before using it in your workflow.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run Docker container
        uses: docker://{image}:{tag}
",0
465,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using tags,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . Tags are useful for letting you decide when to switch between major and minor versions, but these are more ephemeral and can be moved or deleted by the maintainer. This example demonstrates how to target an action that's been tagged as v1.0.1 :","steps:
  - uses: actions/javascript-action@v1.0.1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v1.0.1
",0
466,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using SHAs,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . If you need more reliable versioning, you should use the SHA value associated with the version of the action. SHAs are immutable and therefore more reliable than tags or branches. However, this approach means you will not automatically receive updates for an action, including important bug fixes and security updates. You must use a commit's full SHA value, and not an abbreviated value. When selecting a SHA, you should verify it is from the action's repository and not a repository fork. This example targets an action's SHA:","steps:
  - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@<full-SHA-value>
      - uses: actions/setup-node@<full-SHA-value>
        with:
          node-version: '14'
      - run: npm install
      - run: npm test
",0
467,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using branches,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . Specifying a target branch for the action means it will always run the version currently on that branch. This approach can create problems if an update to the branch includes breaking changes. This example targets a branch named @main :","steps:
  - uses: actions/javascript-action@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@main
",0
468,https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions,Using pre-written building blocks in your workflow - Using inputs and outputs with an action,"An action often accepts or requires inputs and generates outputs that you can use. For example, an action might require you to specify a path to a file, the name of a label, or other data it will use as part of the action processing. To see the inputs and outputs of an action, check the action.yml in the root directory of the repository. In this example action.yml , the inputs keyword defines a required input called file-path , and includes a default value that will be used if none is specified. The outputs keyword defines an output called results-file , which tells you where to locate the results.","name: ""Example""
description: ""Receives file and generates output""
inputs:
  file-path: # id of input
    description: ""Path to test script""
    required: true
    default: ""test-file.js""
outputs:
  results-file: # id of output
    description: ""Path to results file""","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run custom action
        uses: ./path/to/action
        with:
          file-path: './input/file.txt'
      - name: Use action output
        run: echo ""Results file: ${{ steps.run_custom_action.outputs.results-file }}""
",0
469,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-jenkins-with-github-actions-importer,Migrating from Jenkins with GitHub Actions Importer - Reference - Using optional arguments - --config-file-path - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Jenkins. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. When you use the --config-file-path option with the dry-run or migrate subcommands, GitHub Actions Importer matches the repository slug to the job represented by the --source-url option to select the pipeline. It uses the config-file-path to pull the specified source file. In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit. To audit a Jenkins instance using a config file, the config file must be in the following format, and each repository_slug value must be unique:","source_files:
  - repository_slug: pipeline-name
    path: path/to/Jenkinsfile
  - repository_slug: multi-branch-pipeline-name
    branches:
      - branch: main
        path: path/to/Jenkinsfile
      - branch: node
        path: path/to/Jenkinsfile","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer audit
        run: |
          gh actions-importer audit --config-file-path path/to/config-file.yml
",0
470,https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization,Creating workflow templates for your organization - Creating a workflow template,"Workflow templates can be created by users with write access to the organization's public  .github repository. These can then be used by organization members who have permission to create workflows. Workflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see the GitHub Enterprise Cloud documentation . Note  To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, seeReusing workflows. Note To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, see Reusing workflows . This procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow. If it doesn't already exist, create a new public repository named .github in your organization. Create a directory named workflow-templates . Create your new workflow file inside the workflow-templates directory. If you need to refer to a repository's default branch, you can use the $default-branch placeholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch. For example, this file named octo-organization-ci.yml demonstrates a basic workflow.","name: Octo Organization CI

on:
  push:
    branches: [ $default-branch ]
  pull_request:
    branches: [ $default-branch ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Run a one-line script
        run: echo Hello from Octo Organization","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm test
",0
471,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/using-actions-runner-controller-runners-in-a-workflow,Using Actions Runner Controller runners in a workflow - About using ARC runners in a workflow file,"To assign jobs to run on a runner scale set, you can specify the name of the scale set as the value for the runs-on key in your GitHub Actions workflow file. For example, the following configuration for a runner scale set has the INSTALLATION_NAME value set to arc-runner-set . To use this configuration in a workflow, set the value of the runs-on key in your workflow to arc-runner-set , similar to the following example.","jobs:
  job_name:
    runs-on: arc-runner-set","jobs:
  example-job:
    runs-on: arc-runner-set
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, ARC runner!""
",0
472,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-gradle,Publishing Java packages with Gradle - Publishing packages to the Maven Central Repository,"Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the release event triggers with type created . The workflow publishes the package to the Maven Central Repository if CI tests pass. For more information on the release event, see Events that trigger workflows . You can define a new Maven repository in the publishing block of your build.gradle file that points to your package repository. For example, if you were deploying to the Maven Central Repository through the OSSRH hosting project, your build.gradle could specify a repository with the name ""OSSRH"" . With this configuration, you can create a workflow that publishes your package to the Maven Central Repository by running the gradle publish command. In the deploy step, youll need to set environment variables for the username and password or token that you use to authenticate to the Maven repository. For more information, see Using secrets in GitHub Actions .","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Publish package to the Maven Central Repository
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

      - name: Publish package
        run: ./gradlew publish
        env:
          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}","on:
  release:
    types: [created]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up JDK
      uses: actions/setup-java@v2
      with:
        distribution: 'adopt'
        java-version: '11'

    - name: Run tests
      run: ./gradlew test

    - name: Publish to Maven Central
      env:
        MAVEN_USERNAME: ${{ secrets.MAVEN_USERNAME }}
        MAVEN_PASSWORD: ${{ secrets.MAVEN_PASSWORD }}
      run: ./gradlew publish
",0
473,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-gradle,Publishing Java packages with Gradle - Publishing packages to GitHub Packages,"Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the release event triggers with type created . The workflow publishes the package to GitHub Packages if CI tests pass. For more information on the release event, see Events that trigger workflows . You can define a new Maven repository in the publishing block of your build.gradle that points to GitHub Packages. In that repository configuration, you can also take advantage of environment variables set in your CI workflow run. You can use the GITHUB_ACTOR environment variable as a username, and you can set the GITHUB_TOKEN environment variable with your GITHUB_TOKEN secret. The GITHUB_TOKEN secret is set to an access token for the repository each time a job in a workflow begins. You should set the permissions for this access token in the workflow file to grant read access for the contents permission and write access for the packages permission. For more information, see Automatic token authentication . For example, if your organization is named ""octocat"" and your repository is named ""hello-world"", then the GitHub Packages configuration in build.gradle would look similar to the below example. With this configuration, you can create a workflow that publishes your package to GitHub Packages by running the gradle publish command.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Publish package to GitHub Packages
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

      - name: Publish package
        run: ./gradlew publish
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}","permissions:
  contents: read
  packages: write
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'adopt'
        java-version: '11'
    - name: Build with Gradle
      run: ./gradlew build
    - name: Publish to GitHub Packages
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: ./gradlew publish
",0
474,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-gradle,Publishing Java packages with Gradle - Publishing packages to the Maven Central Repository and GitHub Packages,"You can publish your packages to both the Maven Central Repository and GitHub Packages by configuring each in your build.gradle file. Ensure your build.gradle file includes a repository for both your GitHub repository and your Maven Central Repository provider. For example, if you deploy to the Central Repository through the OSSRH hosting project, you might want to specify it in a distribution management repository with the name set to OSSRH . If you deploy to GitHub Packages, you might want to specify it in a distribution management repository with the name set to GitHubPackages . If your organization is named ""octocat"" and your repository is named ""hello-world"", then the configuration in build.gradle would look similar to the below example. With this configuration, you can create a workflow that publishes your package to both the Maven Central Repository and GitHub Packages by running the gradle publish command.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Publish package to the Maven Central Repository and GitHub Packages
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

      - name: Publish package
        run: ./gradlew publish
        env: 
          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'adopt'
        java-version: '11'
    - name: Cache Gradle packages
      uses: actions/cache@v2
      with:
        path: ~/.gradle/caches
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    - name: Publish to Maven Central and GitHub Packages
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
        OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
      run: ./gradlew publish
",0
475,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust,Building and testing Rust - Specifying a Rust version,"GitHub-hosted runners include a recent version of the Rust toolchain. You can use rustup to report on the version installed on a runner, override the version, and to install different toolchains. For more information, see The rustup book . This example shows steps you could use to setup your runner environment to use the nightly build of rust and to report the version.",#NAME?,"jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Install Rust nightly
      run: rustup toolchain install nightly
    - name: Use Rust nightly
      run: rustup default nightly
    - name: Report Rust version
      run: rustc --version
",0
476,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust,Building and testing Rust - Specifying a Rust version - Caching dependencies,"GitHub-hosted runners include a recent version of the Rust toolchain. You can use rustup to report on the version installed on a runner, override the version, and to install different toolchains. For more information, see The rustup book . This example shows steps you could use to setup your runner environment to use the nightly build of rust and to report the version. You can cache and restore dependencies using the Cache action. This example assumes that your repository contains a Cargo.lock file.","- name: Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
    - name: Cache cargo registry
      uses: actions/cache@v2
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-registry-
    - name: Cache cargo index
      uses: actions/cache@v2
      with:
        path: ~/.cargo/git
        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-index-
    - name: Cache cargo build
      uses: actions/cache@v2
      with:
        path: target
        key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-build-
    - name: Report Rust version
      run: rustc --version
    - name: Build
      run: cargo build --verbose
    - name: Test
      run: cargo test --verbose
",0
477,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust,Building and testing Rust - Building and testing your code,You can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use cargo build and cargo test in a job:,"jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        BUILD_TARGET: [release] # refers to a cargo profile
    outputs:
      release_built: ${{ steps.set-output.outputs.release_built }}
    steps:
      - uses: actions/checkout@v4
      - name: Build binaries in ""${{ matrix.BUILD_TARGET }}"" mode
        run: cargo build --profile ${{ matrix.BUILD_TARGET }}
      - name: Run tests in ""${{ matrix.BUILD_TARGET }}"" mode
        run: cargo test --profile ${{ matrix.BUILD_TARGET }}","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Rust
        uses: actions/setup-rust@v1
      - name: Build
        run: cargo build
      - name: Test
        run: cargo test
",0
478,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust,Building and testing Rust - Publishing your package or library to crates.io,"Once you have setup your workflow to build and test your code, you can use a secret to login to crates.io and publish your package.","- name: Login into crates.io
        run: cargo login ${{ secrets.CRATES_IO }}
      - name: Build binaries in ""release"" mode
        run: cargo build -r
      - name: ""Package for crates.io""
        run: cargo package # publishes a package as a tarball
      - name: ""Publish to crates.io""
        run: cargo publish # publishes your crate as a library that can be added as a dependency","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Rust
        uses: actions/setup-rust@v1
      - name: Build
        run: cargo build --verbose
      - name: Test
        run: cargo test --verbose
      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: cargo publish
",0
479,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust,Building and testing Rust - Packaging workflow data as artifacts,"After a workflow completes, you can upload the resulting artifacts for analysis or to use in another workflow. You could add these example steps to the workflow to upload an application for use by another workflow.","- name: Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: <my-app>
          path: target/${{ matrix.BUILD_TARGET }}/<my-app>","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Build
        run: cargo build --release
      - name: Test
        run: cargo test
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: my-application
          path: target/release/
",0
480,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust,Building and testing Rust - Packaging workflow data as artifacts,"After a workflow completes, you can upload the resulting artifacts for analysis or to use in another workflow. You could add these example steps to the workflow to upload an application for use by another workflow. To use the uploaded artifact in a different job, ensure your workflows have the right permissions for the repository, see Automatic token authentication . You could use these example steps to download the app created in the previous workflow and publish it on GitHub.","- uses: actions/checkout@v4
      - name: Download release artifact
        uses: actions/download-artifact@v4
        with:
          name: <my-app>
          path: ./<my-app>
      - name: Publish built binary to GitHub releases
      - run: |
          gh release create --generate-notes ./<my-app>/<my-project>#<my-app>","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Rust
        uses: actions/setup-rust@v1
      - name: Build
        run: cargo build --release
      - name: Test
        run: cargo test
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: my-app
          path: target/release/

  publish:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v2
      - name: Download artifact
        uses: actions/download-artifact@v2
        with:
          name: my-app
      - name: Publish
        run: echo ""Publishing app...""
",0
481,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions?learn=getting_started&learnProduct=actions,Security hardening for GitHub Actions - Understanding the risk of script injections - Example of a script injection attack,"When creating workflows, custom actions , and composite actions , you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner. Attackers can add their own malicious content to the github context , which should be treated as potentially untrusted input. These contexts typically end with body , default_branch , email , head_ref , label , message , name , page_name , ref , and title . For example: github.event.issue.title , or github.event.pull_request.body . You should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions . In addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, zzz"";echo${IFS}""hello"";# would be a valid branch name and would be a possible attack vector for a target repository. The following sections explain how you can help mitigate the risk of script injection. A script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:","- name: Check PR title
        run: |
          title=""${{ github.event.pull_request.title }}""
          if [[ $title =~ ^octocat ]]; then
          echo ""PR title starts with 'octocat'""
          exit 0
          else
          echo ""PR title did not start with 'octocat'""
          exit 1
          fi","jobs:
  check-pr-title:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Validate PR title
        run: |
          if [[ ""${{ github.event.pull_request.title }}"" =~ [^a-zA-Z0-9\ ] ]]; then
            echo ""Invalid PR title""
            exit 1
          fi
",0
482,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions?learn=getting_started&learnProduct=actions,Security hardening for GitHub Actions - Good practices for mitigating script injection attacks - Using an action instead of an inline script (recommended),"There are a number of different approaches available to help you mitigate the risk of script injection: The recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:","uses: fakeaction/checktitle@v3
with:
    title: ${{ github.event.pull_request.title }}","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: your-username/your-action-repo@v1
        with:
          context-value: ${{ github.event.some_context_value }}
",0
483,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions?learn=getting_started&learnProduct=actions,Security hardening for GitHub Actions - Good practices for mitigating script injection attacks - Using an intermediate environment variable,"There are a number of different approaches available to help you mitigate the risk of script injection: For inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable. The following example uses Bash to process the github.event.pull_request.title value as an environment variable:","- name: Check PR title
        env:
          TITLE: ${{ github.event.pull_request.title }}
        run: |
          if [[ ""$TITLE"" =~ ^octocat ]]; then
          echo ""PR title starts with 'octocat'""
          exit 0
          else
          echo ""PR title did not start with 'octocat'""
          exit 1
          fi","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - name: Set up intermediate environment variable
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          echo ""Processing pull request title: $PR_TITLE""
",0
484,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions?learn=getting_started&learnProduct=actions,Security hardening for GitHub Actions - Potential impact of a compromised runner - Accessing secrets,"These sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner. Note  GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library. Note GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library. Workflows triggered from a forked repository using the pull_request event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as issue_comment , issues , push and pull_request from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's GITHUB_TOKEN . If the secret or token is set to an environment variable, it can be directly accessed through the environment using printenv . If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible. For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:","uses: fakeaction/publish@v3
with:
    key: ${{ secrets.PUBLISH_KEY }}","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run security checks
        run: |
          echo ""Running security checks""
          # Example command to list environment variables
          printenv
",0
485,https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners,About GitHub-hosted runners - Using a GitHub-hosted runner,"To use a GitHub-hosted runner, create a job and use runs-on to specify the type of runner that will process the job, such as ubuntu-latest , windows-latest , or macos-latest . For the full list of runner types, see About GitHub-hosted runners . If you have repo: write access to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, see Viewing available runners for a repository . When the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned. The following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners. The following example workflow has two jobs, named Run-npm-on-Ubuntu and Run-PSScriptAnalyzer-on-Windows . When this workflow is triggered, GitHub provisions a new virtual machine for each job.","name: Run commands on different operating systems
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  Run-npm-on-Ubuntu:
    name: Run npm on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm help

  Run-PSScriptAnalyzer-on-Windows:
    name: Run PSScriptAnalyzer on Windows
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install PSScriptAnalyzer module
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module PSScriptAnalyzer -ErrorAction Stop
      - name: Get list of rules
        shell: pwsh
        run: |
          Get-ScriptAnalyzerRule","jobs:
  Run-npm-on-Ubuntu:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm test

  Run-PSScriptAnalyzer-on-Windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install PSScriptAnalyzer
        run: Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
      - name: Run PSScriptAnalyzer
        run: Invoke-ScriptAnalyzer -Path ./scripts
",0
486,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Specifying a Python version - Using multiple Python versions,"To use a pre-installed version of Python or PyPy on a GitHub-hosted runner, use the setup-python action. This action finds a specific version of Python or PyPy from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. If a specific version of Python is not pre-installed in the tools cache, the setup-python action will download and set up the appropriate version from the python-versions repository. Using the setup-python action is the recommended way of using Python with GitHub Actions because it ensures consistent behavior across different runners and different versions of Python. If you are using a self-hosted runner, you must install Python and add it to PATH . For more information, see the setup-python action . The table below describes the locations for the tools cache in each GitHub-hosted runner. UbuntuMacWindowsTool Cache Directory/opt/hostedtoolcache/*/Users/runner/hostedtoolcache/*C:\hostedtoolcache\windows\*Python Tool Cache/opt/hostedtoolcache/Python/*/Users/runner/hostedtoolcache/Python/*C:\hostedtoolcache\windows\Python\*PyPy Tool Cache/opt/hostedtoolcache/PyPy/*/Users/runner/hostedtoolcache/PyPy/*C:\hostedtoolcache\windows\PyPy\* If you are using a self-hosted runner, you can configure the runner to use the setup-python action to manage your dependencies. For more information, see using setup-python with a self-hosted runner in the setup-python README. GitHub supports semantic versioning syntax. For more information, see Using semantic versioning and the Semantic versioning specification . The following example uses a matrix for the job to set up multiple Python versions. For more information, see Running variations of jobs in a workflow .","name: Python package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [""pypy3.10"", ""3.9"", ""3.10"", ""3.11"", ""3.12"", ""3.13""]

    steps:
      - uses: actions/checkout@v4
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      # You can test your matrix by printing the current Python version
      - name: Display Python version
        run: python -c ""import sys; print(sys.version)""","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.7, 3.8, 3.9]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Test with pytest
      run: |
        pytest
",0
487,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Specifying a Python version - Using a specific Python version,"To use a pre-installed version of Python or PyPy on a GitHub-hosted runner, use the setup-python action. This action finds a specific version of Python or PyPy from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. If a specific version of Python is not pre-installed in the tools cache, the setup-python action will download and set up the appropriate version from the python-versions repository. Using the setup-python action is the recommended way of using Python with GitHub Actions because it ensures consistent behavior across different runners and different versions of Python. If you are using a self-hosted runner, you must install Python and add it to PATH . For more information, see the setup-python action . The table below describes the locations for the tools cache in each GitHub-hosted runner. UbuntuMacWindowsTool Cache Directory/opt/hostedtoolcache/*/Users/runner/hostedtoolcache/*C:\hostedtoolcache\windows\*Python Tool Cache/opt/hostedtoolcache/Python/*/Users/runner/hostedtoolcache/Python/*C:\hostedtoolcache\windows\Python\*PyPy Tool Cache/opt/hostedtoolcache/PyPy/*/Users/runner/hostedtoolcache/PyPy/*C:\hostedtoolcache\windows\PyPy\* If you are using a self-hosted runner, you can configure the runner to use the setup-python action to manage your dependencies. For more information, see using setup-python with a self-hosted runner in the setup-python README. GitHub supports semantic versioning syntax. For more information, see Using semantic versioning and the Semantic versioning specification . You can configure a specific version of Python. For example, 3.12. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of Python 3.","name: Python package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        # This is the version of the action for setting up Python, not the Python version.
        uses: actions/setup-python@v5
        with:
          # Semantic version range syntax or exact version of a Python version
          python-version: '3.x'
          # Optional - x64 or x86 architecture, defaults to x64
          architecture: 'x64'
      # You can test your matrix by printing the current Python version
      - name: Display Python version
        run: python -c ""import sys; print(sys.version)""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - run: python --version
",0
488,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Specifying a Python version - Excluding a version,"To use a pre-installed version of Python or PyPy on a GitHub-hosted runner, use the setup-python action. This action finds a specific version of Python or PyPy from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. If a specific version of Python is not pre-installed in the tools cache, the setup-python action will download and set up the appropriate version from the python-versions repository. Using the setup-python action is the recommended way of using Python with GitHub Actions because it ensures consistent behavior across different runners and different versions of Python. If you are using a self-hosted runner, you must install Python and add it to PATH . For more information, see the setup-python action . The table below describes the locations for the tools cache in each GitHub-hosted runner. UbuntuMacWindowsTool Cache Directory/opt/hostedtoolcache/*/Users/runner/hostedtoolcache/*C:\hostedtoolcache\windows\*Python Tool Cache/opt/hostedtoolcache/Python/*/Users/runner/hostedtoolcache/Python/*C:\hostedtoolcache\windows\Python\*PyPy Tool Cache/opt/hostedtoolcache/PyPy/*/Users/runner/hostedtoolcache/PyPy/*C:\hostedtoolcache\windows\PyPy\* If you are using a self-hosted runner, you can configure the runner to use the setup-python action to manage your dependencies. For more information, see using setup-python with a self-hosted runner in the setup-python README. GitHub supports semantic versioning syntax. For more information, see Using semantic versioning and the Semantic versioning specification . If you specify a version of Python that is not available, setup-python fails with an error such as: ##[error]Version 3.7 with arch x64 not found . The error message includes the available versions. You can also use the exclude keyword in your workflow if there is a configuration of Python that you do not wish to run. For more information, see Workflow syntax for GitHub Actions .","name: Python package

on: [push]

jobs:
  build:

    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: [""3.9"", ""3.11"", ""3.13"", ""pypy3.10""]
        exclude:
          - os: macos-latest
            python-version: ""3.11""
          - os: windows-latest
            python-version: ""3.11""","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.6, 3.7, 3.8, 3.9]
        exclude:
          - python-version: 3.7
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Test with pytest
        run: |
          pytest
",0
489,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Installing dependencies,"GitHub-hosted runners have the pip package manager installed. You can use pip to install dependencies from the PyPI package registry before building and testing your code. For example, the YAML below installs or upgrades the pip package installer and the setuptools and wheel packages. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows .","steps:
- uses: actions/checkout@v4
- name: Set up Python
  uses: actions/setup-python@v5
  with:
    python-version: '3.x'
- name: Install dependencies
  run: python -m pip install --upgrade pip setuptools wheel","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel
",0
490,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Installing dependencies - Requirements file,"GitHub-hosted runners have the pip package manager installed. You can use pip to install dependencies from the PyPI package registry before building and testing your code. For example, the YAML below installs or upgrades the pip package installer and the setuptools and wheel packages. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . After you update pip , a typical next step is to install dependencies from requirements.txt . For more information, see pip .","steps:
- uses: actions/checkout@v4
- name: Set up Python
  uses: actions/setup-python@v5
  with:
    python-version: '3.x'
- name: Install dependencies
  run: |
    python -m pip install --upgrade pip
    pip install -r requirements.txt","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel
          pip install -r requirements.txt
",0
491,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Installing dependencies - Caching Dependencies,"GitHub-hosted runners have the pip package manager installed. You can use pip to install dependencies from the PyPI package registry before building and testing your code. For example, the YAML below installs or upgrades the pip package installer and the setuptools and wheel packages. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-python action . The following example caches dependencies for pip.","steps:
- uses: actions/checkout@v4
- uses: actions/setup-python@v5
  with:
    python-version: '3.12'
    cache: 'pip'
- run: pip install -r requirements.txt
- run: pip test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-python@v2
      with:
        python-version: '3.x'
        cache: 'pip'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install setuptools wheel
    - name: Build and Test
      run: |
        # Add your build and test commands here
",0
492,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Testing your code - Testing with pytest and pytest-cov,"You can use the same commands that you use locally to build and test your code. This example installs or upgrades pytest and pytest-cov . Tests are then run and output in JUnit format while code coverage results are output in Cobertura. For more information, see JUnit and Cobertura .","steps:
- uses: actions/checkout@v4
- name: Set up Python
  uses: actions/setup-python@v5
  with:
    python-version: '3.x'
- name: Install dependencies
  run: |
    python -m pip install --upgrade pip
    pip install -r requirements.txt
- name: Test with pytest
  run: |
    pip install pytest pytest-cov
    pytest tests.py --doctest-modules --junitxml=junit/test-results.xml --cov=com --cov-report=xml --cov-report=html","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov
      - name: Run tests
        run: |
          pytest --junitxml=reports/junit.xml --cov=. --cov-report=xml:reports/cobertura.xml
",0
493,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Testing your code - Using Ruff to lint and/or format code,"You can use the same commands that you use locally to build and test your code. The following example installs or upgrades ruff and uses it to lint all files. For more information, see Ruff .","steps:
- uses: actions/checkout@v4
- name: Set up Python
  uses: actions/setup-python@v5
  with:
    python-version: '3.x'
- name: Install the code linting and formatting tool Ruff
  run: pipx install ruff
- name: Lint code with Ruff
  run: ruff check --output-format=github --target-version=py39
- name: Check code formatting with Ruff
  run: ruff format --diff --target-version=py39
  continue-on-error: true","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: python -m pip install --upgrade pip ruff
      - name: Lint with Ruff
        run: ruff .
",0
494,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Testing your code - Running tests with tox,"You can use the same commands that you use locally to build and test your code. With GitHub Actions, you can run tests with tox and spread the work across multiple jobs. You'll need to invoke tox using the -e py option to choose the version of Python in your PATH , rather than specifying a specific version. For more information, see tox .","name: Python package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python: [""3.9"", ""3.11"", ""3.13""]

    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}
      - name: Install tox and any other packages
        run: pip install tox
      - name: Run tox
        # Run tox using the version of Python in `PATH`
        run: tox -e py","jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: python -m pip install --upgrade pip && pip install tox
      - name: Run tests
        run: tox -e py
",0
495,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Packaging workflow data as artifacts,"You can upload artifacts to view after a workflow completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, see Storing and sharing data from a workflow . The following example demonstrates how you can use the upload-artifact action to archive test results from running pytest . For more information, see the upload-artifact action .","name: Python package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [""3.9"", ""3.10"", ""3.11"", ""3.12"", ""3.13""]

    steps:
      - uses: actions/checkout@v4
      - name: Setup Python # Set Python version
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      # Install pip and pytest
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest
      - name: Test with pytest
        run: pytest tests.py --doctest-modules --junitxml=junit/test-results-${{ matrix.python-version }}.xml
      - name: Upload pytest test results
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results-${{ matrix.python-version }}
          path: junit/test-results-${{ matrix.python-version }}.xml
        # Use always() to always run this step to publish test results when there are test failures
        if: ${{ always() }}","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest
    - name: Run tests
      run: pytest
    - name: Upload test results
      uses: actions/upload-artifact@v2
      with:
        name: test-results
        path: ./test-results
",0
496,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python,Building and testing Python - Publishing to PyPI,"You can configure your workflow to publish your Python package to PyPI once your CI tests pass. This section demonstrates how you can use GitHub Actions to upload your package to PyPI each time you publish a release. For more information, see Managing releases in a repository . The example workflow below uses Trusted Publishing to authenticate with PyPI, eliminating the need for a manually configured API token.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Upload Python Package

on:
  release:
    types: [published]

permissions:
  contents: read

jobs:
  release-build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ""3.x""

      - name: Build release distributions
        run: |
          # NOTE: put your own distribution build steps here.
          python -m pip install build
          python -m build

      - name: Upload distributions
        uses: actions/upload-artifact@v4
        with:
          name: release-dists
          path: dist/

  pypi-publish:
    runs-on: ubuntu-latest

    needs:
      - release-build

    permissions:
      # IMPORTANT: this permission is mandatory for trusted publishing
      id-token: write

    # Dedicated environments with protections for publishing are strongly recommended.
    environment:
      name: pypi
      # OPTIONAL: uncomment and update to include your PyPI project URL in the deployment status:
      # url: https://pypi.org/p/YOURPROJECT

    steps:
      - name: Retrieve release distributions
        uses: actions/download-artifact@v4
        with:
          name: release-dists
          path: dist/

      - name: Publish release distributions to PyPI
        uses: pypa/gh-action-pypi-publish@6f7e8d9c0b1a2c3d4e5f6a7b8c9d0e1f2a3b4c5d","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install setuptools wheel
    - name: Build package
      run: python setup.py sdist bdist_wheel
    - name: Test package
      run: python -m unittest discover
  publish:
    runs-on: ubuntu-latest
    needs: build
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    - name: Install Twine
      run: pip install twine
    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
      run: twine upload dist/*
",0
497,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-xamarin-applications,Building and testing Xamarin applications - Building Xamarin.iOS apps,The example below demonstrates how to change the default Xamarin SDK versions and build a Xamarin.iOS application.,"name: Build Xamarin.iOS app

on: [push]

jobs:
  build:

    runs-on: macos-latest

    steps:
    - uses: actions/checkout@v4
    - name: Set default Xamarin SDK versions
      run: |
        $VM_ASSETS/select-xamarin-sdk-v2.sh --mono=6.12 --ios=14.10

    - name: Set default Xcode 12.3
      run: |
        XCODE_ROOT=/Applications/Xcode_12.3.0.app
        echo ""MD_APPLE_SDK_ROOT=$XCODE_ROOT"" >> $GITHUB_ENV
        sudo xcode-select -s $XCODE_ROOT

    - name: Setup .NET Core SDK 5.0.x
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '5.0.x'

    - name: Install dependencies
      run: nuget restore <sln_file_path>

    - name: Build
      run: msbuild <csproj_file_path> /p:Configuration=Debug /p:Platform=iPhoneSimulator /t:Rebuild","jobs:
  build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Xamarin SDK
        run: |
          sudo $AGENT_HOMEDIRECTORY/scripts/select-xamarin-sdk.sh 6_12_0
      - name: Build Xamarin.iOS app
        run: |
          msbuild MyXamarinApp.iOS/MyXamarinApp.iOS.csproj /p:Configuration=Release /p:Platform=iPhone
",0
498,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-xamarin-applications,Building and testing Xamarin applications - Building Xamarin.Android apps,The example below demonstrates how to change default Xamarin SDK versions and build a Xamarin.Android application.,"name: Build Xamarin.Android app

on: [push]

jobs:
  build:

    runs-on: macos-latest

    steps:
    - uses: actions/checkout@v4
    - name: Set default Xamarin SDK versions
      run: |
        $VM_ASSETS/select-xamarin-sdk-v2.sh --mono=6.10 --android=10.2

    - name: Setup .NET Core SDK 5.0.x
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '5.0.x'

    - name: Install dependencies
      run: nuget restore <sln_file_path>

    - name: Build
      run: msbuild <csproj_file_path> /t:PackageForAndroid /p:Configuration=Debug","jobs:
  build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up JDK 11
        uses: actions/setup-java@v2
        with:
          java-version: '11'
      - name: Install Xamarin SDK
        run: |
          sudo $AGENT_HOMEDIRECTORY/scripts/select-xamarin-sdk.sh 6_12_0
      - name: Build Xamarin.Android app
        run: |
          msbuild /t:Restore
          msbuild /t:Build
",0
499,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - About contexts - Determining when to use contexts,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects. Contexts, objects, and properties will vary significantly under different workflow run conditions. For example, the matrix context is only populated for jobs in a matrix . You can access contexts using the expression syntax. For more information, see Evaluate expressions in workflows and actions . ${{ <context> }} Warning  When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions . As part of an expression, you can access context information using one of two syntaxes. In order to use property dereference syntax, the property name must start with a letter or _ and contain only alphanumeric characters, - , or _ . If you attempt to dereference a nonexistent property, it will evaluate to an empty string. GitHub Actions includes a collection of variables called contexts and a similar collection of variables called default variables . These variables are intended for use at different points in the workflow: The following example demonstrates how these different types of variables can be used together in a job:","name: CI
on: push
jobs:
  prod-check:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Deploying to production server on branch $GITHUB_REF""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Print context information
        run: echo ""Job ID: ${{ github.run_id }}""
      - name: Print matrix value
        if: ${{ matrix != null }}
        run: echo ""Matrix value: ${{ matrix.some_value }}""
",0
500,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - About contexts - Example: printing context information to the log,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects. Contexts, objects, and properties will vary significantly under different workflow run conditions. For example, the matrix context is only populated for jobs in a matrix . You can access contexts using the expression syntax. For more information, see Evaluate expressions in workflows and actions . ${{ <context> }} Warning  When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions . As part of an expression, you can access context information using one of two syntaxes. In order to use property dereference syntax, the property name must start with a letter or _ and contain only alphanumeric characters, - , or _ . If you attempt to dereference a nonexistent property, it will evaluate to an empty string. You can print the contents of contexts to the log for debugging. The toJSON function is required to pretty-print JSON objects to the log. Warning  When using the wholegithubcontext, be mindful that it includes sensitive information such asgithub.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context. When using the whole github context, be mindful that it includes sensitive information such as github.token . GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.","name: Context testing
on: push

jobs:
  dump_contexts_to_log:
    runs-on: ubuntu-latest
    steps:
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo ""$GITHUB_CONTEXT""
      - name: Dump job context
        env:
          JOB_CONTEXT: ${{ toJson(job) }}
        run: echo ""$JOB_CONTEXT""
      - name: Dump steps context
        env:
          STEPS_CONTEXT: ${{ toJson(steps) }}
        run: echo ""$STEPS_CONTEXT""
      - name: Dump runner context
        env:
          RUNNER_CONTEXT: ${{ toJson(runner) }}
        run: echo ""$RUNNER_CONTEXT""
      - name: Dump strategy context
        env:
          STRATEGY_CONTEXT: ${{ toJson(strategy) }}
        run: echo ""$STRATEGY_CONTEXT""
      - name: Dump matrix context
        env:
          MATRIX_CONTEXT: ${{ toJson(matrix) }}
        run: echo ""$MATRIX_CONTEXT""","jobs:
  print-context:
    runs-on: ubuntu-latest
    steps:
      - name: Print GitHub context
        run: echo ""${{ toJSON(github) }}""
      - name: Print job context
        run: echo ""${{ toJSON(job) }}""
      - name: Print runner context
        run: echo ""${{ toJSON(runner) }}""
      - name: Print steps context
        run: echo ""${{ toJSON(steps) }}""
      - name: Print strategy context
        run: echo ""${{ toJSON(strategy) }}""
      - name: Print matrix context
        run: echo ""${{ toJSON(matrix) }}""
",0
501,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - github context - Example usage of the github context,"The github context contains information about the workflow run and the event that triggered the run. You can also read most of the github context data in environment variables. For more information about environment variables, see Store information in variables . Warning  When using the wholegithubcontext, be mindful that it includes sensitive information such asgithub.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When using the whole github context, be mindful that it includes sensitive information such as github.token . GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions . This example workflow uses the github.event_name context to run a job only if the workflow run was triggered by the pull_request event.","name: Run CI
on: [push, pull_request]

jobs:
  normal_ci:
    runs-on: ubuntu-latest
    steps:
      - name: Run normal CI
        run: echo ""Running normal CI""

  pull_request_ci:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - name: Run PR CI
        run: echo ""Running PR only CI""","jobs:
  example:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Print event name
        run: echo ""Event name is ${{ github.event_name }}""
",0
502,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - env context - Example usage of the env context,"The env context contains variables that have been set in a workflow, job, or step. It does not contain variables inherited by the runner process. For more information about setting variables in your workflow, see Workflow syntax for GitHub Actions . You can retrieve the values of variables stored in env context and use these values in your workflow file. You can use the env context in any key in a workflow step except for the id and uses keys. For more information on the step syntax, see Workflow syntax for GitHub Actions . If you want to use the value of a variable inside a runner, use the runner operating system's normal method for reading environment variables. This example workflow shows variables being set in the env context at the workflow, job, and step levels. The ${{ env.VARIABLE-NAME }} syntax is then used to retrieve variable values within individual steps in the workflow. When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.","name: Hi Mascot
on: push
env:
  mascot: Mona
  super_duper_var: totally_awesome

jobs:
  windows_job:
    runs-on: windows-latest
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Mona
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Octocat
        env:
          mascot: Octocat
  linux_job:
    runs-on: ubuntu-latest
    env:
      mascot: Tux
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Tux","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      WORKFLOW_VAR: workflow_value
    steps:
      - name: Set job-level environment variable
        run: echo ""JOB_VAR=job_value"" >> $GITHUB_ENV
      - name: Set step-level environment variable
        env:
          STEP_VAR: step_value
        run: |
          echo ""Workflow variable: ${{ env.WORKFLOW_VAR }}""
          echo ""Job variable: ${{ env.JOB_VAR }}""
          echo ""Step variable: ${{ env.STEP_VAR }}""
",0
503,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - vars context - Example usage of the vars context,"Note  Configuration variables for GitHub Actions are in public preview and subject to change. Note Configuration variables for GitHub Actions are in public preview and subject to change. The vars context contains custom configuration variables set at the organization, repository, and environment levels. For more information about defining configuration variables for use in multiple workflows, see Store information in variables . This example workflow shows how configuration variables set at the repository, environment, or organization levels are automatically available using the vars context. Note  Configuration variables at the environment level are automatically available after their environment is declared by the runner. Configuration variables at the environment level are automatically available after their environment is declared by the runner. If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string. The following example shows using configuration variables with the vars context across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels.","on:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo ""repository variable : $REPOSITORY_VAR""
        echo ""organization variable : $ORGANIZATION_VAR""
        echo ""overridden variable : $OVERRIDE_VAR""
        echo ""variable from shell environment : $env_var""
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Print configuration variables
        run: |
          echo ""Repository variable: ${{ vars.repository_variable }}""
          echo ""Organization variable: ${{ vars.organization_variable }}""
          echo ""Environment variable: ${{ vars.environment_variable }}""
",0
504,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - job context - Example usage of the job context,"The job context contains information about the currently running job. This example workflow configures a PostgreSQL service container, and automatically maps port 5432 in the service container to a randomly chosen available port on the host. The job context is used to access the number of the port that was assigned on the host.","name: PostgreSQL Service Example
on: push
jobs:
  postgres-job:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
        ports:
          # Maps TCP port 5432 in the service container to a randomly chosen available port on the host.
          - 5432

    steps:
      - run: pg_isready -h localhost -p ${{ job.services.postgres.ports[5432] }}
      - run: echo ""Run tests against Postgres""","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432/tcp
    steps:
      - name: Check assigned port
        run: echo ""PostgreSQL is running on port ${{ job.services.postgres.ports['5432'] }}""
",0
505,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - jobs context - Example usage of the jobs context,"The jobs context is only available in reusable workflows, and can only be used to set outputs for a reusable workflow. For more information, see Reusing workflows . This example reusable workflow uses the jobs context to set outputs for the reusable workflow. Note how the outputs flow up from the steps, to the job, then to the workflow_call trigger. For more information, see Reusing workflows .","name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: ""The first output string""
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: ""The second output string""
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo ""firstword=hello"" >> $GITHUB_OUTPUT
      - id: step2
        run: echo ""secondword=world"" >> $GITHUB_OUTPUT","jobs:
  example_job:
    runs-on: ubuntu-latest
    outputs:
      example_output: ${{ steps.example_step.outputs.step_output }}
    steps:
      - id: example_step
        run: echo ""step_output=Hello World"" >> $GITHUB_ENV

on:
  workflow_call:
    outputs:
      example_output:
        description: 'An example output from the reusable workflow'
        value: ${{ jobs.example_job.outputs.example_output }}
",0
506,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - steps context - Example usage of the steps context,"The steps context contains information about the steps in the current job that have an id specified and have already run. This example workflow generates a random number as an output in one step, and a later step uses the steps context to read the value of that output.","name: Generate random failure
on: push
jobs:
  randomly-failing-job:
    runs-on: ubuntu-latest
    steps:
      - name: Generate 0 or 1
        id: generate_number
        run: echo ""random_number=$(($RANDOM % 2))"" >> $GITHUB_OUTPUT
      - name: Pass or fail
        run: |
          if [[ ${{ steps.generate_number.outputs.random_number }} == 0 ]]; then exit 0; else exit 1; fi","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - id: generate_random
        run: echo ""::set-output name=random_number::$(shuf -i 1-100 -n 1)""
      - run: echo ""The random number is ${{ steps.generate_random.outputs.random_number }}""
",0
507,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - runner context - Example usage of the runner context,"The runner context contains information about the runner that is executing the current job. This example workflow uses the runner context to set the path to the temporary directory to write logs, and if the workflow fails, it uploads those logs as artifact.","name: Build
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build with logs
        run: |
          mkdir ${{ runner.temp }}/build_logs
          echo ""Logs from building"" > ${{ runner.temp }}/build_logs/build.logs
          exit 1
      - name: Upload logs on fail
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: Build failure logs
          path: ${{ runner.temp }}/build_logs","jobs:
  log-job:
    runs-on: ubuntu-latest
    steps:
      - name: Create log directory
        run: mkdir -p ${{ runner.temp }}/logs

      - name: Write log
        run: echo ""Log entry"" > ${{ runner.temp }}/logs/log.txt

      - name: Upload logs if job fails
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: logs
          path: ${{ runner.temp }}/logs
",0
508,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - secrets context - Example usage of the secrets context,"The secrets context contains the names and values of secrets that are available to a workflow run. The secrets context is not available for composite actions due to security reasons. If you want to pass a secret to a composite action, you need to do it explicitly as an input. For more information about secrets, see Using secrets in GitHub Actions . GITHUB_TOKEN is a secret that is automatically created for every workflow run, and is always included in the secrets context. For more information, see Automatic token authentication . Warning  If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally. Warning If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally. This example workflow uses the GitHub CLI , which requires the GITHUB_TOKEN as the value for the GH_TOKEN input parameter:","name: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title ""Issue title"" --body ""Issue body""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Use GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh auth status
",0
509,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - strategy context - Example usage of the strategy context,"For workflows with a matrix, the strategy context contains information about the matrix execution strategy for the current job. This example workflow uses the strategy.job-index property to set a unique name for a log file for each job in a matrix.","name: Test strategy
on: push

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [1, 2]
        node: [14, 16]
    steps:
      - run: echo ""Mock test logs"" > test-job-${{ strategy.job-index }}.txt
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: Build log for job ${{ strategy.job-index }}
          path: test-job-${{ strategy.job-index }}.txt","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Create log file
        run: echo ""Log for job index ${{ strategy.job-index }}"" > log-${{ strategy.job-index }}.txt
",0
510,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - matrix context - Example usage of the matrix context,"For workflows with a matrix, the matrix context contains the matrix properties defined in the workflow file that apply to the current job. For example, if you configure a matrix with the os and node keys, the matrix context object includes the os and node properties with the values that are being used for the current job. There are no standard properties in the matrix context, only those which are defined in the workflow file. This example workflow creates a matrix with os and node keys. It uses the matrix.os property to set the runner type for each job, and uses the matrix.node property to set the Node.js version for each job.","name: Test matrix
on: push

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - name: Output node version
        run: node --version","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node: [14, 16, 18]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
511,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - needs context - Example usage of the needs context,"The needs context contains outputs from all jobs that are defined as a direct dependency of the current job. Note that this doesn't include implicitly dependent jobs (for example, dependent jobs of a dependent job). For more information on defining job dependencies, see Workflow syntax for GitHub Actions . This example workflow has three jobs: a build job that does a build, a deploy job that requires the build job, and a debug job that requires both the build and deploy jobs and runs only if there is a failure in the workflow. The deploy job also uses the needs context to access an output from the build job.","name: Build and deploy
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.build_step.outputs.build_id }}
    steps:
      - name: Build
        id: build_step
        run: echo ""build_id=$RANDOM"" >> $GITHUB_OUTPUT
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Deploying build ${{ needs.build.outputs.build_id }}""
  debug:
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: ${{ failure() }}
    steps:
      - run: echo ""Failed to build and deploy""","jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build_output: ${{ steps.build_step.outputs.some_output }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Build
        id: build_step
        run: echo ""some_output=build_result"" >> $GITHUB_ENV

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy
        run: echo ""Deploying with build output: ${{ needs.build.outputs.build_output }}""

  debug:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: failure()
    steps:
      - name: Debug
        run: echo ""Debugging due to failure in workflow""
",0
512,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - inputs context - Example usage of the inputs context in a reusable workflow,"The inputs context contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow. For reusable workflows, the input names and types are defined in the workflow_call event configuration of a reusable workflow, and the input values are passed from jobs.<job_id>.with in an external workflow that calls the reusable workflow. For manually triggered workflows, the inputs are defined in the workflow_dispatch event configuration of a workflow. The properties in the inputs context are defined in the workflow file. They are only available in a reusable workflow or in a workflow triggered by the workflow_dispatch event This example reusable workflow uses the inputs context to get the values of the build_id , deploy_target , and perform_deploy inputs that were passed to the reusable workflow from the caller workflow.","name: Reusable deploy workflow
on:
  workflow_call:
    inputs:
      build_id:
        required: true
        type: number
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo ""Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}""","on:
  workflow_call:
    inputs:
      build_id:
        required: true
        type: string
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print inputs
        run: |
          echo ""Build ID: ${{ inputs.build_id }}""
          echo ""Deploy Target: ${{ inputs.deploy_target }}""
          echo ""Perform Deploy: ${{ inputs.perform_deploy }}""
",0
513,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs,Accessing contextual information about workflow runs - inputs context - Example usage of the inputs context in a manually triggered workflow,"The inputs context contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow. For reusable workflows, the input names and types are defined in the workflow_call event configuration of a reusable workflow, and the input values are passed from jobs.<job_id>.with in an external workflow that calls the reusable workflow. For manually triggered workflows, the inputs are defined in the workflow_dispatch event configuration of a workflow. The properties in the inputs context are defined in the workflow file. They are only available in a reusable workflow or in a workflow triggered by the workflow_dispatch event This example workflow triggered by a workflow_dispatch event uses the inputs context to get the values of the build_id , deploy_target , and perform_deploy inputs that were passed to the workflow.","on:
  workflow_dispatch:
    inputs:
      build_id:
        required: true
        type: string
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo ""Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}""","on:
  workflow_dispatch:
    inputs:
      build_id:
        description: 'The ID of the build'
        required: true
        type: string
      deploy_target:
        description: 'The target environment for deployment'
        required: true
        type: string
      perform_deploy:
        description: 'Whether to perform deployment'
        required: true
        type: boolean

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print inputs
        run: |
          echo ""Build ID: ${{ inputs.build_id }}""
          echo ""Deploy Target: ${{ inputs.deploy_target }}""
          echo ""Perform Deploy: ${{ inputs.perform_deploy }}""
",0
514,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for binaries,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the binary you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write","permissions:
  contents: read
  id-token: write
  packages: write
  actions: read
",0
515,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for binaries,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the binary you would like to attest, add the following permissions. After the step where the binary has been built, add the following step.","- name: Generate artifact attestation
  uses: actions/attest-build-provenance@v2
  with:
    subject-path: 'PATH/TO/ARTIFACT'","permissions:
  id-token: write
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Build binary
        run: npm run build

      - name: Generate artifact attestation
        uses: slsa-framework/slsa-github-generator@v1
        with:
          artifact_path: ./path/to/binary
",0
516,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for container images,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the container image you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write
  packages: write","permissions:
  contents: read
  id-token: write
  packages: write
  actions: read
",0
517,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating artifact attestations for your builds - Generating build provenance for container images,"You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images. To generate an artifact attestation, you must: When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's Actions tab. For more information, see the attest-build-provenance repository. In the workflow that builds the container image you would like to attest, add the following permissions. After the step where the image has been built, add the following step.","- name: Generate artifact attestation
  uses: actions/attest-build-provenance@v2
  with:
    subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
    subject-digest: 'sha256:fedcba0...'
    push-to-registry: true","permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: user/repo:tag

    - name: Generate build provenance
      uses: slsa-framework/slsa-github-generator@v1
      with:
        artifact_type: container
        artifact_name: user/repo:tag
",0
518,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for binaries,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the binary you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write","permissions:
  contents: read
  id-token: write
  packages: read
  actions: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Java
        uses: actions/setup-java@v2
        with:
          java-version: '11'

      - name: Build with Maven
        run: mvn clean install

      - name: Generate SBOM
        run: mvn cyclonedx:makeAggregateBom

      - name: Upload SBOM
        uses: actions/upload-artifact@v2
        with:
          name: sbom
          path: target/bom.xml

      - name: Attest SBOM
        uses: slsa-framework/slsa-github-generator@v1
        with:
          artifact_path: target/bom.xml
          attestation_type: sbom
",0
519,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for binaries,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the binary you would like to attest, add the following permissions. After the step where the binary has been built, add the following step.","- name: Generate SBOM attestation
  uses: actions/attest-sbom@v1
  with:
    subject-path: 'PATH/TO/ARTIFACT'
    sbom-path: 'PATH/TO/SBOM'","permissions:
  id-token: write
  contents: read
  actions: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build binary
        run: |
          # Your build commands here

      - name: Generate SBOM attestation
        uses: slsa-framework/slsa-github-generator/.github/actions/attest-sbom@v1
        with:
          artifact_path: path/to/your/binary
",0
520,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for container images,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the container image you would like to attest, add the following permissions.","permissions:
  id-token: write
  contents: read
  attestations: write
  packages: write","permissions:
  id-token: write
  contents: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build container image
        run: |
          docker build -t my-container-image .

      - name: Generate SBOM
        run: |
          syft my-container-image -o json > sbom.json

      - name: Generate SBOM attestation
        uses: slsa-framework/attest-sbom@v1
        with:
          sbom-path: sbom.json
",0
521,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds,Using artifact attestations to establish provenance for builds - Generating an attestation for a software bill of materials (SBOM) - Generating an SBOM attestation for container images,"You can generate signed SBOM attestations for workflow artifacts. To generate an attestation for an SBOM, you must: When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's Actions tab. For more information, see the attest-sbom action repository. In the workflow that builds the container image you would like to attest, add the following permissions. After the step where the image has been built, add the following step.","- name: Generate SBOM attestation
  uses: actions/attest-sbom@v1
  with:
    subject-name: ${{ env.REGISTRY }}/PATH/TO/IMAGE
    subject-digest: 'sha256:fedcba0...'
    sbom-path: 'sbom.json'
    push-to-registry: true","permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build container image
        run: |
          docker build -t my-image:latest .

      - name: Generate SBOM attestation
        uses: slsa-framework/attest-sbom@v1
        with:
          image: my-image:latest
",0
522,https://docs.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues,Closing inactive issues - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Close inactive issues
on:
  schedule:
    - cron: ""30 1 * * *""

jobs:
  close-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/stale@v9
        with:
          days-before-issue-stale: 30
          days-before-issue-close: 14
          stale-issue-label: ""stale""
          stale-issue-message: ""This issue is stale because it has been open for 30 days with no activity.""
          close-issue-message: ""This issue was closed because it has been inactive for 14 days since being marked as stale.""
          days-before-pr-stale: -1
          days-before-pr-close: -1
          repo-token: ${{ secrets.GITHUB_TOKEN }}","name: Close Inactive Issues
on:
  schedule:
    - cron: '0 0 * * *'
jobs:
  close_inactive_issues:
    runs-on: ubuntu-latest
    steps:
      - name: Close inactive issues
        uses: actions/stale@v4
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          days-before-stale: 30
          days-before-close: 7
          stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs.'
          close-issue-message: 'Closing this issue due to inactivity.'
",0
523,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/passing-information-between-jobs,Passing information between jobs - Overview - Example: Defining outputs for a job,"You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs . Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions. If an output is skipped because it may contain a secret, you will see the following warning message: ""Skip output {output.Key} since it may contain secret."" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows . To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs .","jobs:
  job1:
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      output1: ${{ steps.step1.outputs.test }}
      output2: ${{ steps.step2.outputs.test }}
    steps:
      - id: step1
        run: echo ""test=hello"" >> ""$GITHUB_OUTPUT""
      - id: step2
        run: echo ""test=world"" >> ""$GITHUB_OUTPUT""
  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - env:
          OUTPUT1: ${{needs.job1.outputs.output1}}
          OUTPUT2: ${{needs.job1.outputs.output2}}
        run: echo ""$OUTPUT1 $OUTPUT2""","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Set output
        id: step1
        run: echo ""::set-output name=myOutput::Hello World""
    outputs:
      myOutput: ${{ steps.step1.outputs.myOutput }}

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - name: Use output
        run: echo ""The output from job1 is ${{ needs.job1.outputs.myOutput }}""
",0
524,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/passing-information-between-jobs,Passing information between jobs - Overview - Using Job Outputs in a Matrix Job,"You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs . Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions. If an output is skipped because it may contain a secret, you will see the following warning message: ""Skip output {output.Key} since it may contain secret."" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows . To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs . Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.","jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      output_1: ${{ steps.gen_output.outputs.output_1 }}
      output_2: ${{ steps.gen_output.outputs.output_2 }}
      output_3: ${{ steps.gen_output.outputs.output_3 }}
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - name: Generate output
        id: gen_output
        run: |
          version=""${{ matrix.version }}""
          echo ""output_${version}=${version}"" >> ""$GITHUB_OUTPUT""
  job2:
    runs-on: ubuntu-latest
    needs: [job1]
    steps:
      # Will show
      # {
      #   ""output_1"": ""1"",
      #   ""output_2"": ""2"",
      #   ""output_3"": ""3""
      # }
      - run: echo '${{ toJSON(needs.job1.outputs) }}'","jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      example_output: ${{ steps.example_step.outputs.example_value }}
    steps:
      - id: example_step
        run: echo ""::set-output name=example_value::example""

  test:
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - run: echo ""Using output from build: ${{ needs.build.outputs.example_output }}""
",0
525,https://docs.github.com/en/actions/use-cases-and-examples/project-management/moving-assigned-issues-on-project-boards,Moving assigned issues on projects (classic) - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, choose a project (classic).  You can use an existing project, or you can create a new project. For more information about creating a project, see Creating a project (classic) . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Move assigned card
on:
  issues:
    types:
      - assigned
jobs:
  move-assigned-card:
    runs-on: ubuntu-latest
    steps:
      - uses: alex-page/github-project-automation-plus@7ffb872c64bd809d23563a130a0a97d01dfa8f43
        with:
          project: Docs Work
          column: In Progress
          repo-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}","on:
  issues:
    types: [assigned]

jobs:
  move-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Move issue to project
        uses: actions/checkout@v2
      - name: Update project
        uses: actions/github-script@v6
        with:
          script: |
            const projectNumber = 1; // Replace with your project number
            const columnName = 'In Progress'; // Replace with your column name
            const issue = context.payload.issue;
            const project = await github.projects.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            }).then(res => res.data.find(p => p.number === projectNumber));
            if (!project) {
              throw new Error(`Project not found: ${projectNumber}`);
            }
            const columns = await github.projects.listColumns({
              project_id: project.id
            }).then(res => res.data);
            const column = columns.find(c => c.name === columnName);
            if (!column) {
              throw new Error(`Column not found: ${columnName}`);
            }
            await github.projects.createCard({
              column_id: column.id,
              content_id: issue.id,
              content_type: 'Issue'
            });
",0
526,https://docs.github.com/en/actions/use-cases-and-examples/project-management/removing-a-label-when-a-card-is-added-to-a-project-board-column,Removing a label when a card is added to a project (classic) column - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . Choose a project (classic) that belongs to the repository. This workflow cannot be used with projects that belong to users or organizations.  You can use an existing project (classic), or you can create a new project (classic). For more information about creating a project, see Creating a project (classic) . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Remove a label
on:
  project_card:
    types:
      - moved
jobs:
  remove_label:
    if: github.event.project_card.column_id == '12345678'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            // this gets the number at the end of the content URL, which should be the issue/PR number
            const issue_num = context.payload.project_card.content_url.split('/').pop()
            github.rest.issues.removeLabel({
              issue_number: issue_num,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: [""needs review""]
            })","on:
  project_card:
    types: [moved]

jobs:
  remove_label:
    runs-on: ubuntu-latest
    steps:
      - name: Remove label
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          labels: 'your-label'
",0
527,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: Redis container example
on: push

jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to Redis
        # Runs a script that creates a Redis client, populates
        # the client with data, and retrieves data
        run: node client.js
        # Environment variable used by the `client.js` script to create a new Redis client.
        env:
          # The hostname used to communicate with the Redis service container
          REDIS_HOST: redis
          # The default Redis port
          REDIS_PORT: 6379","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      redis:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run Redis CLI
        run: |
          apt-get update
          apt-get install -y redis-tools
          redis-cli -h redis ping
",0
528,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs in containers - Configuring the container job,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. This workflow configures a job that runs in the node:20-bookworm-slim container and uses the ubuntu-latest GitHub-hosted runner as the Docker host for the container. For more information about the node:20-bookworm-slim container, see the node image on Docker Hub. The workflow configures a service container with the label redis . All services must run in a container, so each service requires that you specify the container image . This example uses the redis container image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g. redis:6 . For more information, see the redis image on Docker Hub.","jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5","jobs:
  container-job:
    runs-on: ubuntu-latest
    container:
      image: node:20-bookworm-slim
    services:
      redis:
        image: redis:6
        options: --health-cmd ""redis-cli ping"" --health-interval 10s --health-timeout 5s --health-retries 3
",0
529,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs in containers - Configuring the steps for the container job,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to Redis
    # Runs a script that creates a Redis client, populates
    # the client with data, and retrieves data
    run: node client.js
    # Environment variable used by the `client.js` script to create a new Redis client.
    env:
      # The hostname used to communicate with the Redis service container
      REDIS_HOST: redis
      # The default Redis port
      REDIS_PORT: 6379","jobs:
  container-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      redis:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run Redis command
        run: |
          redis-cli -h redis PING
",0
530,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: Redis runner example
on: push

jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps port 6379 on service container to the host
          - 6379:6379

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to Redis
        # Runs a script that creates a Redis client, populates
        # the client with data, and retrieves data
        run: node client.js
        # Environment variable used by the `client.js` script to create
        # a new Redis client.
        env:
          # The hostname used to communicate with the Redis service container
          REDIS_HOST: localhost
          # The default Redis port
          REDIS_PORT: 6379","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run Redis command
        run: |
          redis-cli -h localhost -p 6379 ping
",0
531,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs directly on the runner machine - Configuring the runner job,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The example uses the ubuntu-latest GitHub-hosted runner as the Docker host. The workflow configures a service container with the label redis . All services must run in a container, so each service requires that you specify the container image . This example uses the redis container image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g. redis:6 . For more information, see the redis image on Docker Hub. The workflow maps port 6379 on the Redis service container to the Docker host. For more information about the ports keyword, see About service containers .","jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd ""redis-cli ping""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps port 6379 on service container to the host
          - 6379:6379","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:6
        ports:
          - 6379:6379
        options: --health-cmd=""redis-cli ping"" --health-interval=10s --health-timeout=5s --health-retries=3
    steps:
      - name: Check Redis service
        run: |
          echo ""Pinging Redis service...""
          redis-cli -h localhost -p 6379 ping
",0
532,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers,Creating Redis service containers - Running jobs directly on the runner machine - Configuring the steps for the runner job,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to Redis
    # Runs a script that creates a Redis client, populates
    # the client with data, and retrieves data
    run: node client.js
    # Environment variable used by the `client.js` script to create
    # a new Redis client.
    env:
      # The hostname used to communicate with the Redis service container
      REDIS_HOST: localhost
      # The default Redis port
      REDIS_PORT: 6379","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running job on the runner machine""
",0
533,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=linux,Running jobs on larger runners - Using groups to control where jobs are run,"In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on a larger runner in the ubuntu-runners group""
",0
534,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=linux,Running jobs on larger runners - Using labels to control where jobs are run,"You can implicitly pass a label to the runs-on key by using the syntax runs-on: LABEL . Alternatively, you can use the labels key, as shown in the example below. In this example, the runs-on key sends the job to any available runner that has been assigned the ubuntu-20.04-16core label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example_job:
    runs-on: ubuntu-20.04-16core
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
535,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=linux,Running jobs on larger runners - Using labels and groups to control where jobs are run,"When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [group:ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
536,https://docs.github.com/en/actions/using-github-hosted-runners/running-jobs-on-larger-runners,Running jobs on larger runners - Using groups to control where jobs are run,"In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
537,https://docs.github.com/en/actions/using-github-hosted-runners/running-jobs-on-larger-runners,Running jobs on larger runners - Using labels to control where jobs are run,"You can implicitly pass a label to the runs-on key by using the syntax runs-on: LABEL . Alternatively, you can use the labels key, as shown in the example below. In this example, the runs-on key sends the job to any available runner that has been assigned the ubuntu-20.04-16core label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  build:
    runs-on: ubuntu-20.04-16core
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run build
        run: npm run build
",0
538,https://docs.github.com/en/actions/using-github-hosted-runners/running-jobs-on-larger-runners,Running jobs on larger runners - Using labels and groups to control where jobs are run,"When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [group:ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
539,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=linux,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run a one-line script
      run: echo ""Hello, world!""
",0
540,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=linux,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: OWNER/REPO_NAME@SHA
        with:
          who-to-greet: ""Your Name""
",0
541,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=linux,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - name: Run goodbye script
      shell: bash
      run: ./goodbye.sh
",0
542,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Adding an action to your workflow - Adding an action from the same repository,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in the same repository where your workflow file uses the action, you can reference the action with either the  {owner}/{repo}@{ref} or ./path/to/dir syntax in your workflow file. Example repository file structure: The path is relative ( ./ ) to the default working directory ( github.workspace , $GITHUB_WORKSPACE ). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated. Example workflow file:","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run local action
        uses: ./path/to/dir
",0
543,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Adding an action to your workflow - Adding an action from a different repository,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in a different repository than your workflow file, you can reference the action with the {owner}/{repo}@{ref} syntax in your workflow file. The action must be stored in a public repository.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/setup-node@v4","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run an action from a different repository
        uses: owner/repo@ref
",0
544,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Adding an action to your workflow - Referencing a container on Docker Hub,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in a published Docker container image on Docker Hub, you must reference the action with the docker://{image}:{tag} syntax in your workflow file. To protect your code and data, we strongly recommend you verify the integrity of the Docker container image from Docker Hub before using it in your workflow.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use Docker container
        uses: docker://{image}:{tag}
",0
545,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using tags,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . Tags are useful for letting you decide when to switch between major and minor versions, but these are more ephemeral and can be moved or deleted by the maintainer. This example demonstrates how to target an action that's been tagged as v1.0.1 :","steps:
  - uses: actions/javascript-action@v1.0.1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v1.0.1
",0
546,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using SHAs,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . If you need more reliable versioning, you should use the SHA value associated with the version of the action. SHAs are immutable and therefore more reliable than tags or branches. However, this approach means you will not automatically receive updates for an action, including important bug fixes and security updates. You must use a commit's full SHA value, and not an abbreviated value. When selecting a SHA, you should verify it is from the action's repository and not a repository fork. This example targets an action's SHA:","steps:
  - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@<full-sha-value>
      - uses: actions/setup-node@<full-sha-value>
        with:
          node-version: '14'
      - name: Run a one-line script
        run: echo Hello, world!
",0
547,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using branches,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . Specifying a target branch for the action means it will always run the version currently on that branch. This approach can create problems if an update to the branch includes breaking changes. This example targets a branch named @main :","steps:
  - uses: actions/javascript-action@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
",0
548,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow,Using pre-written building blocks in your workflow - Using inputs and outputs with an action,"An action often accepts or requires inputs and generates outputs that you can use. For example, an action might require you to specify a path to a file, the name of a label, or other data it will use as part of the action processing. To see the inputs and outputs of an action, check the action.yml in the root directory of the repository. In this example action.yml , the inputs keyword defines a required input called file-path , and includes a default value that will be used if none is specified. The outputs keyword defines an output called results-file , which tells you where to locate the results.","name: ""Example""
description: ""Receives file and generates output""
inputs:
  file-path: # id of input
    description: ""Path to test script""
    required: true
    default: ""test-file.js""
outputs:
  results-file: # id of output
    description: ""Path to results file""","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run example action
        uses: example/action@v1
        with:
          file-path: './path/to/file'
      - name: Use action output
        run: echo ""Results file: ${{ steps.example_action.outputs.results-file }}""
",0
549,https://docs.github.com/en/actions/creating-actions/creating-a-composite-action,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run script
      run: echo ""Hello, World!""
",0
550,https://docs.github.com/en/actions/creating-actions/creating-a-composite-action,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run hello world action
        uses: OWNER/REPO@SHA
        with:
          who-to-greet: 'Your Name'
",0
551,https://docs.github.com/en/actions/creating-actions/creating-a-composite-action,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - run: echo ""Goodbye, World!""
      shell: bash
      working-directory: .github/actions/hello-world-composite-action
",0
552,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - inputs - Example: Specifying inputs,"Optional Input parameters allow you to specify data that the action expects to use during runtime. GitHub stores input parameters as environment variables. We recommend using lowercase input ids. This example configures two inputs: num-octocats and octocat-eye-color . The num-octocats input is not required and will default to a value of 1 . octocat-eye-color is required and has no default value. Note  Actions usingrequired: truewill not automatically return an error if the input is not specified. Note Actions using required: true will not automatically return an error if the input is not specified. Workflow files that use this action can use the with keyword to set an input value for octocat-eye-color . For more information about the with syntax, see Workflow syntax for GitHub Actions .","inputs:
  num-octocats:
    description: 'Number of Octocats'
    required: false
    default: '1'
  octocat-eye-color:
    description: 'Eye color of the Octocats'
    required: true","inputs:
  num-octocats:
    description: 'Number of octocats'
    required: false
    default: 1
  octocat-eye-color:
    description: 'Eye color of the octocat'
    required: true
",0
553,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - outputs for Docker container and JavaScript actions - Example: Declaring outputs for Docker container and JavaScript actions,"Optional Output parameters allow you to declare data that an action sets. Actions that run later in a workflow can use the output data set in previously run actions. For example, if you had an action that performed the addition of two inputs (x + y = z), the action could output the sum (z) for other actions to use as an input. Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. If you don't declare an output in your action metadata file, you can still set outputs and use them in a workflow. For more information on setting outputs in an action, see Workflow commands for GitHub Actions .","outputs:
  sum: # id of the output
    description: 'The sum of the inputs'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run Docker action
        uses: ./path/to/docker-action
        id: docker-action
        with:
          input1: value1
          input2: value2

      - name: Use Docker action output
        run: echo ""Output from Docker action: ${{ steps.docker-action.outputs.output_name }}""

      - name: Run JavaScript action
        uses: ./path/to/javascript-action
        id: js-action
        with:
          input1: value1
          input2: value2

      - name: Use JavaScript action output
        run: echo ""Output from JavaScript action: ${{ steps.js-action.outputs.output_name }}""
",0
554,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - outputs for composite actions - Example: Declaring outputs for composite actions,"Optional  outputs use the same parameters as outputs.<output_id> and outputs.<output_id>.description (see outputs for Docker container and JavaScript actions ), but also includes the value token. Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.","outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-id }}
runs:
  using: ""composite""
  steps:
    - id: random-number-generator
      run: echo ""random-id=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash","outputs:
  example_output:
    description: ""An example output""
    value: ${{ steps.step_id.outputs.output_name }}
",0
555,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - Example: Using Node.js v20,Required Configures the path to the action's code and the runtime used to execute the code.,"runs:
  using: 'node20'
  main: 'main.js'","runs:
  using: 'node20'
  main: 'index.js'
",0
556,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.pre,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to run a script at the start of a job, before the main: action begins. For example, you can use pre: to run a prerequisite setup script. The runtime specified with the using syntax will execute this file. The pre: action always runs by default but you can override this using runs.pre-if . Note  runs.preis not supported for local actions. Note runs.pre is not supported for local actions. In this example, the pre: action runs a script called setup.js :","runs:
  using: 'node20'
  pre: 'setup.js'
  main: 'index.js'
  post: 'cleanup.js'","runs:
  using: 'node12'
  main: 'index.js'
  pre: 'setup.js'
",0
557,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.pre-if,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to define conditions for the pre: action execution. The pre: action will only run if the conditions in pre-if are met. If not set, then pre-if defaults to always() . In pre-if , status check functions evaluate against the job's status, not the action's own status. Note that the step context is unavailable, as no steps have run yet. In this example, cleanup.js only runs on Linux-based runners:","pre: 'cleanup.js'
  pre-if: runner.os == 'linux'","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run JavaScript Action
        uses: actions/javascript-action@v1
        with:
          pre-if: runner.os == 'Linux'
",0
558,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.post,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to run a script at the end of a job, once the main: action has completed. For example, you can use post: to terminate certain processes or remove unneeded files. The runtime specified with the using syntax will execute this file. In this example, the post: action runs a script called cleanup.js :","runs:
  using: 'node20'
  main: 'index.js'
  post: 'cleanup.js'","runs:
  using: 'node12'
  main: 'index.js'
  post: 'cleanup.js'
",0
559,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for JavaScript actions - runs.post-if,"Required Configures the path to the action's code and the runtime used to execute the code. Optional Allows you to define conditions for the post: action execution. The post: action will only run if the conditions in post-if are met. If not set, then post-if defaults to always() . In post-if , status check functions evaluate against the job's status, not the action's own status. For example, this cleanup.js will only run on Linux-based runners:","post: 'cleanup.js'
  post-if: runner.os == 'linux'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run JavaScript action
        uses: ./path-to-action
        with:
          node-version: '14'
    post:
      - name: Cleanup
        if: runner.os == 'Linux'
        run: node cleanup.js
",0
560,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].run,Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional The command you want to run. This can be inline or a script in your action repository:,"runs:
  using: ""composite""
  steps:
    - run: ${{ github.action_path }}/test/script.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
561,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].run,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional The command you want to run. This can be inline or a script in your action repository: Alternatively, you can use $GITHUB_ACTION_PATH :","runs:
  using: ""composite""
  steps:
    - run: $GITHUB_ACTION_PATH/script.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
562,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: success()
      run: echo ""This step runs only if the previous steps were successful.""
",0
563,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Example: Using contexts This step only runs when the event type is a pull_request and the event action is unassigned .","steps:
  - run: echo This event is a pull request that had an assignee removed.
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}","runs:
  using: ""composite""
  steps:
    - if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
      run: echo ""This step runs only for unassigned pull_request events.""
",0
564,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].if,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Example: Using contexts This step only runs when the event type is a pull_request and the event action is unassigned . Example: Using status check functions The my backup step only runs when the previous step of a composite action fails. For more information, see Evaluate expressions in workflows and actions .","steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0","runs:
  using: ""composite""
  steps:
    - name: Example Step
      if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
      run: echo ""This step runs on pull_request with unassigned action""
    - name: My Backup Step
      if: failure()
      run: echo ""This step runs if the previous step fails""
",0
565,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].uses,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag number. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required.","runs:
  using: ""composite""
  steps:
    # Reference a specific commit
    - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
    # Reference the major version of a release
    - uses: actions/checkout@v4
    # Reference a specific version
    - uses: actions/checkout@v4.2.0
    # Reference a branch
    - uses: actions/checkout@main
    # References a subdirectory in a public GitHub repository at a specific branch, ref, or SHA
    - uses: actions/aws/ec2@main
    # References a local action
    - uses: ./.github/actions/my-action
    # References a docker public registry action
    - uses: docker://gcr.io/cloud-builders/gradle
    # Reference a docker image published on docker hub
    - uses: docker://alpine:3.8","runs:
  using: ""composite""
  steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v2
      with:
        node-version: '14'
    - run: npm install
    - run: npm test
",0
566,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for composite actions - runs.steps - runs.steps[*].with,"Required Configures the path to the composite action. Required The steps that you plan to run in this action. These can be either run steps or uses steps. Optional A map of the input parameters defined by the action. Each input parameter is a key/value pair. For more information, see Example: Specifying inputs .","runs:
  using: ""composite""
  steps:
    - name: My first step
      uses: actions/hello_world@main
      with:
        first_name: Mona
        middle_name: The
        last_name: Octocat","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
567,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - Example: Using a Dockerfile in your repository,Required Configures the image used for the Docker container action.,"runs:
  using: 'docker'
  image: 'Dockerfile'","runs:
  using: 'docker'
  image: 'Dockerfile'
",0
568,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - Example: Using public Docker registry container,Required Configures the image used for the Docker container action.,"runs:
  using: 'docker'
  image: 'docker://debian:stretch-slim'","runs:
  using: 'docker'
  image: 'docker://<public-docker-registry-image>'
",0
569,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.pre-entrypoint,"Required Configures the image used for the Docker container action. Optional Allows you to run a script before the entrypoint action begins. For example, you can use pre-entrypoint: to run a prerequisite setup script. GitHub Actions uses docker run to launch this action, and runs the script inside a new container that uses the same base image. This means that the runtime state is different from the main entrypoint container, and any states you require must be accessed in either the workspace, HOME , or as a STATE_ variable. The pre-entrypoint: action always runs by default but you can override this using runs.pre-if . The runtime specified with the using syntax will execute this file. In this example, the pre-entrypoint: action runs a script called setup.sh :","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  pre-entrypoint: 'setup.sh'
  entrypoint: 'main.sh'","runs:
  using: 'docker'
  image: 'your-docker-image'
  pre-entrypoint: 'setup.sh'
",0
570,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.post-entrypoint,"Required Configures the image used for the Docker container action. Optional Allows you to run a cleanup script once the runs.entrypoint action has completed. GitHub Actions uses docker run to launch this action. Because GitHub Actions runs the script inside a new container using the same base image, the runtime state is different from the main entrypoint container. You can access any state you need in either the workspace, HOME , or as a STATE_ variable. The post-entrypoint: action always runs by default but you can override this using runs.post-if .","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  entrypoint: 'main.sh'
  post-entrypoint: 'cleanup.sh'","runs:
  using: 'docker'
  image: 'docker://your-docker-image'
  post-entrypoint: 'your-cleanup-script.sh'
",0
571,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - runs for Docker container actions - runs.args - Example: Defining arguments for the Docker container,"Required Configures the image used for the Docker container action. Optional An array of strings that define the inputs for a Docker container. Inputs can include hardcoded strings. GitHub passes the args to the container's ENTRYPOINT when the container starts up. The args are used in place of the CMD instruction in a Dockerfile . If you use CMD in your Dockerfile , use the guidelines ordered by preference: If you need to pass environment variables into an action, make sure your action runs a command shell to perform variable substitution. For example, if your entrypoint attribute is set to ""sh -c"" , args will be run in a command shell. Alternatively, if your Dockerfile uses an ENTRYPOINT to run the same command ( ""sh -c"" ), args will execute in a command shell. For more information about using the CMD instruction with GitHub Actions, see Dockerfile support for GitHub Actions .","runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.greeting }}
    - 'foo'
    - 'bar'","runs:
  using: 'docker'
  image: 'Dockerfile'
  args: ['your', 'arguments', 'here']
",0
572,https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions,Metadata syntax for GitHub Actions - branding - Example: Configuring branding for an action,Optional You can use a color and Feather icon to create a badge to personalize and distinguish your action. Badges are shown next to your action name in GitHub Marketplace .,"branding:
  icon: 'award'
  color: 'green'","branding:
  color: ""blue""
  icon: ""zap""
",0
573,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: If your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually. Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
574,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: If your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually. Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
575,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Using custom actions - Requesting the JWT using the Actions core toolkit,"If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider. If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN , ACTIONS_ID_TOKEN_REQUEST_URL . To update your workflows using this approach, you will need to make three changes to your YAML: The following example demonstrates how to use actions/github-script with the core toolkit to request the JWT from GitHub's OIDC provider. For more information, see Creating a JavaScript action .","jobs:
  job:
    environment: Production
    runs-on: ubuntu-latest
    steps:
    - name: Install OIDC Client from Core Package
      run: npm install @actions/core@1.6.0 @actions/http-client
    - name: Get Id Token
      uses: actions/github-script@v7
      id: idtoken
      with:
        script: |
          const coredemo = require('@actions/core')
          let id_token = await coredemo.getIDToken()
          coredemo.setOutput('id_token', id_token)","jobs:
  request-jwt:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Request JWT
        uses: actions/github-script@v6
        with:
          script: |
            const core = require('@actions/core');
            const { getIDToken } = require('@actions/core/lib/id-token');
            async function run() {
              try {
                const idToken = await getIDToken();
                console.log(`ID Token: ${idToken}`);
              } catch (error) {
                core.setFailed(`Error retrieving ID token: ${error.message}`);
              }
            }
            run();
",0
576,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Using custom actions - Requesting the JWT using environment variables,"If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider. If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN , ACTIONS_ID_TOKEN_REQUEST_URL . To update your workflows using this approach, you will need to make three changes to your YAML: The following example demonstrates how to use environment variables to request a JSON Web Token. For your deployment job, you will need to define the token settings, using actions/github-script with the core toolkit. For more information, see Creating a JavaScript action . For example:","jobs:
  job:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/github-script@v7
      id: script
      timeout-minutes: 10
      with:
        debug: true
        script: |
          const token = process.env['ACTIONS_RUNTIME_TOKEN']
          const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']
          core.setOutput('TOKEN', token.trim())
          core.setOutput('IDTOKENURL', runtimeUrl.trim())","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Request JWT
        id: request_jwt
        run: |
          echo ""Requesting JWT...""
          echo ""TOKEN=$(curl -H ""Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"" $ACTIONS_ID_TOKEN_REQUEST_URL)"" >> $GITHUB_ENV

      - name: Use JWT
        run: |
          echo ""Using JWT...""
          echo ""Token: ${{ env.TOKEN }}""
",0
577,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Using custom actions - Requesting the JWT using environment variables,"If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider. If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN , ACTIONS_ID_TOKEN_REQUEST_URL . To update your workflows using this approach, you will need to make three changes to your YAML: The following example demonstrates how to use environment variables to request a JSON Web Token. For your deployment job, you will need to define the token settings, using actions/github-script with the core toolkit. For more information, see Creating a JavaScript action . For example: You can then use curl to retrieve a JWT from the GitHub OIDC provider. For example:","- run: |
        IDTOKEN=$(curl -H ""Authorization: Bearer ${{steps.script.outputs.TOKEN}}"" ${{steps.script.outputs.IDTOKENURL}}  -H ""Accept: application/json; api-version=2.0"" -H ""Content-Type: application/json"" -d ""{}"" | jq -r '.value')
        echo $IDTOKEN
        jwtd() {
            if [[ -x $(command -v jq) ]]; then
                jq -R 'split(""."") | .[0],.[1] | @base64d | fromjson' <<< ""${1}""
                echo ""Signature: $(echo ""${1}"" | awk -F'.' '{print $3}')""
            fi
        }
        jwtd $IDTOKEN
        echo ""idToken=${IDTOKEN}"" >> $GITHUB_OUTPUT
      id: tokenid","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Request JWT
        env:
          ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ secrets.ACTIONS_ID_TOKEN_REQUEST_TOKEN }}
          ACTIONS_ID_TOKEN_REQUEST_URL: ${{ secrets.ACTIONS_ID_TOKEN_REQUEST_URL }}
        run: |
          TOKEN=$(curl -H ""Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN"" $ACTIONS_ID_TOKEN_REQUEST_URL)
          echo ""JWT Token: $TOKEN""
",0
578,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows,Using OpenID Connect with reusable workflows - How the token works with reusable workflows,"During a workflow run, GitHub's OIDC provider presents a OIDC token to the cloud provider which contains information about the job. If that job is part of a reusable workflow, the token will include the standard claims that contain information about the calling workflow, and will also include a custom claim called job_workflow_ref that contains information about the called workflow. For example, the following OIDC token is for a job that was part of a called workflow. The workflow , ref , and other attributes describe the caller workflow, while job_workflow_ref refers to the called workflow:","{
  ""typ"": ""JWT"",
  ""alg"": ""RS256"",
  ""x5t"": ""example-thumbprint"",
  ""kid"": ""example-key-id""
}
{
  ""jti"": ""example-id"",
  ""sub"": ""repo:octo-org/octo-repo:environment:prod"",
  ""aud"": ""https://github.com/octo-org"",
  ""ref"": ""refs/heads/main"",
  ""sha"": ""example-sha"",
  ""repository"": ""octo-org/octo-repo"",
  ""repository_owner"": ""octo-org"",
  ""actor_id"": ""12"",
  ""repository_id"": ""74"",
  ""repository_owner_id"": ""65"",
  ""run_id"": ""example-run-id"",
  ""run_number"": ""10"",
  ""run_attempt"": ""2"",
  ""actor"": ""octocat"",
  ""workflow"": ""example-workflow"",
  ""head_ref"": """",
  ""base_ref"": """",
  ""event_name"": ""workflow_dispatch"",
  ""ref_type"": ""branch"",
  ""job_workflow_ref"": ""octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main"",
  ""iss"": ""https://token.actions.githubusercontent.com"",
  ""nbf"": 1632492967,
  ""exp"": 1632493867,
  ""iat"": 1632493567
}","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Call reusable workflow
        uses: owner/repo/.github/workflows/reusable-workflow.yml@main
        with:
          some-input: some-value
        id-token: write
",0
579,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Input parameters for the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. key : Required The key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail. path : Required The path(s) on the runner to cache or restore. You can specify a single path, or you can add multiple paths on separate lines. For example:","- name: Cache Gradle packages
  uses: actions/cache@v4
  with:
    path: |
      ~/.gradle/caches
      ~/.gradle/wrapper","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: path/to/dependencies
        key: ${{ runner.os }}-build-${{ hashFiles('**/lockfile') }}
    - name: Install dependencies
      run: |
        # Command to install dependencies
",0
580,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Input parameters for the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. key : Required The key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail. path : Required The path(s) on the runner to cache or restore. You can specify a single path, or you can add multiple paths on separate lines. For example: You can specify either directories or single files, and glob patterns are supported. You can specify absolute paths, or paths relative to the workspace directory. restore-keys : Optional A string containing alternative restore keys, with each restore key placed on a new line. If no cache hit occurs for key , these restore keys are used sequentially in the order provided to find and restore a cache. For example:","restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: path/to/dependencies
          key: ${{ runner.os }}-build-${{ hashFiles('**/lockfile') }}
          restore-keys: |
            ${{ runner.os }}-build-
",0
581,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Example using the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. This example creates a new cache when the packages in package-lock.json file change, or when the runner's operating system changes. The cache key uses contexts and expressions to generate a key that includes the runner's operating system and a SHA-256 hash of the package-lock.json file.","name: Caching with npm
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache node modules
        id: cache-npm
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
        name: List the state of node modules
        continue-on-error: true
        run: npm list

      - name: Install dependencies
        run: npm install

      - name: Build
        run: npm run build

      - name: Test
        run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
    - run: npm install
",0
582,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Using contexts to create cache keys,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, see Accessing contextual information about workflow runs and Evaluate expressions in workflows and actions . Using expressions to create a key allows you to automatically create a new cache when dependencies change. For example, you can create a key using an expression that calculates the hash of an npm package-lock.json file. So, when the dependencies that make up the package-lock.json file change, the cache key changes and a new cache is automatically created.",npm-${{ hashFiles('package-lock.json') }},"jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache node modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        run: npm install
",0
583,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Using contexts to create cache keys,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, see Accessing contextual information about workflow runs and Evaluate expressions in workflows and actions . Using expressions to create a key allows you to automatically create a new cache when dependencies change. For example, you can create a key using an expression that calculates the hash of an npm package-lock.json file. So, when the dependencies that make up the package-lock.json file change, the cache key changes and a new cache is automatically created. GitHub evaluates the expression hash ""package-lock.json"" to derive the final key .",npm-d5ea0750,"jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache node modules
      uses: actions/cache@v3
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    - name: Install dependencies
      run: npm install
",0
584,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Using the output of the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. You can use the output of the cache action to do something based on whether a cache hit or miss occurred. When an exact match is found for a cache for the specified key , the cache-hit output is set to true . In the example workflow above, there is a step that lists the state of the Node modules if a cache miss occurred:","- if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
  name: List the state of node modules
  continue-on-error: true
  run: npm list","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache Node modules
      id: cache-node-modules
      uses: actions/cache@v3
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    - name: Install dependencies
      if: steps.cache-node-modules.outputs.cache-hit != 'true'
      run: npm install
    - name: List Node modules
      if: steps.cache-node-modules.outputs.cache-hit != 'true'
      run: ls node_modules
",0
585,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Matching a cache key - Example using multiple restore keys,"The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for key , and if there is still no hit, it searches for restore-keys and the version . If there are still no hits in the current branch, the cache action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache . Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation. restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key . You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache.","restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: path/to/dependencies
        key: ${{ runner.os }}-build-${{ hashFiles('**/lockfiles') }}
        restore-keys: |
          ${{ runner.os }}-build-
          ${{ runner.os }}-
",0
586,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Matching a cache key - Example using multiple restore keys,"The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for key , and if there is still no hit, it searches for restore-keys and the version . If there are still no hits in the current branch, the cache action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache . Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation. restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key . You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache. The runner evaluates the expressions, which resolve to these restore-keys :","restore-keys: |
  npm-feature-d5ea0750
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: path/to/dependencies
        key: ${{ runner.os }}-build-${{ hashFiles('**/lockfile') }}
        restore-keys: |
          ${{ runner.os }}-build-
          ${{ runner.os }}-
",0
587,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Matching a cache key - Example using multiple restore keys - Example of search priority,"The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for key , and if there is still no hit, it searches for restore-keys and the version . If there are still no hits in the current branch, the cache action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache . Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation. restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key . You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache. The runner evaluates the expressions, which resolve to these restore-keys : The restore key npm-feature- matches any key that starts with the string npm-feature- . For example, both of the keys npm-feature-fd3052de and npm-feature-a9b253ff match the restore key. The cache with the most recent creation date would be used. The keys in this example are searched in the following order:","key:
  npm-feature-d5ea0750
restore-keys: |
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: npm-feature-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          npm-feature-
",0
588,https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Managing caches - Force deleting cache entries,"To manage caches created from your workflows, you can: There are multiple ways to manage caches for your repositories: Using the GitHub web interface, as shown below. Using the REST API. For more information, see REST API endpoints for GitHub Actions cache . Installing the gh cache subcommand to manage your caches from the command line. For more information, see the GitHub CLI documentation . Note  If you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed. Note If you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed. Caches have branch scope restrictions in place, which means some caches have limited usage options. For more information on cache scope restrictions, see Restrictions for accessing a cache , earlier in this article. If caches limited to a specific branch are using a lot of storage quota, it may cause caches from the default branch to be created and deleted at a high frequency. For example, a repository could have many new pull requests opened, each with their own caches that are restricted to that branch. These caches could take up the majority of the cache storage for that repository. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository. In order to prevent cache thrashing when this happens, you can set up workflows to delete caches on a faster cadence than the cache eviction policy will. You can use the GitHub CLI to delete caches for specific branches. The following example workflow uses gh cache to delete up to 100 caches created by a branch once a pull request is closed. To run the following example on cross-repository pull requests or pull requests from forks, you can trigger the workflow with the pull_request_target event. If you do use pull_request_target to trigger the workflow, there are security considerations to keep in mind. For more information, see Events that trigger workflows .","name: cleanup caches by a branch
on:
  pull_request:
    types:
      - closed

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup
        run: |
          echo ""Fetching list of cache key""
          cacheKeysForPR=$(gh cache list --ref $BRANCH --limit 100 --json id --jq '.[].id')

          ## Setting this to not fail the workflow while deleting cache keys.
          set +e
          echo ""Deleting caches...""
          for cacheKey in $cacheKeysForPR
          do
              gh cache delete $cacheKey
          done
          echo ""Done""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          BRANCH: refs/pull/${{ github.event.pull_request.number }}/merge","on:
  pull_request:
    types: [closed]

jobs:
  delete-cache:
    runs-on: ubuntu-latest
    steps:
      - name: Install GitHub CLI
        run: sudo apt-get install -y gh

      - name: Delete caches
        run: gh cache delete --branch ${{ github.head_ref }} --confirm --limit 100
",0
589,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell,Building and testing PowerShell - Adding a workflow for Pester,"To automate your testing with PowerShell and Pester, you can add a workflow that runs every time a change is pushed to your repository. In the following example, Test-Path is used to check that a file called resultsfile.log is present. This example workflow file must be added to your repository's .github/workflows/ directory:","name: Test PowerShell on Ubuntu
on: push

jobs:
  pester-test:
    name: Pester test
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Perform a Pester test from the command-line
        shell: pwsh
        run: Test-Path resultsfile.log | Should -Be $true
      - name: Perform a Pester test from the Tests.ps1 file
        shell: pwsh
        run: |
          Invoke-Pester Unit.Tests.ps1 -Passthru","on:
  push:
    branches:
      - '**'

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup PowerShell
        uses: actions/setup-powershell@v2
      - name: Run Pester tests
        run: |
          Install-Module -Name Pester -Force -SkipPublisherCheck
          Invoke-Pester
      - name: Check for results file
        run: |
          if (-Not (Test-Path -Path ""resultsfile.log"")) {
            throw ""resultsfile.log not found""
          }
",0
590,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell,Building and testing PowerShell - Installing dependencies,"GitHub-hosted runners have PowerShell 7 and Pester installed. You can use Install-Module to install additional dependencies from the PowerShell Gallery before building and testing your code. Note  The pre-installed packages (such as Pester) used by GitHub-hosted runners are regularly updated, and can introduce significant changes. As a result, it is recommended that you always specify the required package versions by usingInstall-Modulewith-MaximumVersion. Note The pre-installed packages (such as Pester) used by GitHub-hosted runners are regularly updated, and can introduce significant changes. As a result, it is recommended that you always specify the required package versions by using Install-Module with -MaximumVersion . You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . For example, the following job installs the SqlServer and PSScriptAnalyzer modules:","jobs:
  install-dependencies:
    name: Install dependencies
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install from PSGallery
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module SqlServer, PSScriptAnalyzer","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install dependencies
        run: |
          Install-Module -Name SqlServer -MaximumVersion 21.1.18256 -Force
          Install-Module -Name PSScriptAnalyzer -MaximumVersion 1.20.0 -Force
      - name: Run tests
        run: |
          Invoke-Pester
",0
591,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell,Building and testing PowerShell - Installing dependencies - Caching dependencies,"GitHub-hosted runners have PowerShell 7 and Pester installed. You can use Install-Module to install additional dependencies from the PowerShell Gallery before building and testing your code. Note  The pre-installed packages (such as Pester) used by GitHub-hosted runners are regularly updated, and can introduce significant changes. As a result, it is recommended that you always specify the required package versions by usingInstall-Modulewith-MaximumVersion. Note The pre-installed packages (such as Pester) used by GitHub-hosted runners are regularly updated, and can introduce significant changes. As a result, it is recommended that you always specify the required package versions by using Install-Module with -MaximumVersion . You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . For example, the following job installs the SqlServer and PSScriptAnalyzer modules: Note  By default, no repositories are trusted by PowerShell. When installing modules from the PowerShell Gallery, you must explicitly set the installation policy forPSGallerytoTrusted. By default, no repositories are trusted by PowerShell. When installing modules from the PowerShell Gallery, you must explicitly set the installation policy for PSGallery to Trusted . You can cache PowerShell dependencies using a unique key, which allows you to restore the dependencies for future workflows with the cache action. For more information, see Caching dependencies to speed up workflows . PowerShell caches its dependencies in different locations, depending on the runner's operating system. For example, the path location used in the following Ubuntu example will be different for a Windows operating system.","steps:
  - uses: actions/checkout@v4
  - name: Setup PowerShell module cache
    id: cacher
    uses: actions/cache@v4
    with:
      path: ""~/.local/share/powershell/Modules""
      key: ${{ runner.os }}-SqlServer-PSScriptAnalyzer
  - name: Install required PowerShell modules
    if: steps.cacher.outputs.cache-hit != 'true'
    shell: pwsh
    run: |
      Set-PSRepository PSGallery -InstallationPolicy Trusted
      Install-Module SqlServer, PSScriptAnalyzer -ErrorAction Stop","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Set up PowerShell
      uses: actions/setup-powershell@v2

    - name: Restore PowerShell module cache
      uses: actions/cache@v3
      with:
        path: ~/.local/share/powershell/Modules
        key: ${{ runner.os }}-ps-modules-${{ hashFiles('**/*.ps1') }}

    - name: Install PowerShell modules
      run: |
        pwsh -Command ""Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted""
        pwsh -Command ""Install-Module -Name SqlServer -MaximumVersion 21.1.18256 -Force""
        pwsh -Command ""Install-Module -Name PSScriptAnalyzer -MaximumVersion 1.20.0 -Force""

    - name: Run tests
      run: pwsh -Command ""Invoke-Pester""
",0
592,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell,Building and testing PowerShell - Testing your code - Using PSScriptAnalyzer to lint code,"You can use the same commands that you use locally to build and test your code. The following example installs PSScriptAnalyzer and uses it to lint all ps1 files in the repository. For more information, see PSScriptAnalyzer on GitHub .","lint-with-PSScriptAnalyzer:
    name: Install and run PSScriptAnalyzer
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install PSScriptAnalyzer module
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module PSScriptAnalyzer -ErrorAction Stop
      - name: Lint with PSScriptAnalyzer
        shell: pwsh
        run: |
          Invoke-ScriptAnalyzer -Path *.ps1 -Recurse -Outvariable issues
          $errors   = $issues.Where({$_.Severity -eq 'Error'})
          $warnings = $issues.Where({$_.Severity -eq 'Warning'})
          if ($errors) {
              Write-Error ""There were $($errors.Count) errors and $($warnings.Count) warnings total."" -ErrorAction Stop
          } else {
              Write-Output ""There were $($errors.Count) errors and $($warnings.Count) warnings total.""
          }","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up PowerShell
        uses: actions/setup-powershell@v2
      - name: Install PSScriptAnalyzer
        run: pwsh -c ""Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser""
      - name: Lint PowerShell scripts
        run: pwsh -c ""Invoke-ScriptAnalyzer -Path './**/*.ps1'""
",0
593,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell,Building and testing PowerShell - Packaging workflow data as artifacts,"You can upload artifacts to view after a workflow completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, see Storing and sharing data from a workflow . The following example demonstrates how you can use the upload-artifact action to archive the test results received from Invoke-Pester . For more information, see the upload-artifact action .","name: Upload artifact from Ubuntu

on: [push]

jobs:
  upload-pester-results:
    name: Run Pester and upload results
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Test with Pester
        shell: pwsh
        run: Invoke-Pester Unit.Tests.ps1 -Passthru | Export-CliXml -Path Unit.Tests.xml
      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: ubuntu-Unit-Tests
          path: Unit.Tests.xml
    if: ${{ always() }}","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup PowerShell
      uses: actions/setup-powershell@v2
    - name: Run Pester tests
      run: |
        Install-Module -Name Pester -Force -SkipPublisherCheck
        Invoke-Pester -OutputFormat NUnitXml -OutputFile TestResults.xml
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: TestResults.xml
",0
594,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell,Building and testing PowerShell - Publishing to PowerShell Gallery,"You can configure your workflow to publish your PowerShell module to the PowerShell Gallery when your CI tests pass. You can use secrets to store any tokens or credentials needed to publish your package. For more information, see Using secrets in GitHub Actions . The following example creates a package and uses Publish-Module to publish it to the PowerShell Gallery:","name: Publish PowerShell Module

on:
  release:
    types: [created]

jobs:
  publish-to-gallery:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build and publish
        env:
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        shell: pwsh
        run: |
          ./build.ps1 -Path /tmp/samplemodule
          Publish-Module -Path /tmp/samplemodule -NuGetApiKey $env:NUGET_KEY -Verbose","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up PowerShell
      uses: actions/setup-powershell@v2
    - name: Install dependencies
      run: Install-Module -Name Pester -Force -Scope CurrentUser
    - name: Run tests
      run: Invoke-Pester
    - name: Publish module
      env:
        PSGalleryApiKey: ${{ secrets.PSGALLERY_API_KEY }}
      run: |
        $moduleManifest = Get-ChildItem -Path . -Filter '*.psd1' | Select-Object -First 1
        Publish-Module -Path $moduleManifest.FullName -NuGetApiKey $PSGalleryApiKey
",0
595,https://docs.github.com/en/actions/security-guides/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3,Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3 - Step 1: Configuring your builds - Building with artifact attestations,"First, we need to build with both artifact attestations and a reusable workflow. The reusable workflow you use to build your software must also generate artifact attestations to establish build provenance. For more information, see Using artifact attestations to establish provenance for builds . When you use a reusable workflow to generate artifact attestations, both the calling workflow and the reusable workflow need to have the following permissions.","permissions:
  attestations: write
  contents: read
  id-token: write","permissions:
  contents: read
  id-token: write
  packages: read
  actions: read
  checks: read
  deployments: read
  issues: read
  discussions: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read

jobs:
  build:
    uses: ./.github/workflows/reusable-build-workflow.yml
    with:
      generate-attestations: true
",0
596,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action,Creating a JavaScript action - Creating an action metadata file,"Create a new file named action.yml in the hello-world-javascript-action directory with the following example code. For more information, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'node20'
  main: 'index.js'","name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:
    description: 'Who to greet'
    default: 'World'
runs:
  using: 'node12'
  main: 'index.js'
",0
597,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action,Creating a JavaScript action - Testing out your action in a workflow - Example using a public action,"Now you're ready to test your action out in a workflow. Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository . This example demonstrates how your new public action can be run from within an external repository. Copy the following YAML into a new file at .github/workflows/main.yml , and update the uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b line with your username and the name of the public repository you created above. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Run my action
      uses: your-username/your-repo-name@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
      with:
        who-to-greet: 'Your Name'
",0
598,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action,Creating a JavaScript action - Testing out your action in a workflow - Example using a private action,"Now you're ready to test your action out in a workflow. Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository . Copy the workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Run private action
        uses: ./  # Assumes the action is in the root of the repository
        with:
          who-to-greet: YourName
",0
599,https://docs.github.com/en/actions/writing-workflows/about-workflows,About workflows - Advanced workflow features - Storing secrets,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your workflows use sensitive data, such as passwords or certificates, you can save these in GitHub as secrets and then use them in your workflows as environment variables. This means that you will be able to create and share workflows without having to embed sensitive values directly in the workflow's YAML source. This example job demonstrates how to reference an existing secret as an environment variable, and send it as a parameter to an example command.","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Retrieve secret
        env:
          super_secret: ${{ secrets.SUPERSECRET }}
        run: |
          example-command ""$super_secret""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret
        run: echo ""Using secret""
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}
",0
600,https://docs.github.com/en/actions/writing-workflows/about-workflows,About workflows - Advanced workflow features - Creating dependent jobs,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. By default, the jobs in your workflow all run in parallel at the same time. If you have a job that must only run after another job has completed, you can use the needs keyword to create this dependency. If one of the jobs fails, all dependent jobs are skipped; however, if you need the jobs to continue, you can define this using the if conditional statement. In this example, the setup , build , and test jobs run in series, with build and test being dependent on the successful completion of the job that precedes them:","jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: ./setup_server.sh
  build:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - run: ./build_server.sh
  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: ./test_server.sh","jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Setting up environment""

  build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - run: echo ""Building the project""

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo ""Running tests""
",0
601,https://docs.github.com/en/actions/writing-workflows/about-workflows,About workflows - Advanced workflow features - Using a matrix,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. The matrix is created using the strategy keyword, which receives the build options as an array. For example, this matrix will run the job multiple times, using different versions of Node.js:","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [12, 14, 16]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - run: npm test
",0
602,https://docs.github.com/en/actions/writing-workflows/about-workflows,About workflows - Advanced workflow features - Caching dependencies,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your jobs regularly reuse dependencies, you can consider caching these files to help improve performance. Once the cache is created, it is available to all workflows in the same repository. This example demonstrates how to cache the ~/.npm directory:","jobs:
  example-job:
    steps:
      - name: Cache node modules
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache NPM dependencies
        uses: actions/cache@v2
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-
      - name: Install dependencies
        run: npm install
",0
603,https://docs.github.com/en/actions/writing-workflows/about-workflows,About workflows - Advanced workflow features - Using databases and service containers,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your job requires a database or cache service, you can use the services keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can use services to create a postgres container, and then use node to connect to the service.","jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node:20-bookworm-slim
    services:
      postgres:
        image: postgres
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: npm ci
      - name: Connect to PostgreSQL
        run: node client.js
        env:
          POSTGRES_HOST: postgres
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run database script
        env:
          PGHOST: localhost
          PGUSER: postgres
          PGPASSWORD: postgres
          PGPORT: 5432
        run: node script.js
",0
604,https://docs.github.com/en/actions/writing-workflows/about-workflows,About workflows - Advanced workflow features - Using labels to route workflows,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If you want to be sure that a particular type of runner will process your job, you can use labels to control where jobs are executed. You can assign labels to a self-hosted runner in addition to their default label of self-hosted . Then, you can refer to these labels in your YAML workflow, ensuring that the job is routed in a predictable way. GitHub-hosted runners have predefined labels assigned. This example shows how a workflow can use labels to specify the required runner:","jobs:
  example-job:
    runs-on: [self-hosted, linux, x64, gpu]","jobs:
  example-job:
    runs-on: [self-hosted, custom-label]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on a self-hosted runner with a custom label""
",0
605,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Input parameters for the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. key : Required The key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail. path : Required The path(s) on the runner to cache or restore. You can specify a single path, or you can add multiple paths on separate lines. For example:","- name: Cache Gradle packages
  uses: actions/cache@v4
  with:
    path: |
      ~/.gradle/caches
      ~/.gradle/wrapper","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: path/to/dependencies
          key: ${{ runner.os }}-build-${{ hashFiles('**/lockfile') }}
",0
606,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Input parameters for the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. key : Required The key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail. path : Required The path(s) on the runner to cache or restore. You can specify a single path, or you can add multiple paths on separate lines. For example: You can specify either directories or single files, and glob patterns are supported. You can specify absolute paths, or paths relative to the workspace directory. restore-keys : Optional A string containing alternative restore keys, with each restore key placed on a new line. If no cache hit occurs for key , these restore keys are used sequentially in the order provided to find and restore a cache. For example:","restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: path/to/dependencies
          key: ${{ runner.os }}-dependencies-${{ hashFiles('**/lockfile') }}
          restore-keys: |
            ${{ runner.os }}-dependencies-
",0
607,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Example using the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. This example creates a new cache when the packages in package-lock.json file change, or when the runner's operating system changes. The cache key uses contexts and expressions to generate a key that includes the runner's operating system and a SHA-256 hash of the package-lock.json file.","name: Caching with npm
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache node modules
        id: cache-npm
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
        name: List the state of node modules
        continue-on-error: true
        run: npm list

      - name: Install dependencies
        run: npm install

      - name: Build
        run: npm run build

      - name: Test
        run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/cache@v2
      with:
        path: ~/.npm
        key: ${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-
    - run: npm install
",0
608,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Using contexts to create cache keys,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, see Accessing contextual information about workflow runs and Evaluate expressions in workflows and actions . Using expressions to create a key allows you to automatically create a new cache when dependencies change. For example, you can create a key using an expression that calculates the hash of an npm package-lock.json file. So, when the dependencies that make up the package-lock.json file change, the cache key changes and a new cache is automatically created.",npm-${{ hashFiles('package-lock.json') }},"jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache node modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        run: npm install
",0
609,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Using contexts to create cache keys,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, see Accessing contextual information about workflow runs and Evaluate expressions in workflows and actions . Using expressions to create a key allows you to automatically create a new cache when dependencies change. For example, you can create a key using an expression that calculates the hash of an npm package-lock.json file. So, when the dependencies that make up the package-lock.json file change, the cache key changes and a new cache is automatically created. GitHub evaluates the expression hash ""package-lock.json"" to derive the final key .",npm-d5ea0750,"jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache npm dependencies
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
    - name: Install dependencies
      run: npm install
",0
610,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Using the cache action - Using the output of the cache action,"The cache action will attempt the following sequence when restoring a cache: If there is an exact match to the provided key , this is considered a cache hit. If no cache exactly matches the provided key , this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path . For more information about how this is handled, see Cache hits and misses . You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key. You can use the output of the cache action to do something based on whether a cache hit or miss occurred. When an exact match is found for a cache for the specified key , the cache-hit output is set to true . In the example workflow above, there is a step that lists the state of the Node modules if a cache miss occurred:","- if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
  name: List the state of node modules
  continue-on-error: true
  run: npm list","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache Node modules
      id: cache-node-modules
      uses: actions/cache@v3
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    - name: Install dependencies
      if: steps.cache-node-modules.outputs.cache-hit != 'true'
      run: npm install
    - name: List Node modules
      if: steps.cache-node-modules.outputs.cache-hit != 'true'
      run: ls node_modules
",0
611,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Matching a cache key - Example using multiple restore keys,"The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for key , and if there is still no hit, it searches for restore-keys and the version . If there are still no hits in the current branch, the cache action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache . Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation. restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key . You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache.","restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: path/to/dependencies
        key: ${{ runner.os }}-build-${{ hashFiles('**/lockfiles') }}
        restore-keys: |
          ${{ runner.os }}-build-
          ${{ runner.os }}-
",0
612,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Matching a cache key - Example using multiple restore keys,"The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for key , and if there is still no hit, it searches for restore-keys and the version . If there are still no hits in the current branch, the cache action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache . Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation. restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key . You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache. The runner evaluates the expressions, which resolve to these restore-keys :","restore-keys: |
  npm-feature-d5ea0750
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: path/to/dependencies
        key: ${{ runner.os }}-build-${{ hashFiles('**/lockfile') }}
        restore-keys: |
          ${{ runner.os }}-build-
          ${{ runner.os }}-
",0
613,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Matching a cache key - Example using multiple restore keys - Example of search priority,"The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for key , and if there is still no hit, it searches for restore-keys and the version . If there are still no hits in the current branch, the cache action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache . Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation. restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key . You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache. The runner evaluates the expressions, which resolve to these restore-keys : The restore key npm-feature- matches any key that starts with the string npm-feature- . For example, both of the keys npm-feature-fd3052de and npm-feature-a9b253ff match the restore key. The cache with the most recent creation date would be used. The keys in this example are searched in the following order:","key:
  npm-feature-d5ea0750
restore-keys: |
  npm-feature-
  npm-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Cache dependencies
      uses: actions/cache@v2
      with:
        path: ~/.npm
        key: npm-feature-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          npm-feature-
",0
614,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows,Caching dependencies to speed up workflows - Managing caches - Force deleting cache entries,"To manage caches created from your workflows, you can: There are multiple ways to manage caches for your repositories: Using the GitHub web interface, as shown below. Using the REST API. For more information, see REST API endpoints for GitHub Actions cache . Installing the gh cache subcommand to manage your caches from the command line. For more information, see the GitHub CLI documentation . Note  If you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed. Note If you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed. Caches have branch scope restrictions in place, which means some caches have limited usage options. For more information on cache scope restrictions, see Restrictions for accessing a cache , earlier in this article. If caches limited to a specific branch are using a lot of storage quota, it may cause caches from the default branch to be created and deleted at a high frequency. For example, a repository could have many new pull requests opened, each with their own caches that are restricted to that branch. These caches could take up the majority of the cache storage for that repository. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository. In order to prevent cache thrashing when this happens, you can set up workflows to delete caches on a faster cadence than the cache eviction policy will. You can use the GitHub CLI to delete caches for specific branches. The following example workflow uses gh cache to delete up to 100 caches created by a branch once a pull request is closed. To run the following example on cross-repository pull requests or pull requests from forks, you can trigger the workflow with the pull_request_target event. If you do use pull_request_target to trigger the workflow, there are security considerations to keep in mind. For more information, see Events that trigger workflows .","name: cleanup caches by a branch
on:
  pull_request:
    types:
      - closed

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup
        run: |
          echo ""Fetching list of cache key""
          cacheKeysForPR=$(gh cache list --ref $BRANCH --limit 100 --json id --jq '.[].id')

          ## Setting this to not fail the workflow while deleting cache keys.
          set +e
          echo ""Deleting caches...""
          for cacheKey in $cacheKeysForPR
          do
              gh cache delete $cacheKey
          done
          echo ""Done""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          BRANCH: refs/pull/${{ github.event.pull_request.number }}/merge","on:
  pull_request:
    types: [closed]

jobs:
  delete-cache:
    runs-on: ubuntu-latest
    steps:
      - name: Install GitHub CLI
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      - name: Delete caches
        run: gh cache delete --branch ${{ github.head_ref }} --confirm --limit 100
",0
615,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:","on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    concurrency:
      group: my-concurrency-group
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
616,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch: You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:","on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true","jobs:
  example_job:
    concurrency: example-group
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
617,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.","jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
618,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled. Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:","on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
  job-2:
    concurrency:
      group: ci-${{ github.ref }}
      cancel-in-progress: true
",0
619,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using concurrency to cancel any in-progress job or run,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true :","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true
jobs:
  example_job:
    runs-on: ubuntu-latest
    concurrency:
      group: my-concurrency-group
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
620,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using a fallback value,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}
",0
621,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Only cancel in-progress jobs or runs for the current workflow,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow. To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job with concurrency control""
",0
622,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Only cancel in-progress jobs on specific branches,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches. To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: ${{ !startsWith(github.ref, 'refs/heads/release/') }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job""
",0
623,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - About expressions - Example setting an environment variable,"You can use expressions to programmatically set environment variables in workflow files and access contexts. An expression can be any combination of literal values, references to a context, or functions. You can combine literals, context references, and functions using operators. For more information about contexts, see Accessing contextual information about workflow runs . Expressions are commonly used with the conditional if keyword in a workflow file to determine whether a step should run. When an if conditional is true , the step will run. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. ${{ <expression> }} Note  The exception to this rule is when you are using expressions in anifclause, where, optionally, you can usually omit${{and}}. For more information aboutifconditionals, seeWorkflow syntax for GitHub Actions. Note The exception to this rule is when you are using expressions in an if clause, where, optionally, you can usually omit ${{ and }} . For more information about if conditionals, see Workflow syntax for GitHub Actions . Warning  When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions .","env:
  MY_ENV_VAR: ${{ <expression> }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_VAR=${{ github.event_name }}"" >> $GITHUB_ENV
",0
624,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Literals - Example of literals,"As part of an expression, you can use boolean , null , number , or string data types. Note that in conditionals, falsy values ( false , 0 , -0 , """" , '' , null ) are coerced to false and truthy ( true and other non-falsy values) are coerced to true .","env:
  myNull: ${{ null }}
  myBoolean: ${{ false }}
  myIntegerNumber: ${{ 711 }}
  myFloatNumber: ${{ -9.2 }}
  myHexNumber: ${{ 0xff }}
  myExponentialNumber: ${{ -2.99e-2 }}
  myString: Mona the Octocat
  myStringInBraces: ${{ 'It''s open source!' }}","jobs:
  evaluate-expressions:
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate boolean
        run: echo ${{ true && false }}
      - name: Evaluate null
        run: echo ${{ null || true }}
      - name: Evaluate number
        run: echo ${{ 0 || 1 }}
      - name: Evaluate string
        run: echo ${{ '' || 'default' }}
",0
625,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Operators - Example,"Note    GitHub ignores case when comparing strings.steps.<step_id>.outputs.<output_name>evaluates as a string. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. For more information, seeAccessing contextual information about workflow runs.For numerical comparison, thefromJSON()function can be used to convert a string to a number. For more information on thefromJSON()function, seefromJSON. Note GitHub performs loose equality comparisons. If the types do not match, GitHub coerces the type to a number. GitHub casts data types to a number using these conversions: When NaN is one of the operands of any relational comparison ( > , < , >= , <= ), the result is always false . For more information, see the NaN Mozilla docs . GitHub ignores case when comparing strings. Objects and arrays are only considered equal when they are the same instance. GitHub offers ternary operator like behaviour that you can use in expressions. By using a ternary operator in this way, you can dynamically set the value of an environment variable based on a condition, without having to write separate if-else blocks for each possible option.","env:
  MY_ENV_VAR: ${{ github.ref == 'refs/heads/main' && 'value_for_main_branch' || 'value_for_other_branches' }}","jobs:
  evaluate-expressions:
    runs-on: ubuntu-latest
    steps:
      - id: example
        run: echo ""result=$((fromJSON('\""5\""') > 3 ? 'greater' : 'lesser'))"" >> $GITHUB_ENV
",0
626,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Functions - fromJSON - Example returning a JSON object,"GitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions: fromJSON(value) Returns a JSON object or JSON data type for value . You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects. This workflow sets a JSON matrix in one job, and passes it to the next job using an output and fromJSON .","name: build
on: push
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo ""matrix={\""include\"":[{\""project\"":\""foo\"",\""config\"":\""Debug\""},{\""project\"":\""bar\"",\""config\"":\""Release\""}]}"" >> $GITHUB_OUTPUT
  job2:
    needs: job1
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}
    steps:
      - run: echo ""Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}""","jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo ""::set-output name=matrix::{\""include\"":[{\""os\"":\""ubuntu-latest\""},{\""os\"":\""windows-latest\""}]}""

  use-matrix:
    runs-on: ubuntu-latest
    needs: set-matrix
    strategy:
      matrix: ${{ fromJSON(needs.set-matrix.outputs.matrix) }}
    steps:
      - run: echo ""Running on ${{ matrix.os }}""
",0
627,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Functions - fromJSON - Example returning a JSON data type,"GitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions: fromJSON(value) Returns a JSON object or JSON data type for value . You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects. This workflow uses fromJSON to convert environment variables from a string to a Boolean or integer.","name: print
on: push
env:
  continue: true
  time: 3
jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - continue-on-error: ${{ fromJSON(env.continue) }}
        timeout-minutes: ${{ fromJSON(env.time) }}
        run: echo ...","jobs:
  convert_env:
    runs-on: ubuntu-latest
    steps:
      - name: Convert environment variables
        env:
          BOOL_STRING: ""true""
          INT_STRING: ""42""
        run: |
          echo ""Boolean value: ${{ fromJSON(env.BOOL_STRING) }}""
          echo ""Integer value: ${{ fromJSON(env.INT_STRING) }}""
",0
628,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Status check functions - success - Example of success,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true when all previous steps have succeeded.","steps:
  ...
  - name: The job has succeeded
    if: ${{ success() }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: Step 2
        run: echo ""This is step 2""
      - name: Conditional Step
        if: success()
        run: echo ""All previous steps succeeded""
",0
629,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Status check functions - always - Example of always,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Causes the step to always execute, and returns true , even when canceled. The always expression is best used at the step level or on tasks that you expect to run even when a job is canceled. For example, you can use always to send logs even when a job is canceled. Warning  Avoid usingalwaysfor any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative:if: ${{ !cancelled() }} Warning Avoid using always for any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative: if: ${{ !cancelled() }}",if: ${{ always() }},"jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run step always
        run: echo ""This step runs always""
        if: always()
",0
630,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Status check functions - cancelled - Example of cancelled,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true if the workflow was canceled.",if: ${{ cancelled() }},"jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Check if cancelled
        if: cancelled()
        run: echo ""The workflow was cancelled.""
",0
631,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Status check functions - failure - Example of failure,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true when any previous step of a job fails. If you have a chain of dependent jobs, failure() returns true if any ancestor job fails.","steps:
  ...
  - name: The job has failed
    if: ${{ failure() }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: Step 2
        run: exit 1
      - name: Step 3
        if: failure()
        run: echo ""A previous step has failed""
",0
632,https://docs.github.com/en/actions/learn-github-actions/expressions,Evaluate expressions in workflows and actions - Status check functions - failure - failure with conditions - Example of failure with conditions,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true when any previous step of a job fails. If you have a chain of dependent jobs, failure() returns true if any ancestor job fails. You can include extra conditions for a step to run after a failure, but you must still include failure() to override the default status check of success() that is automatically applied to if conditions that don't contain a status check function.","steps:
  ...
  - name: Failing step
    id: demo
    run: exit 1
  - name: The demo step has failed
    if: ${{ failure() && steps.demo.conclusion == 'failure' }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: exit 1
      - name: Step 2
        if: failure()
        run: echo ""This runs because a previous step failed.""
",0
633,https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows,Using GitHub CLI in workflows,"You can script with GitHub CLI in GitHub Actions workflows. NoteTo learn more about GitHub CLI, seeAbout GitHub CLI.  GitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable calledGH_TOKENto a token with the required scopes.  You can execute any GitHub CLI command. For example, this workflow uses thegh issue commentsubcommand to add a comment when an issue is opened. You can also execute API calls through GitHub CLI. For example, this workflow first uses thegh apisubcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step. In the second step, it uses thegh issue createsubcommand to create an issue containing the information from the first step. Note  To learn more about GitHub CLI, seeAbout GitHub CLI. Note To learn more about GitHub CLI, see About GitHub CLI . GitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable called GH_TOKEN to a token with the required scopes. You can execute any GitHub CLI command. For example, this workflow uses the gh issue comment subcommand to add a comment when an issue is opened.","name: Comment when opened
on:
  issues:
    types:
      - opened
jobs:
  comment:
    runs-on: ubuntu-latest
    steps:
      - run: gh issue comment $ISSUE --body ""Thank you for opening this issue!""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE: ${{ github.event.issue.html_url }}","jobs:
  github-cli:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment 1 --body ""This is a comment added by GitHub CLI""
",0
634,https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows,Using GitHub CLI in workflows,"You can also execute API calls through GitHub CLI. For example, this workflow first uses the gh api subcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step. In the second step, it uses the gh issue create subcommand to create an issue containing the information from the first step.","name: Report remaining open issues
on: 
  schedule: 
    # Daily at 8:20 UTC
    - cron: '20 8 * * *'
jobs:
  track_pr:
    runs-on: ubuntu-latest
    steps:
      - run: |
          numOpenIssues=""$(gh api graphql -F owner=$OWNER -F name=$REPO -f query='
            query($name: String!, $owner: String!) {
              repository(owner: $owner, name: $name) {
                issues(states:OPEN){
                  totalCount
                }
              }
            }
          ' --jq '.data.repository.issues.totalCount')""

          echo 'NUM_OPEN_ISSUES='$numOpenIssues >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
      - run: |
          gh issue create --title ""Issue report"" --body ""$NUM_OPEN_ISSUES issues remaining"" --repo $GITHUB_REPOSITORY
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  use-gh-cli:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Query GraphQL API
        run: |
          result=$(gh api graphql -f query='
            {
              viewer {
                login
              }
            }
          ' --jq '.data.viewer.login')
          echo ""result=$result"" >> $GITHUB_ENV
      - name: Create issue
        run: |
          gh issue create --title ""GraphQL API Result"" --body ""The login is ${{ env.result }}""
",0
635,https://docs.github.com/en/actions/quickstart,Quickstart for GitHub Actions - Creating your first workflow,"In your repository on GitHub, create a workflow file called github-actions-demo.yml in the .github/workflows directory. To do this: If the .github/workflows directory already exists, navigate to that directory on GitHub, click Add file , then click Create new file , and name the file github-actions-demo.yml . If your repository doesn't have a .github/workflows directory, go to the main page of the repository on GitHub, click Add file , then click Create new file , and name the file .github/workflows/github-actions-demo.yml . This creates the .github and workflows directories and the github-actions-demo.yml file in a single step. Note  For GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called.github/workflows.  You can give the workflow file any name you like, but you must use.ymlor.yamlas the file name extension. YAML is a markup language that's commonly used for configuration files. Note For GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called .github/workflows . You can give the workflow file any name you like, but you must use .yml or .yaml as the file name extension. YAML is a markup language that's commonly used for configuration files. Copy the following YAML contents into the github-actions-demo.yml file:","name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "" The job was automatically triggered by a ${{ github.event_name }} event.""
      - run: echo "" This job is now running on a ${{ runner.os }} server hosted by GitHub!""
      - run: echo "" The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.""
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "" The ${{ github.repository }} repository has been cloned to the runner.""
      - run: echo "" The workflow is now ready to test your code on the runner.""
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "" This job's status is ${{ job.status }}.""","name: GitHub Actions Demo
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Run a one-line script
      run: echo Hello, world!
    - name: Run a multi-line script
      run: |
        echo Add other actions to build,
        echo test, and deploy your project.
",0
636,https://docs.github.com/en/actions/managing-issues-and-pull-requests/closing-inactive-issues,Closing inactive issues - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Close inactive issues
on:
  schedule:
    - cron: ""30 1 * * *""

jobs:
  close-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/stale@v9
        with:
          days-before-issue-stale: 30
          days-before-issue-close: 14
          stale-issue-label: ""stale""
          stale-issue-message: ""This issue is stale because it has been open for 30 days with no activity.""
          close-issue-message: ""This issue was closed because it has been inactive for 14 days since being marked as stale.""
          days-before-pr-stale: -1
          days-before-pr-close: -1
          repo-token: ${{ secrets.GITHUB_TOKEN }}","name: Close Inactive Issues
on:
  schedule:
    - cron: '0 0 * * *'
jobs:
  close_inactive_issues:
    runs-on: ubuntu-latest
    steps:
      - name: Close inactive issues
        uses: actions/stale@v4
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          days-before-stale: 30
          days-before-close: 7
          stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs.'
          close-issue-message: 'Closing this issue due to inactivity.'
",0
637,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Specifying the Node.js version,"The easiest way to specify a Node.js version is by using the setup-node action provided by GitHub. For more information see, setup-node . The setup-node action takes a Node.js version as an input and configures that version on the runner. The setup-node action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. Using the setup-node action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to PATH . The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in node-version . The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the node-version array creates a job that runs the same steps. Each job can access the value defined in the matrix node-version array using the matrix context. The setup-node action uses the context as the node-version input. The setup-node action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs .","strategy:
  matrix:
    node-version: ['18.x', '20.x']

steps:
- uses: actions/checkout@v4
- name: Use Node.js ${{ matrix.node-version }}
  uses: actions/setup-node@v4
  with:
    node-version: ${{ matrix.node-version }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - run: npm test
",0
638,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Specifying the Node.js version,"The easiest way to specify a Node.js version is by using the setup-node action provided by GitHub. For more information see, setup-node . The setup-node action takes a Node.js version as an input and configures that version on the runner. The setup-node action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. Using the setup-node action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to PATH . The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in node-version . The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the node-version array creates a job that runs the same steps. Each job can access the value defined in the matrix node-version array using the matrix context. The setup-node action uses the context as the node-version input. The setup-node action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs . Alternatively, you can build and test with exact Node.js versions.","strategy:
  matrix:
    node-version: ['10.17.0', '17.9.0']","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm install
    - run: npm test
",0
639,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Specifying the Node.js version,"The easiest way to specify a Node.js version is by using the setup-node action provided by GitHub. For more information see, setup-node . The setup-node action takes a Node.js version as an input and configures that version on the runner. The setup-node action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. Using the setup-node action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to PATH . The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in node-version . The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the node-version array creates a job that runs the same steps. Each job can access the value defined in the matrix node-version array using the matrix context. The setup-node action uses the context as the node-version input. The setup-node action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs . Alternatively, you can build and test with exact Node.js versions. Or, you can build and test using a single version of Node.js too.","name: Node.js CI

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm install
    - run: npm test
",0
640,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using npm,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the versions in the package-lock.json or npm-shrinkwrap.json file and prevents updates to the lock file. Using npm ci is generally faster than running npm install . For more information, see npm ci and Introducing npm ci for faster, more reliable builds .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: npm ci","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm ci
",0
641,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using npm,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the versions in the package-lock.json or npm-shrinkwrap.json file and prevents updates to the lock file. Using npm ci is generally faster than running npm install . For more information, see npm ci and Introducing npm ci for faster, more reliable builds . Using npm install installs the dependencies defined in the package.json file. For more information, see npm install .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: npm install","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm ci
      - name: Build
        run: npm run build
      - name: Test
        run: npm test
",0
642,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using Yarn,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the dependencies defined in the yarn.lock file and prevents updates to the yarn.lock file. For more information, see yarn install .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: yarn --frozen-lockfile","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: yarn install --frozen-lockfile
",0
643,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using Yarn,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the dependencies defined in the yarn.lock file and prevents updates to the yarn.lock file. For more information, see yarn install . Alternatively, you can install the dependencies defined in the package.json file.","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: yarn","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: yarn install --frozen-lockfile
",0
644,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using a private registry and creating the .npmrc file,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can use the setup-node action to create a local .npmrc file on the runner that configures the default registry and scope. The setup-node action also accepts an authentication token as input, used to access private registries or publish node packages. For more information, see setup-node . To authenticate to your private registry, you'll need to store your npm authentication token as a secret. For example, create a repository secret called NPM_TOKEN . For more information, see Using secrets in GitHub Actions . In the example below, the secret NPM_TOKEN stores the npm authentication token. The setup-node action configures the .npmrc file to read the npm authentication token from the NODE_AUTH_TOKEN environment variable. When using the setup-node action to create an .npmrc file, you must set the NODE_AUTH_TOKEN environment variable with the secret that contains your npm authentication token. Before installing dependencies, use the setup-node action to create the .npmrc file. The action has two input parameters. The node-version parameter sets the Node.js version, and the registry-url parameter sets the default registry. If your package registry uses scopes, you must use the scope parameter. For more information, see npm-scope .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    always-auth: true
    node-version: '20.x'
    registry-url: https://registry.npmjs.org
    scope: '@octocat'
- name: Install dependencies
  run: npm ci
  env:
    NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'
          registry-url: 'https://registry.npmjs.org'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      - run: npm install
      - run: npm test
",0
645,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example caching dependencies,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-node action . The following example caches dependencies for npm.","steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'
- run: npm install
- run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v3
        with:
          node-version: '14'
          cache: 'npm'
      - run: npm install
      - run: npm test
",0
646,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example caching dependencies,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-node action . The following example caches dependencies for npm. The following example caches dependencies for Yarn.","steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'yarn'
- run: yarn
- run: yarn test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: '14'
        cache: 'npm'
    - run: npm install
    - run: npm test

  build-yarn:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: '14'
        cache: 'yarn'
    - run: yarn install
    - run: yarn test
",0
647,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example caching dependencies,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-node action . The following example caches dependencies for npm. The following example caches dependencies for Yarn. The following example caches dependencies for pnpm (v6.10+).","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# NOTE: pnpm caching support requires pnpm version >= 6.10.0

steps:
- uses: actions/checkout@v4
- uses: pnpm/action-setup@0609f0983b7a228f052f81ef4c3d6510cae254ad
  with:
    version: 6.10.0
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'pnpm'
- run: pnpm install
- run: pnpm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
    - run: npm install
    - run: npm test

  build-yarn:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'yarn'
    - run: yarn install
    - run: yarn test

  build-pnpm:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'pnpm'
    - run: pnpm install
    - run: pnpm test
",0
648,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs,Building and testing Node.js - Building and testing your code,"You can use the same commands that you use locally to build and test your code. For example, if you run npm run build to run build steps defined in your package.json file and npm test to run your test suite, you would add those commands in your workflow file.","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- run: npm install
- run: npm run build --if-present
- run: npm test","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      - run: npm install
      - run: npm run build
      - run: npm test
",0
649,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to Docker Hub,"Note  Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker. Note Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker. Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when the release event triggers with the published activity type. In the example workflow below, we use the Docker login-action and build-push-action actions to build the Docker image and, if the build succeeds, push the built image to Docker Hub. To push to Docker Hub, you will need to have a Docker Hub account, and have a Docker Hub repository created. For more information, see Pushing a Docker container image to Docker Hub in the Docker documentation. The login-action options required for Docker Hub are: The metadata-action option required for Docker Hub is: The build-push-action options required for Docker Hub are:","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Publish Docker image

on:
  release:
    types: [published]

jobs:
  push_to_registry:
    name: Push Docker image to Docker Hub
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
      attestations: write
      id-token: write
    steps:
      - name: Check out the repo
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: my-docker-hub-namespace/my-docker-hub-repository

      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: index.docker.io/my-docker-hub-namespace/my-docker-hub-repository
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true","on:
  release:
    types: [published]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/my-repo:${{ github.ref_name }}
",0
650,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds.",name: Create and publish a Docker image,"name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
651,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch calledrelease.","on:
  push:
    branches: ['release']","on:
  push:
    branches: ['release']

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
652,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.","env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
653,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.","jobs:
  build-and-push-image:
    runs-on: ubuntu-latest","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
654,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.","permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
655,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the GITHUB_TOKEN for the actions in this job.","steps:
      - name: Checkout repository
        uses: actions/checkout@v4","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
656,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the GITHUB_TOKEN for the actions in this job. Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.","- name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
657,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the GITHUB_TOKEN for the actions in this job. Uses the docker/login-action action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels.","- name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
658,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the GITHUB_TOKEN for the actions in this job. Uses the docker/login-action action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step uses docker/metadata-action to extract tags and labels that will be applied to the specified image. The id ""meta"" allows the output of this step to be referenced in a subsequent step. The images value provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step.","- name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
659,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the GITHUB_TOKEN for the actions in this job. Uses the docker/login-action action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step uses docker/metadata-action to extract tags and labels that will be applied to the specified image. The id ""meta"" allows the output of this step to be referenced in a subsequent step. The images value provides the base name for the tags and labels. This step uses the docker/build-push-action action to build the image, based on your repository's Dockerfile . If the build succeeds, it pushes the image to GitHub Packages.
It uses the context parameter to define the build's context as the set of files located in the specified path. For more information, see Usage in the README of the docker/build-push-action repository.
It uses the tags and labels parameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds.","- name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
660,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to GitHub Packages,"Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch. In the example workflow below, we use the Docker login-action , metadata-action , and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages. The login-action options required for GitHub Packages are: The metadata-action option required for GitHub Packages is: The build-push-action options required for GitHub Packages are: Note    This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning. Note BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true  Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. BesideInline#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true Beside Inline Configures this workflow to run every time a change is pushed to the branch calledrelease. Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to theGITHUB_TOKENfor the actions in this job.  Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid""meta"" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels. This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.
It uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.
It uses thetagsandlabelsparameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds. Configures this workflow to run every time a change is pushed to the branch called release . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the GITHUB_TOKEN for the actions in this job. Uses the docker/login-action action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step uses docker/metadata-action to extract tags and labels that will be applied to the specified image. The id ""meta"" allows the output of this step to be referenced in a subsequent step. The images value provides the base name for the tags and labels. This step uses the docker/build-push-action action to build the image, based on your repository's Dockerfile . If the build succeeds, it pushes the image to GitHub Packages.
It uses the context parameter to define the build's context as the set of files located in the specified path. For more information, see Usage in the README of the docker/build-push-action repository.
It uses the tags and labels parameters to tag and label the image with the output from the ""meta"" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see Using artifact attestations to establish provenance for builds .","#
name: Create and publish a Docker image

# Configures this workflow to run every time a change is pushed to the branch called `release`.
on:
  push:
    branches: ['release']

# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      #
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` ""meta"" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.
      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.
      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the ""meta"" step.
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true","name: Create and publish a Docker image
on:
  push:
    branches: ['release']
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true
",0
661,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images,Publishing Docker images - Publishing images to Docker Hub and GitHub Packages,"In a single workflow, you can publish your Docker image to multiple registries by using the login-action and build-push-action actions for each registry. The following example workflow uses the steps from the previous sections ( Publishing images to Docker Hub and Publishing images to GitHub Packages ) to create a single workflow that pushes to both registries.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Publish Docker image

on:
  release:
    types: [published]

jobs:
  push_to_registries:
    name: Push Docker image to multiple registries
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
      attestations: write
      id-token: write
    steps:
      - name: Check out the repo
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Log in to the Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        with:
          images: |
            my-docker-hub-namespace/my-docker-hub-repository
            ghcr.io/${{ github.repository }}

      - name: Build and push Docker images
        id: push
        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ghcr.io/${{ github.repository }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Build and push to Docker Hub
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ secrets.DOCKERHUB_USERNAME }}/my-image:latest
    - name: Build and push to GitHub Packages
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ghcr.io/${{ github.repository_owner }}/my-image:latest
",0
662,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Using workflow commands to access toolkit functions - Example: Creating an annotation for an error,"The actions/toolkit includes a number of functions that can be executed as workflow commands. Use the :: syntax to run the workflow commands within your YAML file; these commands are then sent to the runner over stdout . For example, instead of using code to create an error annotation, as below: You can use the error command in your workflow to create the same error annotation:","- name: Create annotation for build error
        run: echo ""::error file=app.js,line=1::Missing semicolon""","jobs:
  create-error-annotation:
    runs-on: ubuntu-latest
    steps:
      - name: Create error annotation
        run: echo ""::error file=app.js,line=10,col=15::Syntax error""
",0
663,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Grouping log lines - Example: Grouping log lines,"Creates an expandable group in the log. To create a group, use the group command and specify a title . Anything you print to the log between the group and endgroup commands is nested inside an expandable entry in the log.","jobs:
  bash-example:
    runs-on: ubuntu-latest
    steps:
      - name: Group of log lines
        run: |
            echo ""::group::My title""
            echo ""Inside group""
            echo ""::endgroup::""","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Group log lines
        run: |
          echo ""::group::My expandable group""
          echo ""This is inside the group""
          echo ""Another line inside the group""
          echo ""::endgroup::""
",0
664,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking an environment variable,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. When you print the variable MY_NAME or the value ""Mona The Octocat"" in the log, you'll see ""***"" instead of ""Mona The Octocat"" .","jobs:
  bash-example:
    runs-on: ubuntu-latest
    env:
      MY_NAME: ""Mona The Octocat""
    steps:
      - name: bash-version
        run: echo ""::add-mask::$MY_NAME""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Mask environment variable
        run: |
          echo ""::add-mask::$MY_NAME""
          echo ""My name is $MY_NAME""
        env:
          MY_NAME: ""Mona The Octocat""
",0
665,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking a generated output within a single job,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you do not need to pass your secret from one job to another job, you can:","on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        run: |
          the_secret=$((RANDOM))
          echo ""::add-mask::$the_secret""
          echo ""secret-number=$the_secret"" >> ""$GITHUB_OUTPUT""
      - name: Use that secret output (protected by a mask)
        run: |
          echo ""the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Generate secret
        id: generate_secret
        run: echo ""SECRET_VALUE=super_secret_value"" >> $GITHUB_ENV

      - name: Mask secret
        run: echo ""::add-mask::$SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}

      - name: Use secret
        run: echo ""The secret is $SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}
",0
666,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking and passing a secret between jobs or workflows - Workflow,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you want to pass a masked secret between jobs or workflows, you should store the secret in a store and then retrieve it in the subsequent job or workflow. Note  This workflow uses an imaginary secret store,secret-store, which has imaginary commandsstore-secretandretrieve-secret.some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29is an imaginary action that installs thesecret-storeapplication and configures it to connect to aninstancewithcredentials. Note This workflow uses an imaginary secret store, secret-store , which has imaginary commands store-secret and retrieve-secret . some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29 is an imaginary action that installs the secret-store application and configures it to connect to an instance with credentials .","on: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    outputs:
      handle: ${{ steps.generate-secret.outputs.handle }}
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      id: generate-secret
      shell: bash
      run: |
        GENERATED_SECRET=$((RANDOM))
        echo ""::add-mask::$GENERATED_SECRET""
        SECRET_HANDLE=$(secret-store store-secret ""$GENERATED_SECRET"")
        echo ""handle=$SECRET_HANDLE"" >> ""$GITHUB_OUTPUT""
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: bash
      run: |
        SECRET_HANDLE=""${{ needs.secret-generator.outputs.handle }}""
        RETRIEVED_SECRET=$(secret-store retrieve-secret ""$SECRET_HANDLE"")
        echo ""::add-mask::$RETRIEVED_SECRET""
        echo ""We retrieved our masked secret: $RETRIEVED_SECRET""","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Store secret
        run: echo ""my-secret-value"" | store-secret my-secret-key
      - name: Mask secret
        run: echo ""::add-mask::my-secret-value""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Retrieve secret
        run: retrieve-secret my-secret-key
",0
667,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Stopping and starting workflow commands - Example: Stopping and starting workflow commands,"Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command. For example, you could stop logging to output an entire script that has comments. To stop the processing of workflow commands, pass a unique token to stop-commands . To resume processing workflow commands, pass the same token that you used to stop workflow commands. Warning  Make sure the token you're using is randomly generated and unique for each run. Warning Make sure the token you're using is randomly generated and unique for each run.","jobs:
  workflow-command-job:
    runs-on: ubuntu-latest
    steps:
      - name: Disable workflow commands
        run: |
          echo '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          stopMarker=$(uuidgen)
          echo ""::stop-commands::$stopMarker""
          echo '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          echo ""::$stopMarker::""
          echo '::warning:: This is a warning again, because stop-commands has been turned off.'","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Stop workflow commands
        run: echo ""::stop-commands::${{ secrets.UNIQUE_TOKEN }}""

      - name: Log script
        run: |
          echo ""This is a script with comments""
          echo ""# This is a comment""
          echo ""echo Hello World""

      - name: Start workflow commands
        run: echo ""::${{ secrets.UNIQUE_TOKEN }}::""
",0
668,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how:","name: Example Workflow for Environment Files

on: push

jobs:
  set_and_use_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_ENV_VAR=myValue"" >> $GITHUB_ENV

      - name: Use environment variable
        run: |
          echo ""The value of MY_ENV_VAR is $MY_ENV_VAR""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variable
        run: echo ""MY_VAR=HelloWorld"" >> $GITHUB_ENV

      - name: Use environment variable
        run: echo ""The value of MY_VAR is $MY_VAR""
",0
669,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how: Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names:","steps:
  - name: Store build timestamp
    run: echo ""BUILD_TIME=$(date +'%T')"" >> $GITHUB_ENV

  - name: Deploy using stored timestamp
    run: echo ""Deploying at $BUILD_TIME""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variables
        run: |
          echo ""BUILD_TIMESTAMP=$(date +%Y%m%d%H%M%S)"" >> $GITHUB_ENV
          echo ""COMMIT_SHA=$(git rev-parse HEAD)"" >> $GITHUB_ENV
          echo ""ARTIFACT_NAME=my-artifact"" >> $GITHUB_ENV

      - name: Use environment variables
        run: |
          echo ""Build Timestamp: $BUILD_TIMESTAMP""
          echo ""Commit SHA: $COMMIT_SHA""
          echo ""Artifact Name: $ARTIFACT_NAME""
",0
670,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Setting an environment variable - Example of writing an environment variable to GITHUB_ENV,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable.","steps:
  - name: Set the value
    id: step_one
    run: |
      echo ""action_state=yellow"" >> ""$GITHUB_ENV""
  - name: Use the value
    id: step_two
    run: |
      printf '%s\n' ""$action_state"" # This will output 'yellow'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_VARIABLE=some_value"" >> $GITHUB_ENV
      - name: Use environment variable
        run: echo $MY_VARIABLE
",0
671,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Setting an environment variable - Multiline strings - Example of a multiline string,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable. For multiline strings, you may use a delimiter with the following syntax. Warning  Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. Warning Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. This example uses EOF as the delimiter, and sets the JSON_RESPONSE environment variable to the value of the curl response.","steps:
  - name: Set the value in bash
    id: step_one
    run: |
      {
        echo 'JSON_RESPONSE<<EOF'
        curl https://example.com
        echo EOF
      } >> ""$GITHUB_ENV""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set JSON_RESPONSE environment variable
        run: |
          echo ""JSON_RESPONSE<<EOF"" >> $GITHUB_ENV
          echo '{ ""key"": ""value"", ""another_key"": ""another_value"" }' >> $GITHUB_ENV
          echo ""EOF"" >> $GITHUB_ENV
",0
672,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Setting an output parameter - Example of setting an output parameter,Sets a step's output parameter. Note that the step will need an id to be defined to later retrieve the output value. You can set multi-line output values with the same technique used in the Multiline strings section to define multi-line environment variables. This example demonstrates how to set the SELECTED_COLOR output parameter and later retrieve it:,"- name: Set color
        id: color-selector
        run: echo ""SELECTED_COLOR=green"" >> ""$GITHUB_OUTPUT""
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: echo ""The selected color is $SELECTED_COLOR""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - id: set-output
        run: echo ""SELECTED_COLOR=blue"" >> $GITHUB_ENV
      - run: echo ""The selected color is ${{ steps.set-output.outputs.SELECTED_COLOR }}""
",0
673,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Adding a job summary - Multiline Markdown content - Example of multiline Markdown content,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. For multiline Markdown content, you can use >> to continuously append content for the current step. With every append operation, a newline character is automatically added.","- name: Generate list using Markdown
  run: |
    echo ""This is the lead in sentence for the list"" >> $GITHUB_STEP_SUMMARY
    echo """" >> $GITHUB_STEP_SUMMARY # this is a blank line
    echo ""- Lets add a bullet point"" >> $GITHUB_STEP_SUMMARY
    echo ""- Lets add a second bullet point"" >> $GITHUB_STEP_SUMMARY
    echo ""- How about a third one?"" >> $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: |
          echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY
          echo ""This is a multiline"" >> $GITHUB_STEP_SUMMARY
          echo ""Markdown content"" >> $GITHUB_STEP_SUMMARY
",0
674,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Adding a job summary - Overwriting job summaries - Example of overwriting job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To clear all content for the current step, you can use > to overwrite any previously added content in Bash, or remove -Append in PowerShell","- name: Overwrite Markdown
  run: |
    echo ""Adding some Markdown content"" >> $GITHUB_STEP_SUMMARY
    echo ""There was an error, we need to clear the previous Markdown with some new content."" > $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" > $GITHUB_STEP_SUMMARY
      - name: Overwrite job summary
        run: echo ""## Overwritten Job Summary"" > $GITHUB_STEP_SUMMARY
",0
675,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions,Workflow commands for GitHub Actions - Adding a job summary - Removing job summaries - Example of removing job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To completely remove a summary for the current step, the file that GITHUB_STEP_SUMMARY references can be deleted.","- name: Delete all summary content
  run: |
    echo ""Adding Markdown content that we want to remove before the step ends"" >> $GITHUB_STEP_SUMMARY
    rm $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY

      - name: Remove job summary
        run: rm $GITHUB_STEP_SUMMARY
",0
676,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform,Configuring OpenID Connect in Google Cloud Platform - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
677,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform,Configuring OpenID Connect in Google Cloud Platform - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
",0
678,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform,Configuring OpenID Connect in Google Cloud Platform - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The google-github-actions/auth action receives a JWT from the GitHub OIDC provider, and then requests an access token from GCP. For more information, see the GCP documentation . This example has a job called Get_OIDC_ID_token that uses actions to request a list of services from GCP. This action exchanges a GitHub OIDC token for a Google Cloud access token, using Workload Identity Federation .","name: List services in GCP
on:
  pull_request:
    branches:
      - main

permissions:
  id-token: write

jobs:
  Get_OIDC_ID_token:
    runs-on: ubuntu-latest
    steps:
    - id: 'auth'
      name: 'Authenticate to GCP'
      uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0'
      with:
          create_credentials_file: 'true'
          workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER'
          service_account: 'SERVICE-ACCOUNT'
    - id: 'gcloud'
      name: 'gcloud'
      run: |-
        gcloud auth login --brief --cred-file=""${{ steps.auth.outputs.credentials_file_path }}""
        gcloud services list","jobs:
  Get_OIDC_ID_token:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: 'projects/YOUR_PROJECT_NUMBER/locations/global/workloadIdentityPools/YOUR_POOL_ID/providers/YOUR_PROVIDER_ID'
          service_account: 'YOUR_SERVICE_ACCOUNT_EMAIL'

      - name: List GCP services
        run: gcloud services list
",0
679,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow,Storing and sharing data from a workflow - Uploading build and test artifacts - Example,"You can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, see About continuous integration with GitHub Actions . The output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage. You can use the upload-artifact action to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided then artifact will be used as the default name. For more information on syntax, see the actions/upload-artifact action. For example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in the dist directory, you would deploy the files in the dist directory to your web application server if all tests completed successfully. This example shows you how to create a workflow for a Node.js project that builds the code in the src directory and runs the tests in the tests directory. You can assume that running npm test produces a code coverage report named code-coverage.html stored in the output/test/ directory. The workflow uploads the production artifacts in the dist directory, but excludes any markdown files. It also uploads the code-coverage.html report as another artifact.","name: Node CI

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: npm install, build, and test
        run: |
          npm install
          npm run build --if-present
          npm test
      - name: Archive production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-without-markdown
          path: |
            dist
            !dist/**/*.md
      - name: Archive code coverage results
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-report
          path: output/test/code-coverage.html","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Install dependencies
      run: npm install
    - name: Build
      run: npm run build
    - name: Test
      run: npm test
    - name: Upload production artifacts
      uses: actions/upload-artifact@v3
      with:
        name: production-artifacts
        path: dist/
        exclude: '**/*.md'
    - name: Upload code coverage report
      uses: actions/upload-artifact@v3
      with:
        name: code-coverage-report
        path: output/test/code-coverage.html
",0
680,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow,Storing and sharing data from a workflow - Configuring a custom artifact retention period,"You can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can use retention-days with the upload-artifact action. This example demonstrates how to set a custom retention period of 5 days for the artifact named my-artifact :","- name: 'Upload Artifact'
    uses: actions/upload-artifact@v4
    with:
      name: my-artifact
      path: my_file.txt
      retention-days: 5","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Create a file to upload
        run: echo ""This is a test file"" > my-artifact.txt
      - name: Upload artifact with custom retention
        uses: actions/upload-artifact@v3
        with:
          name: my-artifact
          path: my-artifact.txt
          retention-days: 5
",0
681,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow,Storing and sharing data from a workflow - Downloading or deleting artifacts - Downloading artifacts during a workflow run,"During a workflow run, you can use the download-artifact action to download artifacts that were previously uploaded in the same workflow run. After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see Downloading workflow artifacts , Removing workflow artifacts , and REST API endpoints for GitHub Actions artifacts . The actions/download-artifact action can be used to download previously uploaded artifacts during a workflow run. Note  If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. SeeDownload Artifacts from other Workflow Runs or Repositoriesin the documentation for thedownload-artifactaction. Note If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. See Download Artifacts from other Workflow Runs or Repositories in the documentation for the download-artifact action. Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is artifact .","- name: Download a single artifact
  uses: actions/download-artifact@v4
  with:
    name: my-artifact","jobs:
  download_artifact:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v3
        with:
          name: artifact
",0
682,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow,Storing and sharing data from a workflow - Downloading or deleting artifacts - Downloading artifacts during a workflow run,"During a workflow run, you can use the download-artifact action to download artifacts that were previously uploaded in the same workflow run. After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see Downloading workflow artifacts , Removing workflow artifacts , and REST API endpoints for GitHub Actions artifacts . The actions/download-artifact action can be used to download previously uploaded artifacts during a workflow run. Note  If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. SeeDownload Artifacts from other Workflow Runs or Repositoriesin the documentation for thedownload-artifactaction. Note If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. See Download Artifacts from other Workflow Runs or Repositories in the documentation for the download-artifact action. Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is artifact . You can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts.","- name: Download all workflow run artifacts
  uses: actions/download-artifact@v4","jobs:
  download_artifacts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v3
        with:
          name: artifact
",0
683,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow,Storing and sharing data from a workflow - Passing data between jobs in a workflow,"You can use the upload-artifact and download-artifact actions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see the actions/upload-artifact and download-artifact actions. Jobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses the needs keyword to ensure that job_1 , job_2 , and job_3 run sequentially. For example, job_2 requires job_1 using the needs: job_1 syntax. Job 1 performs these steps: Job 2 uses the result in the previous job: Job 3 displays the result uploaded in the previous job: The full math operation performed in this workflow example is (3 + 7) x 9 = 90 .","name: Share data between jobs

on: [push]

jobs:
  job_1:
    name: Add 3 and 7
    runs-on: ubuntu-latest
    steps:
      - shell: bash
        run: |
          expr 3 + 7 > math-homework.txt
      - name: Upload math result for job 1
        uses: actions/upload-artifact@v4
        with:
          name: homework_pre
          path: math-homework.txt

  job_2:
    name: Multiply by 9
    needs: job_1
    runs-on: windows-latest
    steps:
      - name: Download math result for job 1
        uses: actions/download-artifact@v4
        with:
          name: homework_pre
      - shell: bash
        run: |
          value=`cat math-homework.txt`
          expr $value \* 9 > math-homework.txt
      - name: Upload math result for job 2
        uses: actions/upload-artifact@v4
        with:
          name: homework_final
          path: math-homework.txt

  job_3:
    name: Display results
    needs: job_2
    runs-on: macOS-latest
    steps:
      - name: Download math result for job 2
        uses: actions/download-artifact@v4
        with:
          name: homework_final
      - name: Print the final result
        shell: bash
        run: |
          value=`cat math-homework.txt`
          echo The result is $value","jobs:
  job_1:
    runs-on: ubuntu-latest
    steps:
      - name: Perform addition
        run: echo $((3 + 7)) > result.txt
      - name: Upload result
        uses: actions/upload-artifact@v3
        with:
          name: addition-result
          path: result.txt

  job_2:
    runs-on: ubuntu-latest
    needs: job_1
    steps:
      - name: Download addition result
        uses: actions/download-artifact@v3
        with:
          name: addition-result
      - name: Perform multiplication
        run: |
          result=$(cat result.txt)
          echo $((result * 9)) > final-result.txt
      - name: Upload final result
        uses: actions/upload-artifact@v3
        with:
          name: final-result
          path: final-result.txt

  job_3:
    runs-on: ubuntu-latest
    needs: job_2
    steps:
      - name: Download final result
        uses: actions/download-artifact@v3
        with:
          name: final-result
      - name: Display result
        run: cat final-result.txt
",0
684,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Configuring the runner scale set name,"ARC offers several advanced configuration options. Note  Runner scale set names are unique within the runner group they belong to. If you want to deploy multiple runner scale sets with the same name, they must belong to different runner groups. Note Runner scale set names are unique within the runner group they belong to. If you want to deploy multiple runner scale sets with the same name, they must belong to different runner groups. To configure the runner scale set name, you can define an INSTALLATION_NAME or set the value of runnerScaleSetName in your copy of the values.yaml file.","## The name of the runner scale set to create, which defaults to the Helm release name
runnerScaleSetName: ""my-runners""","jobs:
  deploy-runner-scale-set:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Configure runner scale set name
        run: |
          echo ""runnerScaleSetName: my-runner-scale-set"" >> values.yaml
      - name: Deploy runner scale set
        run: |
          kubectl apply -f values.yaml
",0
685,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Choosing runner destinations,"ARC offers several advanced configuration options. Runner scale sets can be deployed at the repository, organization, or enterprise levels. To deploy runner scale sets to a specific level, set the value of githubConfigUrl in your copy of the values.yaml to the URL of your repository, organization, or enterprise. The following example shows how to configure ARC to add runners to octo-org/octo-repo .","githubConfigUrl: ""https://github.com/octo-ent/octo-org/octo-repo""","jobs:
  deploy-runner-scale-set:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Deploy runner scale set
        uses: actions-runner-controller/actions-runner-controller@v0.21.0
        with:
          githubConfigUrl: https://github.com/octo-org/octo-repo
",0
686,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Using a GitHub App for authentication - Option 1: Create a Kubernetes secret (recommended),"ARC offers several advanced configuration options. If you are not using enterprise-level runners, you can use GitHub Apps to authenticate with the GitHub API. For more information, see Authenticating to the GitHub API . Note  Given the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead. Note Given the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead. You can either create a Kubernetes secret, or specify values in your values.yaml file. Once you have created your GitHub App, create a Kubernetes secret and pass the reference to that secret in your copy of the values.yaml file. Note  Create the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller. Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller . In your copy of the values.yaml pass the secret name as a reference.",githubConfigSecret: pre-defined-secret,"jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Kubernetes secret
        run: |
          kubectl create secret generic github-app-secret \
            --from-literal=app_id=<your-github-app-id> \
            --from-literal=private_key=<your-private-key> \
            --namespace=arc-runners
",0
687,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Using a GitHub App for authentication - Option 2: Specify values in your values.yaml file,"ARC offers several advanced configuration options. If you are not using enterprise-level runners, you can use GitHub Apps to authenticate with the GitHub API. For more information, see Authenticating to the GitHub API . Note  Given the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead. Note Given the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead. You can either create a Kubernetes secret, or specify values in your values.yaml file. Alternatively, you can specify the values of app_id , installation_id and private_key in your copy of the values.yaml file.","## githubConfigSecret is the Kubernetes secret to use when authenticating with GitHub API.
## You can choose to use a GitHub App or a personal access token (classic)
githubConfigSecret:
  ## GitHub Apps Configuration
  ## IDs must be strings, use quotes
  github_app_id: ""123456""
  github_app_installation_id: ""654321""
  github_app_private_key: |
    -----BEGIN RSA PRIVATE KEY-----
    ...
    HkVN9...
    ...
    -----END RSA PRIVATE KEY-----","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Kubernetes
        uses: azure/setup-kubectl@v1
        with:
          version: 'latest'

      - name: Deploy ARC with GitHub App authentication
        run: |
          helm upgrade --install arc actions-runner-controller/actions-runner-controller \
            --namespace actions-runner-system \
            --set githubApp.app_id=${{ secrets.GITHUB_APP_ID }} \
            --set githubApp.installation_id=${{ secrets.GITHUB_INSTALLATION_ID }} \
            --set githubApp.private_key=${{ secrets.GITHUB_PRIVATE_KEY }}
",0
688,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Managing access with runner groups,"ARC offers several advanced configuration options. You can use runner groups to control which organizations or repositories have access to your runner scale sets. For more information on runner groups, see Managing access to self-hosted runners using groups . To add a runner scale set to a runner group, you must already have a runner group created. Then set the runnerGroup property in your copy of the values.yaml file. The following example adds a runner scale set to the Octo-Group runner group.","runnerGroup: ""Octo-Group""","jobs:
  deploy-runner-scale-set:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Deploy runner scale set
        uses: actions/arc-deploy@v1
        with:
          runnerGroup: Octo-Group
",0
689,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Configuring an outbound proxy,"ARC offers several advanced configuration options. To force HTTP traffic for the controller and runners to go through your outbound proxy, set the following properties in your Helm chart.","proxy:
  http:
    url: http://proxy.com:1234
    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys
  https:
    url: http://proxy.com:1234
    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys
  noProxy:
    - example.com
    - example.org","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Deploy ARC with Helm
      run: |
        helm upgrade --install arc actions-runner-controller/actions-runner-controller \
          --namespace actions-runner-system \
          --set controller.manager.env[0].name=HTTP_PROXY \
          --set controller.manager.env[0].value=http://your-proxy:8080 \
          --set controller.manager.env[1].name=HTTPS_PROXY \
          --set controller.manager.env[1].value=http://your-proxy:8080 \
          --set controller.manager.env[2].name=NO_PROXY \
          --set controller.manager.env[2].value=your-no-proxy-list
",0
690,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Setting the maximum and minimum number of runners - Example: Unbounded number of runners,"ARC offers several advanced configuration options. The maxRunners and minRunners properties provide you with a range of options to customize your ARC setup. Note  ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. Note ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. If you comment out both the maxRunners and minRunners properties, ARC will scale up to the number of jobs assigned to the runner scale set and will scale down to 0 if there aren't any active jobs.","## maxRunners is the max number of runners the auto scaling runner set will scale up to.
# maxRunners: 0

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
# minRunners: 0","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy runner scale sets
        uses: actions/runner-controller@v0.1
        with:
          maxRunners: 
          minRunners: 
",0
691,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Setting the maximum and minimum number of runners - Example: Minimum number of runners,ARC offers several advanced configuration options. The maxRunners and minRunners properties provide you with a range of options to customize your ARC setup. Note  ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. Note ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. You can set the minRunners property to any number and ARC will make sure there is always the specified number of runners active and available to take jobs assigned to the runner scale set at all times.,"## maxRunners is the max number of runners the auto scaling runner set will scale up to.
# maxRunners: 0

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 20","jobs:
  deploy-runner-scale-sets:
    runs-on: ubuntu-latest
    steps:
      - name: Set minRunners and maxRunners
        run: |
          kubectl patch runnerscaleset <your-runner-scale-set-name> --type='json' -p='[{""op"": ""replace"", ""path"": ""/spec/minRunners"", ""value"": <min-number>}, {""op"": ""replace"", ""path"": ""/spec/maxRunners"", ""value"": <max-number>}]'
",0
692,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Setting the maximum and minimum number of runners - Example: Set maximum and minimum number of runners,"ARC offers several advanced configuration options. The maxRunners and minRunners properties provide you with a range of options to customize your ARC setup. Note  ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. Note ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. In this configuration, Actions Runner Controller will scale up to a maximum of 30 runners and will scale down to 20 runners when the jobs are complete. Note  The value ofminRunnerscan never exceed that ofmaxRunners, unlessmaxRunnersis commented out. The value of minRunners can never exceed that of maxRunners , unless maxRunners is commented out.","## maxRunners is the max number of runners the auto scaling runner set will scale up to.
maxRunners: 30

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 20","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Set max and min runners
        run: |
          kubectl patch configmap arc-config -n actions-runner-system --type merge -p '{""data"":{""maxRunners"":""30"",""minRunners"":""20""}}'
",0
693,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Setting the maximum and minimum number of runners - Example: Jobs queue draining,"ARC offers several advanced configuration options. The maxRunners and minRunners properties provide you with a range of options to customize your ARC setup. Note  ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. Note ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule. In certain scenarios you might want to drain the jobs queue to troubleshoot a problem or to perform maintenance on your cluster. If you set both properties to 0 , Actions Runner Controller will not create new runner pods when new jobs are available and assigned.","## maxRunners is the max number of runners the auto scaling runner set will scale up to.
maxRunners: 0

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 0","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Set max and min runners to 0
        run: |
          kubectl patch runnerscaleset <your-runnerscaleset-name> --type='json' -p='[{""op"": ""replace"", ""path"": ""/spec/maxRunners"", ""value"": 0}, {""op"": ""replace"", ""path"": ""/spec/minRunners"", ""value"": 0}]'
",0
694,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Custom TLS certificates,"ARC offers several advanced configuration options. Note  If you are using a custom runner image that is not based on theDebiandistribution, the following instructions will not work. Note If you are using a custom runner image that is not based on the Debian distribution, the following instructions will not work. Some environments require TLS certificates that are signed by a custom certificate authority (CA). Since the custom certificate authority certificates are not bundled with the controller or runner containers, you must inject them into their respective trust stores.","githubServerTLS:
  certificateFrom:
    configMapKeyRef:
      name: config-map-name
      key: ca.crt
  runnerMountPath: /usr/local/share/ca-certificates/","jobs:
  deploy-runner-scale-sets:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Deploy runner scale sets
        run: |
          kubectl create secret generic custom-ca-cert \
            --from-file=ca.crt=/path/to/custom/ca.crt \
            -n actions-runner-system

          kubectl patch deployment actions-runner-controller \
            -n actions-runner-system \
            --type=json \
            -p='[{""op"": ""add"", ""path"": ""/spec/template/spec/containers/0/volumeMounts/-"", ""value"": {""name"": ""custom-ca-cert"", ""mountPath"": ""/usr/local/share/ca-certificates/custom-ca.crt"", ""subPath"": ""ca.crt""}}]'

          kubectl patch deployment actions-runner-controller \
            -n actions-runner-system \
            --type=json \
            -p='[{""op"": ""add"", ""path"": ""/spec/template/spec/volumes/-"", ""value"": {""name"": ""custom-ca-cert"", ""secret"": {""secretName"": ""custom-ca-cert""}}}]'

          kubectl rollout restart deployment actions-runner-controller -n actions-runner-system
",0
695,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Using a private container registry - Configuring the controller image,"ARC offers several advanced configuration options. Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . To use a private container registry, you can copy the controller image and runner image to your private container registry. Then configure the links to those images and set the imagePullPolicy and imagePullSecrets values. You can update your copy of the values.yaml file and set the image properties as follows.","image:
  repository: ""custom-registry.io/gha-runner-scale-set-controller""
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""0.4.0""

imagePullSecrets:
  - name: <registry-secret-name>","jobs:
  deploy-runner-scale-sets:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Deploy ARC with private registry
        run: |
          helm upgrade --install actions-runner-controller actions-runner-controller/actions-runner-controller \
            --namespace actions-runner-system \
            --set controllerManager.image.repository=<your-private-registry>/actions-runner-controller \
            --set controllerManager.image.tag=<controller-image-tag> \
            --set controllerManager.image.pullPolicy=IfNotPresent \
            --set controllerManager.imagePullSecrets[0].name=<your-image-pull-secret> \
            --set runner.image.repository=<your-private-registry>/runner \
            --set runner.image.tag=<runner-image-tag> \
            --set runner.image.pullPolicy=IfNotPresent \
            --set runner.imagePullSecrets[0].name=<your-image-pull-secret>
",0
696,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Using a private container registry - Configuring the runner image,"ARC offers several advanced configuration options. Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . To use a private container registry, you can copy the controller image and runner image to your private container registry. Then configure the links to those images and set the imagePullPolicy and imagePullSecrets values. You can update your copy of the values.yaml file and set the template.spec properties as follows.","template:
  spec:
    containers:
      - name: runner
        image: ""custom-registry.io/actions-runner:latest""
        imagePullPolicy: Always
        command: [""/home/runner/run.sh""]
    imagePullSecrets:
      - name: <registry-secret-name>","jobs:
  deploy-runner-scale-sets:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Deploy Runner Scale Sets
        uses: actions-runner-controller/actions-runner-controller@v0.21.0
        with:
          controller-image: my-private-registry/controller-image:latest
          runner-image: my-private-registry/runner-image:latest
          image-pull-policy: Always
          image-pull-secrets: my-image-pull-secret
",0
697,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Updating the pod specification for the runner pod,"ARC offers several advanced configuration options. Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . You can fully customize the PodSpec of the runner pod and the controller will apply the configuration you specify. The following is an example pod specification.","template:
  spec:
    containers:
      - name: runner
        image: ghcr.io/actions/actions-runner:latest
        command: [""/home/runner/run.sh""]
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
        securityContext:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            add:
              - NET_ADMIN","spec:
  containers:
  - name: runner
    image: my-custom-runner-image:latest
    resources:
      limits:
        memory: ""2Gi""
        cpu: ""1""
      requests:
        memory: ""1Gi""
        cpu: ""0.5""
    env:
    - name: RUNNER_NAME
      value: my-runner
    - name: RUNNER_WORKDIR
      value: /runner
    volumeMounts:
    - name: runner-volume
      mountPath: /runner
  volumes:
  - name: runner-volume
    emptyDir: {}
",0
698,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using advanced configuration options - Updating the pod specification for the listener pod,"ARC offers several advanced configuration options. Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . You can customize the PodSpec of the listener pod and the controller will apply the configuration you specify. The following is an example pod specification. Note  It's important to not change thelistenerTemplate.spec.containers.namevalue of the listener container. Otherwise, the configuration you specify will be applied to a new side-car container. Note It's important to not change the listenerTemplate.spec.containers.name value of the listener container. Otherwise, the configuration you specify will be applied to a new side-car container.","listenerTemplate:
  spec:
    containers:
    # If you change the name of the container, the configuration will not be applied to the listener,
    # and it will be treated as a side-car container.
    - name: listener
      securityContext:
        runAsUser: 1000
      resources:
        limits:
          cpu: ""1""
          memory: 1Gi
        requests:
          cpu: ""1""
          memory: 1Gi","jobs:
  deploy-runner-scale-sets:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy with ARC
        uses: actions/checkout@v2
      - name: Update listener pod spec
        run: |
          kubectl apply -f - <<EOF
          apiVersion: actions.summerwind.dev/v1alpha1
          kind: RunnerDeployment
          metadata:
            name: example-runner-deployment
          spec:
            replicas: 1
            template:
              spec:
                repository: example/repo
                listenerTemplate:
                  spec:
                    containers:
                    - name: listener
                      resources:
                        limits:
                          cpu: ""500m""
                          memory: ""512Mi""
                        requests:
                          cpu: ""250m""
                          memory: ""256Mi""
          EOF
",0
699,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using Docker-in-Docker or Kubernetes mode for containers - Using Docker-in-Docker mode,"Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes . Note  The Docker-in-Docker container requires privileged mode. For more information, seeConfigure a Security Context for a Pod or Containerin the Kubernetes documentation.  By default, thedindcontainer uses thedocker:dindimage, which runs the Docker daemon as root. You can replace this image withdocker:dind-rootlessas long as you are aware of theknown limitationsand run the pods with--privilegedmode. To learn how to customize the Docker-in-Docker configuration, seeCustomizing container modes. Note The Docker-in-Docker container requires privileged mode. For more information, see Configure a Security Context for a Pod or Container in the Kubernetes documentation. By default, the dind container uses the docker:dind image, which runs the Docker daemon as root. You can replace this image with docker:dind-rootless as long as you are aware of the known limitations and run the pods with --privileged mode. To learn how to customize the Docker-in-Docker configuration, see Customizing container modes . Docker-in-Docker mode is a configuration that allows you to run Docker inside a Docker container. In this configuration, for each runner pod created, ARC creates the following containers. To enable Docker-in-Docker mode, set the containerMode.type to dind as follows.","containerMode:
  type: ""dind""","jobs:
  deploy:
    runs-on: ubuntu-latest
    container:
      image: docker:dind
      options: --privileged
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: .
          push: true
          tags: user/repository:tag
",0
700,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using Docker-in-Docker or Kubernetes mode for containers - Using Docker-in-Docker mode,"Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes . Note  The Docker-in-Docker container requires privileged mode. For more information, seeConfigure a Security Context for a Pod or Containerin the Kubernetes documentation.  By default, thedindcontainer uses thedocker:dindimage, which runs the Docker daemon as root. You can replace this image withdocker:dind-rootlessas long as you are aware of theknown limitationsand run the pods with--privilegedmode. To learn how to customize the Docker-in-Docker configuration, seeCustomizing container modes. Note The Docker-in-Docker container requires privileged mode. For more information, see Configure a Security Context for a Pod or Container in the Kubernetes documentation. By default, the dind container uses the docker:dind image, which runs the Docker daemon as root. You can replace this image with docker:dind-rootless as long as you are aware of the known limitations and run the pods with --privileged mode. To learn how to customize the Docker-in-Docker configuration, see Customizing container modes . Docker-in-Docker mode is a configuration that allows you to run Docker inside a Docker container. In this configuration, for each runner pod created, ARC creates the following containers. To enable Docker-in-Docker mode, set the containerMode.type to dind as follows. The template.spec will be updated to the following default configuration.","template:
  spec:
    initContainers:
      - name: init-dind-externals
        image: ghcr.io/actions/actions-runner:latest
        command:
          [""cp"", ""-r"", ""/home/runner/externals/."", ""/home/runner/tmpDir/""]
        volumeMounts:
          - name: dind-externals
            mountPath: /home/runner/tmpDir
    containers:
      - name: runner
        image: ghcr.io/actions/actions-runner:latest
        command: [""/home/runner/run.sh""]
        env:
          - name: DOCKER_HOST
            value: unix:///var/run/docker.sock
        volumeMounts:
          - name: work
            mountPath: /home/runner/_work
          - name: dind-sock
            mountPath: /var/run
      - name: dind
        image: docker:dind
        args:
          - dockerd
          - --host=unix:///var/run/docker.sock
          - --group=$(DOCKER_GROUP_GID)
        env:
          - name: DOCKER_GROUP_GID
            value: ""123""
        securityContext:
          privileged: true
        volumeMounts:
          - name: work
            mountPath: /home/runner/_work
          - name: dind-sock
            mountPath: /var/run
          - name: dind-externals
            mountPath: /home/runner/externals
    volumes:
      - name: work
        emptyDir: {}
      - name: dind-sock
        emptyDir: {}
      - name: dind-externals
        emptyDir: {}","jobs:
  deploy:
    runs-on: ubuntu-latest
    container:
      image: docker:dind
      options: --privileged
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: .
          push: true
          tags: user/repository:tag
",0
701,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using Docker-in-Docker or Kubernetes mode for containers - Using Kubernetes mode - Configuring Kubernetes mode,"Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes . In Kubernetes mode, ARC uses runner container hooks to create a new pod in the same namespace to run the service, container job, or action. To enable Kubernetes mode, set the containerMode.type to kubernetes in your values.yaml file.","containerMode:
  type: ""kubernetes""
  kubernetesModeWorkVolumeClaim:
    accessModes: [""ReadWriteOnce""]
    storageClassName: ""dynamic-blob-storage""
    resources:
      requests:
        storage: 1Gi","jobs:
  deploy-runner-scale-sets:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Configure Kubernetes mode
        run: |
          echo ""containerMode:""
          echo ""  type: kubernetes"" >> values.yaml
",0
702,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using Docker-in-Docker or Kubernetes mode for containers - Using Kubernetes mode - Configuring Kubernetes mode,"Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes . In Kubernetes mode, ARC uses runner container hooks to create a new pod in the same namespace to run the service, container job, or action. To enable Kubernetes mode, set the containerMode.type to kubernetes in your values.yaml file. For additional Helm configuration options, see values.yaml in the ARC repository. Note  When Kubernetes mode is enabled, workflows that are not configured with a container job will fail with an error similar to:  Jobs without a job container are forbidden on this runner, please add a'container:'to your job or contact your self-hosted runner administrator.  To allow jobs without a job container to run, setACTIONS_RUNNER_REQUIRE_JOB_CONTAINERtofalseon your runner container. This instructs the runner to disable this check. Note When Kubernetes mode is enabled, workflows that are not configured with a container job will fail with an error similar to: To allow jobs without a job container to run, set ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER to false on your runner container. This instructs the runner to disable this check.","template:
  spec:
    containers:
      - name: runner
        image: ghcr.io/actions/actions-runner:latest
        command: [""/home/runner/run.sh""]
        env:
          - name: ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER
            value: ""false""","jobs:
  deploy:
    runs-on: self-hosted
    container:
      image: your-container-image
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy with Kubernetes mode
        run: |
          echo ""Deploying with Kubernetes mode""
        env:
          ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER: false
",0
703,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using Docker-in-Docker or Kubernetes mode for containers - Customizing container modes - Example: running dind-rootless,"Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes . When you set the containerMode in the values.yaml file for the gha-runner-scale-set helm chart , you can use either of the following values: Depending on which value you set for the containerMode , a configuration will automatically be injected into the template section of the values.yaml file for the gha-runner-scale-set helm chart. To customize the spec, comment out or remove containerMode , and append the configuration you want in the template section. Before deciding to run dind-rootless , make sure you are aware of known limitations .","## githubConfigUrl is the GitHub url for where you want to configure runners
## ex: https://github.com/myorg/myrepo or https://github.com/myorg
githubConfigUrl: ""https://github.com/actions/actions-runner-controller""

## githubConfigSecret is the k8s secrets to use when auth with GitHub API.
## You can choose to use GitHub App or a PAT token
githubConfigSecret: my-super-safe-secret

## maxRunners is the max number of runners the autoscaling runner set will scale up to.
maxRunners: 5

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 0

runnerGroup: ""my-custom-runner-group""

## name of the runner scale set to create. Defaults to the helm release name
runnerScaleSetName: ""my-awesome-scale-set""

## template is the PodSpec for each runner Pod
## For reference: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec
template:
  spec:
    initContainers:
    - name: init-dind-externals
      image: ghcr.io/actions/actions-runner:latest
      command: [""cp"", ""-r"", ""/home/runner/externals/."", ""/home/runner/tmpDir/""]
      volumeMounts:
        - name: dind-externals
          mountPath: /home/runner/tmpDir
    - name: init-dind-rootless
      image: docker:dind-rootless
      command:
        - sh
        - -c
        - |
          set -x
          cp -a /etc/. /dind-etc/
          echo 'runner:x:1001:1001:runner:/home/runner:/bin/ash' >> /dind-etc/passwd
          echo 'runner:x:1001:' >> /dind-etc/group
          echo 'runner:100000:65536' >> /dind-etc/subgid
          echo 'runner:100000:65536' >> /dind-etc/subuid
          chmod 755 /dind-etc;
          chmod u=rwx,g=rx+s,o=rx /dind-home
          chown 1001:1001 /dind-home
      securityContext:
        runAsUser: 0
      volumeMounts:
        - mountPath: /dind-etc
          name: dind-etc
        - mountPath: /dind-home
          name: dind-home
    containers:
    - name: runner
      image: ghcr.io/actions/actions-runner:latest
      command: [""/home/runner/run.sh""]
      env:
        - name: DOCKER_HOST
          value: unix:///run/user/1001/docker.sock
      securityContext:
        privileged: true
        runAsUser: 1001
        runAsGroup: 1001
      volumeMounts:
        - name: work
          mountPath: /home/runner/_work
        - name: dind-sock
          mountPath: /run/user/1001
    - name: dind
      image: docker:dind-rootless
      args:
        - dockerd
        - --host=unix:///run/user/1001/docker.sock
      securityContext:
        privileged: true
        runAsUser: 1001
        runAsGroup: 1001
      volumeMounts:
        - name: work
          mountPath: /home/runner/_work
        - name: dind-sock
          mountPath: /run/user/1001
        - name: dind-externals
          mountPath: /home/runner/externals
        - name: dind-etc
          mountPath: /etc
        - name: dind-home
          mountPath: /home/runner
    volumes:
    - name: work
      emptyDir: {}
    - name: dind-externals
      emptyDir: {}
    - name: dind-sock
      emptyDir: {}
    - name: dind-etc
      emptyDir: {}
    - name: dind-home
      emptyDir: {}","jobs:
  deploy-runner-scale-set:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Deploy Helm Chart
        uses: azure/setup-helm@v1
        with:
          version: v3.5.4

      - name: Install Runner Scale Set
        run: |
          helm repo add actions-runner-controller https://actions-runner-controller.github.io/actions-runner-controller
          helm repo update
          helm install gha-runner-scale-set actions-runner-controller/gha-runner-scale-set --namespace actions-runner-system --create-namespace --set containerMode=dind-rootless
",0
704,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Using Docker-in-Docker or Kubernetes mode for containers - Customizing container modes - Configuring hook extensions - Example: Using config map to set securityContext,"Warning  This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.  For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller. Warning This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly. For more information about what GitHub Support can assist with, see About support for Actions Runner Controller . If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes . When you set the containerMode in the values.yaml file for the gha-runner-scale-set helm chart , you can use either of the following values: Depending on which value you set for the containerMode , a configuration will automatically be injected into the template section of the values.yaml file for the gha-runner-scale-set helm chart. To customize the spec, comment out or remove containerMode , and append the configuration you want in the template section. As of ARC version 0.4.0, runner-container-hooks support hook extensions. You can use these to configure the pod created by runner-container-hooks. For example, you could use a hook extension to set a security context on the pod. Hook extensions allow you to specify a YAML file that is used to update the PodSpec of the pod created by runner-container-hooks. There are two options to configure hook extensions. Note  With both options, you must set theACTIONS_RUNNER_CONTAINER_HOOK_TEMPLATEenvironment variable in the runner container spec to point to the path of the YAML file mounted in the runner container. Note With both options, you must set the ACTIONS_RUNNER_CONTAINER_HOOK_TEMPLATE environment variable in the runner container spec to point to the path of the YAML file mounted in the runner container. Create a config map in the same namespace as the runner pods. For example:","apiVersion: v1
kind: ConfigMap
metadata:
  name: hook-extension
  namespace: arc-runners
data:
  content: |
    metadata:
      annotations:
        example: ""extension""
    spec:
      containers:
        - name: ""$job"" # Target the job container
          securityContext:
            runAsUser: 1000","apiVersion: v1
kind: ConfigMap
metadata:
  name: runner-container-hook-config
  namespace: runner-namespace
data:
  hook-template.yaml: |
    apiVersion: v1
    kind: Pod
    spec:
      securityContext:
        runAsUser: 1000
        runAsGroup: 3000
        fsGroup: 2000
",0
705,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller,Deploying runner scale sets with Actions Runner Controller - Enabling metrics,"Note  Metrics for ARC are available as of version gha-runner-scale-set-0.5.0. Note Metrics for ARC are available as of version gha-runner-scale-set-0.5.0. ARC can emit metrics about your runners, your jobs, and time spent on executing your workflows. Metrics can be used to identify congestion, monitor the health of your ARC deployment, visualize usage trends, optimize resource consumption, among many other use cases. Metrics are emitted by the controller-manager and listener pods in Prometheus format. For more information, see Exposition formats in the Prometheus documentation. To enable metrics for ARC, configure the metrics property in the values.yaml file of the gha-runner-scale-set-controller chart. The following is an example configuration.","metrics:
  controllerManagerAddr: "":8080""
  listenerAddr: "":8080""
  listenerEndpoint: ""/metrics""","metrics:
  enabled: true
  serviceMonitor:
    enabled: true
",0
706,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables,Store information in variables - Defining environment variables for a single workflow,"To set a custom environment variable for a single workflow, you can define it using the env key in the workflow file. The scope of a custom variable set by this method is limited to the element in which it is defined. You can define variables that are scoped for:","name: Greeting on variable day

on:
  workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: ""Say Hello Mona it's Monday""
        run: echo ""$Greeting $First_Name. Today is $DAY_OF_WEEK!""
        env:
          First_Name: Mona","env:
  CUSTOM_VARIABLE: ""value""
",0
707,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables,Store information in variables - Using contexts to access variable values - Using the env context to access environment variable values,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs . There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs . You can access environment variable values using the env context and configuration variable values using the vars context. In addition to runner environment variables, GitHub Actions allows you to set and read env key values using contexts. Environment variables and contexts are intended for use at different points in the workflow. The run steps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example, $NAME for the bash shell on a Linux runner, or $env:NAME for PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax ${{ CONTEXT.PROPERTY }} , to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner. However, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, an if conditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in an if conditional statement to access the value of an variable.","name: Conditional env variable

on: workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: ""Say Hello Mona it's Monday""
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        run: echo ""$Greeting $First_Name. Today is $DAY_OF_WEEK!""
        env:
          First_Name: Mona","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      MY_ENV_VAR: 'Hello World'
    steps:
      - name: Print environment variable
        run: echo $MY_ENV_VAR

      - name: Print environment variable using context
        run: echo ${{ env.MY_ENV_VAR }}

      - name: Conditional step
        if: ${{ env.MY_ENV_VAR == 'Hello World' }}
        run: echo ""Condition met""
",0
708,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables,Store information in variables - Using contexts to access variable values - Using the env context to access environment variable values,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs . There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs . You can access environment variable values using the env context and configuration variable values using the vars context. In addition to runner environment variables, GitHub Actions allows you to set and read env key values using contexts. Environment variables and contexts are intended for use at different points in the workflow. The run steps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example, $NAME for the bash shell on a Linux runner, or $env:NAME for PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax ${{ CONTEXT.PROPERTY }} , to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner. However, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, an if conditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in an if conditional statement to access the value of an variable. In this modification of the earlier example, we've introduced an if conditional. The workflow step is now only run if DAY_OF_WEEK is set to ""Monday"". We access this value from the if conditional statement by using the env context . The env context is not required for the variables referenced within the run command. They are referenced as runner environment variables and are interpolated after the job is received by the runner. We could, however, have chosen to interpolate those variables before sending the job to the runner, by using contexts. The resulting output would be the same.","run: echo ""${{ env.Greeting }} ${{ env.First_Name }}. Today is ${{ env.DAY_OF_WEEK }}!""","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      DAY_OF_WEEK: Monday
    steps:
      - name: Check day of the week
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        run: echo ""Today is $DAY_OF_WEEK""
",0
709,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables,Store information in variables - Using contexts to access variable values - Using the vars context to access configuration variable values,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs . There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs . You can access environment variable values using the env context and configuration variable values using the vars context. Configuration variables can be accessed across the workflow using vars context. For more information, see Accessing contextual information about workflow runs . If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string. The following example shows using configuration variables with the vars context across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels.","on:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo ""repository variable : $REPOSITORY_VAR""
        echo ""organization variable : $ORGANIZATION_VAR""
        echo ""overridden variable : $OVERRIDE_VAR""
        echo ""variable from shell environment : $env_var""
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Print configuration variables
        run: |
          echo ""Repository variable: ${{ vars.repository_variable }}""
          echo ""Organization variable: ${{ vars.organization_variable }}""
          echo ""Environment variable: ${{ vars.environment_variable }}""
",0
710,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables,Store information in variables - Detecting the operating system,"You can write a single workflow file that can be used for different operating systems by using the RUNNER_OS default environment variable and the corresponding context property ${{ runner.os }} . For example, the following workflow could be run successfully if you changed the operating system from macos-latest to windows-latest without having to alter the syntax of the environment variables, which differs depending on the shell being used by the runner.","on: workflow_dispatch

jobs:
  if-Windows-else:
    runs-on: macos-latest
    steps:
      - name: condition 1
        if: runner.os == 'Windows'
        run: echo ""The operating system on the runner is $env:RUNNER_OS.""
      - name: condition 2
        if: runner.os != 'Windows'
        run: echo ""The operating system on the runner is not Windows, it's $RUNNER_OS.""","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
    steps:
      - name: Check operating system
        run: echo ""Running on ${{ runner.os }}""
",0
711,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi,Configuring OpenID Connect in PyPI - Updating your GitHub Actions workflow,"Once your trusted publisher is registered on PyPI, you can update your release workflow to use trusted publishing. Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The pypa/gh-action-pypi-publish action has built-in support for trusted publishing, which can be enabled by giving its containing job the id-token: write permission and omitting username and password . The following example uses the pypa/gh-action-pypi-publish action to exchange an OIDC token for a PyPI API token, which is then used to upload a package's release distributions to PyPI.","jobs:
  release-build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ""3.x""

      - name: build release distributions
        run: |
          # NOTE: put your own distribution build steps here.
          python -m pip install build
          python -m build

      - name: upload windows dists
        uses: actions/upload-artifact@v4
        with:
          name: release-dists
          path: dist/

  pypi-publish:
    runs-on: ubuntu-latest
    needs:
      - release-build
    permissions:
      id-token: write

    steps:
      - name: Retrieve release distributions
        uses: actions/download-artifact@v4
        with:
          name: release-dists
          path: dist/

      - name: Publish release distributions to PyPI
        uses: pypa/gh-action-pypi-publish@3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f","jobs:
  release:
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v3
      - uses: pypa/gh-action-pypi-publish@release/v1
        with:
          package_dir: .
",0
712,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Creating a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call :","on:
  workflow_call:","on:
  workflow_call:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
713,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow.","on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      personal_access_token:
        required: true","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""${{ inputs.example_input }}""
      - name: Use secret
        run: echo ""Using secret""
        env:
          SECRET: ${{ secrets.example_secret }}
",0
714,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions .","jobs:
  reusable_workflow_job:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.personal_access_token }}
        configuration-path: ${{ inputs.config-path }}","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
715,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions . In the example above, personal_access_token is a secret that's defined at the repository or organization level. Warning  Environment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions. Warning Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions . Pass the input or secret from the caller workflow. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}","on:
  workflow_call:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        type: string
    secrets:
      example_secret:
        description: 'An example secret'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
716,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions . In the example above, personal_access_token is a secret that's defined at the repository or organization level. Warning  Environment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions. Warning Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions . Pass the input or secret from the caller workflow. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string). Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit","on:
  workflow_call:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        type: string
    secrets:
      example_secret:
        description: 'An example secret'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
717,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Creating a reusable workflow - Example reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : This reusable workflow file named workflow-B.yml (we'll refer to this later in the example caller workflow ) takes an input string and a secret from the caller workflow and uses them in an action.","name: Reusable workflow example

on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      token:
        required: true

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.token }}
        configuration-path: ${{ inputs.config-path }}","on:
  workflow_call:
    inputs:
      example_input:
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use inputs and secrets
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
718,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Calling a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job.","jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
",0
719,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Calling a reusable workflow - Passing inputs and secrets to a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      input_name: input_value
    secrets:
      secret_name: ${{ secrets.SECRET_VALUE }}
",0
720,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Calling a reusable workflow - Passing inputs and secrets to a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string). Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      input_name: input_value
    secrets:
      secret_name: ${{ secrets.SECRET_VALUE }}
",0
721,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Calling a reusable workflow - Using a matrix strategy with a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. Jobs using the matrix strategy can call a reusable workflow. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, see Running variations of jobs in a workflow . This example job below calls a reusable workflow and references the matrix context by defining the variable target with the values [dev, stage, prod] . It will run three jobs, one for each value in the variable.","jobs:
  ReuseableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}","jobs:
  call-reusable-workflow:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      target: ${{ matrix.target }}
",0
722,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Calling a reusable workflow - Example caller workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. This workflow file calls two workflow files. The second of these, workflow-B.yml (shown in the example reusable workflow ), is passed an input ( config-path ) and a secret ( token ).","name: Call a reusable workflow

on:
  pull_request:
    branches:
      - main

jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1

  call-workflow-passing-data:
    permissions:
      contents: read
      pull-requests: write
    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}","jobs:
  call-workflow-a:
    uses: owner/repo/.github/workflows/workflow-A.yml@commitSHA

  call-workflow-b:
    uses: owner/repo/.github/workflows/workflow-B.yml@commitSHA
    with:
      config-path: 'path/to/config'
    secrets:
      token: ${{ secrets.TOKEN }}
",0
723,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Nesting reusable workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow.","name: Reusable workflow

on:
  workflow_call:

jobs:
  call-another-reusable:
    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1","jobs:
  call-workflow-1:
    uses: ./called-workflow-1.yml

# called-workflow-1.yml
jobs:
  call-workflow-2:
    uses: ./called-workflow-2.yml

# called-workflow-2.yml
jobs:
  call-workflow-3:
    uses: ./called-workflow-3.yml

# called-workflow-3.yml
jobs:
  final-step:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Final step in the workflow chain""
",0
724,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Nesting reusable workflows - Passing secrets to nested workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow. You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions . Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C. In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.","jobs:
  workflowA-calls-workflowB:
    uses: octo-org/example-repo/.github/workflows/B.yml@main
    secrets: inherit # pass all secrets","jobs:
  call-workflow-b:
    uses: ./called-workflow-1.yml
    secrets: inherit

  call-workflow-c:
    uses: ./called-workflow-2.yml
    secrets:
      my_secret: ${{ secrets.my_secret }}
",0
725,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Nesting reusable workflows - Passing secrets to nested workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow. You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions . Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C. In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.","jobs:
  workflowB-calls-workflowC:
    uses: different-org/example-repo/.github/workflows/C.yml@main
    secrets:
      repo-token: ${{ secrets.personal_access_token }} # pass just this secret","jobs:
  call-workflow-b:
    uses: ./called-workflow-1.yml
    secrets: inherit

  call-workflow-c:
    uses: ./called-workflow-2.yml
    secrets:
      my_secret: ${{ secrets.my_secret }}

  call-workflow-d:
    uses: ./called-workflow-3.yml
",0
726,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Using outputs from a reusable workflow,"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow. If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow. The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: ""hello"" and ""world."" In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2 . In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1 , and one called secondword which we map to output2 . The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below. For more information, see Passing information between jobs and Workflow syntax for GitHub Actions .","name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: ""The first output string""
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: ""The second output string""
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo ""firstword=hello"" >> $GITHUB_OUTPUT
      - id: step2
        run: echo ""secondword=world"" >> $GITHUB_OUTPUT","jobs:
  generate_outputs:
    runs-on: ubuntu-latest
    outputs:
      output1: ${{ steps.step1.outputs.word }}
      output2: ${{ steps.step2.outputs.word }}
    steps:
      - id: step1
        run: echo ""::set-output name=word::hello""
      - id: step2
        run: echo ""::set-output name=word::world""

on:
  workflow_call:
    outputs:
      firstword:
        value: ${{ jobs.generate_outputs.outputs.output1 }}
      secondword:
        value: ${{ jobs.generate_outputs.outputs.output2 }}
",0
727,https://docs.github.com/en/actions/using-workflows/reusing-workflows,Reusing workflows - Using outputs from a reusable workflow,"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow. If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow. The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: ""hello"" and ""world."" In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2 . In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1 , and one called secondword which we map to output2 . The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below. For more information, see Passing information between jobs and Workflow syntax for GitHub Actions . We can now use the outputs in the caller workflow, in the same way you would use the outputs from a job within the same workflow. We reference the outputs using the names defined at the workflow level in the reusable workflow: firstword and secondword . In this workflow, job1 calls the reusable workflow and job2 prints the outputs from the reusable workflow (""hello world"") to standard output in the workflow log.","name: Call a reusable workflow and use its outputs

on:
  workflow_dispatch:

jobs:
  job1:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}","jobs:
  reusable_workflow:
    runs:
      steps:
        - id: step1
          run: echo ""::set-output name=step_output1::hello""
        - id: step2
          run: echo ""::set-output name=step_output2::world""
    outputs:
      output1: ${{ steps.step1.outputs.step_output1 }}
      output2: ${{ steps.step2.outputs.step_output2 }}

on:
  workflow_call:
    outputs:
      firstword:
        value: ${{ jobs.reusable_workflow.outputs.output1 }}
      secondword:
        value: ${{ jobs.reusable_workflow.outputs.output2 }}

jobs:
  job1:
    uses: ./reusable_workflow.yml

  job2:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}""
",0
728,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=windows,Running jobs on larger runners - Using groups to control where jobs are run,"In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
729,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=windows,Running jobs on larger runners - Using labels to control where jobs are run,"You can implicitly pass a label to the runs-on key by using the syntax runs-on: LABEL . Alternatively, you can use the labels key, as shown in the example below. In this example, the runs-on key sends the job to any available runner that has been assigned the windows-2022-16core label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      labels: windows-2022-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example_job:
    runs-on: windows-2022-16core
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
730,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners?platform=windows,Running jobs on larger runners - Using labels and groups to control where jobs are run,"When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [group:ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
731,https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/customizing-github-hosted-runners,Customizing GitHub-hosted runners - Installing software on Ubuntu runners,The following example demonstrates how to install an apt package as part of a job.,"name: Build on Ubuntu
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install jq tool
        run: |
          sudo apt-get update
          sudo apt-get install jq","jobs:
  install-package:
    runs-on: ubuntu-latest
    steps:
      - name: Install package
        run: sudo apt-get update && sudo apt-get install -y <package-name>
",0
732,https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/customizing-github-hosted-runners,Customizing GitHub-hosted runners - Installing software on macOS runners,The following example demonstrates how to install Brew packages and casks as part of a job.,"name: Build on macOS
on: push

jobs:
  build:
    runs-on: macos-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install GitHub CLI
        run: |
          brew update
          brew install gh
      - name: Install Microsoft Edge
        run: |
          brew update
          brew install --cask microsoft-edge","jobs:
  install_software:
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install Brew packages
        run: |
          brew update
          brew install wget
      - name: Install Brew casks
        run: |
          brew install --cask google-chrome
",0
733,https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/customizing-github-hosted-runners,Customizing GitHub-hosted runners - Installing software on Windows runners,The following example demonstrates how to use Chocolatey to install the GitHub CLI as part of a job.,"name: Build on Windows
on: push
jobs:
  build:
    runs-on: windows-latest
    steps:
      - run: choco install gh
      - run: gh version","jobs:
  install-gh-cli:
    runs-on: windows-latest
    steps:
      - name: Install Chocolatey
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force; `
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; `
          iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
      - name: Install GitHub CLI
        run: choco install gh -y
",0
734,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service,Deploying Python to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy a Python project to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If you use a version of Python other than 3.8 , change PYTHON_VERSION to the version that you use. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and deploy Python app to Azure Web App

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name
  PYTHON_VERSION: '3.8'               # set this to the Python version to use

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python version
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Create and start virtual environment
        run: |
          python -m venv venv
          source venv/bin/activate

      - name: Set up dependency caching for faster installs
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: pip install -r requirements.txt

      # Optional: Add a step to run tests here (PyTest, Django test suites, etc.)

      - name: Upload artifact for deployment jobs
        uses: actions/upload-artifact@v4
        with:
          name: python-app
          path: |
            .
            !venv/
  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: python-app
          path: .

      - name: 'Deploy to Azure Web App'
        id: deploy-to-webapp
        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}","on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.8

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build project
        run: |
          # Add your build commands here
          echo ""Building the project""

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'production'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
",0
735,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect,About security hardening with OpenID Connect - Configuring the OIDC trust with the cloud - Understanding the OIDC token,"When you configure your cloud to trust GitHub's OIDC provider, you must add conditions that filter incoming requests, so that untrusted repositories or workflows cant request access tokens for your cloud resources: Each job requests an OIDC token from GitHub's OIDC provider, which responds with an automatically generated JSON web token (JWT) that is unique for each workflow job where it is generated. When the job runs, the OIDC token is presented to the cloud provider. To validate the token, the cloud provider checks if the OIDC token's subject and other claims are a match for the conditions that were preconfigured on the cloud role's OIDC trust definition. The following example OIDC token uses a subject ( sub ) that references a job environment named prod in the octo-org/octo-repo repository.","{
  ""typ"": ""JWT"",
  ""alg"": ""RS256"",
  ""x5t"": ""example-thumbprint"",
  ""kid"": ""example-key-id""
}
{
  ""jti"": ""example-id"",
  ""sub"": ""repo:octo-org/octo-repo:environment:prod"",
  ""environment"": ""prod"",
  ""aud"": ""https://github.com/octo-org"",
  ""ref"": ""refs/heads/main"",
  ""sha"": ""example-sha"",
  ""repository"": ""octo-org/octo-repo"",
  ""repository_owner"": ""octo-org"",
  ""actor_id"": ""12"",
  ""repository_visibility"": ""private"",
  ""repository_id"": ""74"",
  ""repository_owner_id"": ""65"",
  ""run_id"": ""example-run-id"",
  ""run_number"": ""10"",
  ""run_attempt"": ""2"",
  ""runner_environment"": ""github-hosted"",
  ""actor"": ""octocat"",
  ""workflow"": ""example-workflow"",
  ""head_ref"": """",
  ""base_ref"": """",
  ""event_name"": ""workflow_dispatch"",
  ""ref_type"": ""branch"",
  ""job_workflow_ref"": ""octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main"",
  ""iss"": ""https://token.actions.githubusercontent.com"",
  ""nbf"": 1632492967,
  ""exp"": 1632493867,
  ""iat"": 1632493567
}","jobs:
  example-job:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Request OIDC token
        id: oidc
        run: echo ""Requesting OIDC token""
      - name: Use OIDC token
        run: |
          echo ""Using OIDC token for cloud authentication""
          # Example command to use the OIDC token
          # cloud-cli authenticate --token ${{ steps.oidc.outputs.token }}
",0
736,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect,About security hardening with OpenID Connect - Updating your actions for OIDC - Adding permissions settings,"To update your custom actions to authenticate using OIDC, you can use getIDToken() from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see ""OIDC Token"" in the npm package documentation . You could also use a curl command to request the JWT, using the following environment variables. For example: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
737,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect,About security hardening with OpenID Connect - Updating your actions for OIDC - Adding permissions settings,"To update your custom actions to authenticate using OIDC, you can use getIDToken() from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see ""OIDC Token"" in the npm package documentation . You could also use a curl command to request the JWT, using the following environment variables. For example: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","jobs:
  example-job:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Request OIDC Token
        run: |
          echo ""Requesting OIDC Token""
          curl -H ""Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"" \
               -H ""Accept: application/json"" \
               https://api.github.com
",0
738,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-amazon-elastic-container-service,Deploying to Amazon Elastic Container Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build a container image and push it to Amazon ECR. It then updates the task definition with the new image ID, and deploys the task definition to Amazon ECS. Ensure that you provide your own values for all the variables in the env key of the workflow. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Deploy to Amazon ECS

on:
  push:
    branches:
      - main

env:
  AWS_REGION: MY_AWS_REGION                   # set this to your preferred AWS region, e.g. us-west-1
  ECR_REPOSITORY: MY_ECR_REPOSITORY           # set this to your Amazon ECR repository name
  ECS_SERVICE: MY_ECS_SERVICE                 # set this to your Amazon ECS service name
  ECS_CLUSTER: MY_ECS_CLUSTER                 # set this to your Amazon ECS cluster name
  ECS_TASK_DEFINITION: MY_ECS_TASK_DEFINITION # set this to the path to your Amazon ECS task definition
                                               # file, e.g. .aws/task-definition.json
  CONTAINER_NAME: MY_CONTAINER_NAME           # set this to the name of the container in the
                                               # containerDefinitions section of your task definition

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@0e613a0980cbf65ed5b322eb7a1e075d28913a83
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@62f4f872db3836360b72999f4b87f1ff13310f3a

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build a docker container and
          # push it to ECR so that it can
          # be deployed to ECS.
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo ""image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"" >> $GITHUB_OUTPUT

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@c804dfbdd57f713b6c079302a4c01db7017a36fc
        with:
          task-definition: ${{ env.ECS_TASK_DEFINITION }}
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@df9643053eda01f169e64a0e60233aacca83799a
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2

    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Update ECS service with new image
      env:
        AWS_REGION: ${{ secrets.AWS_REGION }}
        ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
        ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
        CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}
        ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --force-new-deployment --region $AWS_REGION
",0
739,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-php-to-azure-app-service,Deploying PHP to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy a PHP project to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If the path to your project is not the repository root, change AZURE_WEBAPP_PACKAGE_PATH to the path to your project. If you use a version of PHP other than 8.x , change PHP_VERSION to the version that you use. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and deploy PHP app to Azure Web App

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name
  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root
  PHP_VERSION: '8.x'                  # set this to the PHP version to use

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@1f2e3d4c5b6a7f8e9d0c1b2a3e4f5d6c7b8a9e0f
        with:
          php-version: ${{ env.PHP_VERSION }}

      - name: Check if composer.json exists
        id: check_files
        uses: andstor/file-existence-action@2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b
        with:
          files: 'composer.json'

      - name: Get Composer Cache Directory
        id: composer-cache
        if: steps.check_files.outputs.files_exists == 'true'
        run: |
          echo ""dir=$(composer config cache-files-dir)"" >> $GITHUB_OUTPUT

      - name: Set up dependency caching for faster installs
        uses: actions/cache@v4
        if: steps.check_files.outputs.files_exists == 'true'
        with:
          path: ${{ steps.composer-cache.outputs.dir }}
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: Run composer install if composer.json exists
        if: steps.check_files.outputs.files_exists == 'true'
        run: composer validate --no-check-publish && composer install --prefer-dist --no-progress

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: php-app
          path: .

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: php-app

      - name: 'Deploy to Azure Web App'
        id: deploy-to-webapp
        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: .","on:
  push:
    branches:
      - main
env:
  AZURE_WEBAPP_NAME: your-webapp-name
  AZURE_WEBAPP_PACKAGE_PATH: .
  PHP_VERSION: 8.x
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
      - name: Install dependencies
        run: composer install --no-dev --optimize-autoloader
      - name: Archive project files
        run: zip -r my-php-app.zip ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          package: my-php-app.zip
",0
740,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Creating a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call :","on:
  workflow_call:","on:
  workflow_call:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
741,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow.","on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      personal_access_token:
        required: true","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""${{ inputs.example_input }}""
      - name: Use secret
        run: echo ""Secret is set""
        env:
          SECRET: ${{ secrets.example_secret }}
",0
742,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions .","jobs:
  reusable_workflow_job:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.personal_access_token }}
        configuration-path: ${{ inputs.config-path }}","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
743,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions . In the example above, personal_access_token is a secret that's defined at the repository or organization level. Warning  Environment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions. Warning Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions . Pass the input or secret from the caller workflow. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}","on:
  workflow_call:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        type: string
    secrets:
      example_secret:
        description: 'An example secret'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
744,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions . In the example above, personal_access_token is a secret that's defined at the repository or organization level. Warning  Environment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions. Warning Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions . Pass the input or secret from the caller workflow. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string). Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit","on:
  workflow_call:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        type: string
    secrets:
      example_secret:
        description: 'An example secret'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
745,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Creating a reusable workflow - Example reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : This reusable workflow file named workflow-B.yml (we'll refer to this later in the example caller workflow ) takes an input string and a secret from the caller workflow and uses them in an action.","name: Reusable workflow example

on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      token:
        required: true

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.token }}
        configuration-path: ${{ inputs.config-path }}","on:
  workflow_call:
    inputs:
      example_input:
        type: string
        required: true
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
746,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Calling a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job.","jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1","jobs:
  job1:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@main
  job2:
    uses: owner/repo/.github/workflows/another-reusable-workflow.yml@v1.0.0
",0
747,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Calling a reusable workflow - Passing inputs and secrets to a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      input_name: input_value
    secrets:
      secret_name: ${{ secrets.SECRET_VALUE }}
",0
748,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Calling a reusable workflow - Passing inputs and secrets to a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string). Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      input_name: input_value
    secrets:
      secret_name: ${{ secrets.SECRET_VALUE }}
",0
749,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Calling a reusable workflow - Using a matrix strategy with a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. Jobs using the matrix strategy can call a reusable workflow. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, see Running variations of jobs in a workflow . This example job below calls a reusable workflow and references the matrix context by defining the variable target with the values [dev, stage, prod] . It will run three jobs, one for each value in the variable.","jobs:
  ReuseableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}","jobs:
  call-reusable-workflow:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      target: ${{ matrix.target }}
",0
750,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Calling a reusable workflow - Example caller workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. This workflow file calls two workflow files. The second of these, workflow-B.yml (shown in the example reusable workflow ), is passed an input ( config-path ) and a secret ( token ).","name: Call a reusable workflow

on:
  pull_request:
    branches:
      - main

jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1

  call-workflow-passing-data:
    permissions:
      contents: read
      pull-requests: write
    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}","jobs:
  call-workflow-a:
    uses: owner/repo/.github/workflows/workflow-A.yml@commitSHA

  call-workflow-b:
    uses: owner/repo/.github/workflows/workflow-B.yml@commitSHA
    with:
      config-path: 'path/to/config'
    secrets:
      token: ${{ secrets.TOKEN }}
",0
751,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Nesting reusable workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow.","name: Reusable workflow

on:
  workflow_call:

jobs:
  call-another-reusable:
    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1","jobs:
  call-workflow-1:
    uses: ./called-workflow-1.yml

# called-workflow-1.yml
jobs:
  call-workflow-2:
    uses: ./called-workflow-2.yml

# called-workflow-2.yml
jobs:
  call-workflow-3:
    uses: ./called-workflow-3.yml

# called-workflow-3.yml
jobs:
  final-step:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This is the final step in the workflow chain.""
",0
752,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Nesting reusable workflows - Passing secrets to nested workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow. You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions . Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C. In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.","jobs:
  workflowA-calls-workflowB:
    uses: octo-org/example-repo/.github/workflows/B.yml@main
    secrets: inherit # pass all secrets","jobs:
  call-workflow-b:
    uses: ./called-workflow-1.yml
    secrets: inherit

  call-workflow-c:
    uses: ./called-workflow-2.yml
    secrets:
      my_secret: ${{ secrets.my_secret }}
",0
753,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Nesting reusable workflows - Passing secrets to nested workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow. You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions . Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C. In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.","jobs:
  workflowB-calls-workflowC:
    uses: different-org/example-repo/.github/workflows/C.yml@main
    secrets:
      repo-token: ${{ secrets.personal_access_token }} # pass just this secret","jobs:
  call-workflow-b:
    uses: ./called-workflow-1.yml
    secrets: inherit

  call-workflow-c:
    uses: ./called-workflow-2.yml
    secrets:
      my_secret: ${{ secrets.my_secret }}
",0
754,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Using outputs from a reusable workflow,"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow. If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow. The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: ""hello"" and ""world."" In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2 . In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1 , and one called secondword which we map to output2 . The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below. For more information, see Passing information between jobs and Workflow syntax for GitHub Actions .","name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: ""The first output string""
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: ""The second output string""
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo ""firstword=hello"" >> $GITHUB_OUTPUT
      - id: step2
        run: echo ""secondword=world"" >> $GITHUB_OUTPUT","jobs:
  reusable_job:
    runs-on: ubuntu-latest
    outputs:
      output1: ${{ steps.step1.outputs.step_output }}
      output2: ${{ steps.step2.outputs.step_output }}
    steps:
      - id: step1
        run: echo ""::set-output name=step_output::hello""
      - id: step2
        run: echo ""::set-output name=step_output::world""

on:
  workflow_call:
    outputs:
      firstword:
        value: ${{ jobs.reusable_job.outputs.output1 }}
      secondword:
        value: ${{ jobs.reusable_job.outputs.output2 }}
",0
755,https://docs.github.com/en/actions/sharing-automations/reusing-workflows,Reusing workflows - Using outputs from a reusable workflow,"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow. If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow. The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: ""hello"" and ""world."" In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2 . In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1 , and one called secondword which we map to output2 . The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below. For more information, see Passing information between jobs and Workflow syntax for GitHub Actions . We can now use the outputs in the caller workflow, in the same way you would use the outputs from a job within the same workflow. We reference the outputs using the names defined at the workflow level in the reusable workflow: firstword and secondword . In this workflow, job1 calls the reusable workflow and job2 prints the outputs from the reusable workflow (""hello world"") to standard output in the workflow log.","name: Call a reusable workflow and use its outputs

on:
  workflow_dispatch:

jobs:
  job1:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}","jobs:
  reusable_workflow:
    runs:
      steps:
        - id: step1
          run: echo ""::set-output name=step_output1::hello""
        - id: step2
          run: echo ""::set-output name=step_output2::world""
    outputs:
      output1: ${{ steps.step1.outputs.step_output1 }}
      output2: ${{ steps.step2.outputs.step_output2 }}

on:
  workflow_call:
    outputs:
      firstword:
        value: ${{ jobs.reusable_workflow.outputs.output1 }}
      secondword:
        value: ${{ jobs.reusable_workflow.outputs.output2 }}

jobs:
  job1:
    uses: ./.github/workflows/reusable_workflow.yml

  job2:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}""
",0
756,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bamboo-with-github-actions-importer,Migrating from Bamboo with GitHub Actions Importer - Reference - Optional arguments - --config-file-path - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bamboo. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from the Bamboo instance. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit. To audit a Bamboo instance using a config file, the config file must be in the following format, and each repository_slug must be unique:","source_files:
  - repository_slug: IN/COM
    path: path/to/one/source/file.yml
  - repository_slug: IN/JOB
    path: path/to/another/source/file.yml","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer audit
        run: |
          gh actions-importer audit --config-file-path path/to/config-file.yml
",0
757,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=linux,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run a one-line script
      run: echo Hello, world!
",0
758,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=linux,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run hello world action
        uses: OWNER/REPO@SHA
        with:
          who-to-greet: ""Your Name""
",0
759,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=linux,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - name: Say Goodbye
      run: ./goodbye.sh
",0
760,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer,Migrating from Travis CI with GitHub Actions Importer - Reference - Using optional arguments - --config-file-path - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Travis CI. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit. To audit a Travis CI instance using a configuration file, the file must be in the following format and each repository_slug value must be unique:","source_files:
  - repository_slug: travis-org-name/travis-repo-name
    path: path/to/.travis.yml
  - repository_slug: travis-org-name/some-other-travis-repo-name
    path: path/to/.travis.yml","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer audit
        run: |
          gh actions-importer audit --config-file-path path/to/config.yml
",0
761,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers,Extending GitHub Actions Importer with custom transformers - Creating custom transformers for items - Example custom transformer for a build step,"You can create custom transformers that GitHub Actions Importer will use when converting existing build steps or triggers to their equivalent in GitHub Actions. This is especially useful when: GitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. In order to create custom transformers for build steps and triggers: The following example converts a build step that uses the ""buildJavaScriptApp"" identifier to run various npm commands: The above example results in the following GitHub Actions workflow step. It is comprised of converted build steps that had a buildJavaScriptApp identifier:","- name: build javascript app
  run: |
    npm run build
    npm run package
    npm run deploy","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Build JavaScript app
        run: npm run build
      - name: Run tests
        run: npm test
",0
762,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-nodejs-packages,Publishing Node.js packages - Publishing packages to the npm registry,"You can trigger a workflow to publish your package every time you publish a new release. The process in the following example is executed when the release event of type published is triggered. If the CI tests pass, the process uploads the package to the npm registry. For more information, see Managing releases in a repository . To perform authenticated operations against the npm registry in your workflow, you'll need to store your npm authentication token as a secret. For example, create a repository secret called NPM_TOKEN . For more information, see Using secrets in GitHub Actions . By default, npm uses the name field of the package.json file to determine the name of your published package. When publishing to a global namespace, you only need to include the package name. For example, you would publish a package named my-package to https://www.npmjs.com/package/my-package . If you're publishing a package that includes a scope prefix, include the scope in the name of your package.json file. For example, if your npm scope prefix is ""octocat"" and the package name is ""hello-world"", the name in your package.json file should be @octocat/hello-world . If your npm package uses a scope prefix and the package is public, you need to use the option npm publish --access public . This is an option that npm requires to prevent someone from publishing a private package unintentionally. If you would like to publish your package with provenance, include the --provenance flag with your npm publish command. This allows you to publicly and verifiably establish where and how your package was built, which increases supply chain security for people who consume your package. For more information, see Generating provenance statements in the npm documentation. This example stores the NPM_TOKEN secret in the NODE_AUTH_TOKEN environment variable. When the setup-node action creates an .npmrc file, it references the token from the NODE_AUTH_TOKEN environment variable.","name: Publish Package to npmjs
on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
      # Setup .npmrc file to publish to npm
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
      - run: npm ci
      - run: npm publish --provenance --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '16'
        registry-url: 'https://registry.npmjs.org'
    - run: npm ci
    - run: npm test
    - run: npm publish --access public --provenance
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
",0
763,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-nodejs-packages,Publishing Node.js packages - Publishing packages to GitHub Packages - Example workflow,"You can trigger a workflow to publish your package every time you publish a new release. The process in the following example is executed when the release event of type published is triggered. If the CI tests pass, the process uploads the package to GitHub Packages. For more information, see Managing releases in a repository . This example stores the GITHUB_TOKEN secret in the NODE_AUTH_TOKEN environment variable. When the setup-node action creates an .npmrc file, it references the token from the NODE_AUTH_TOKEN environment variable.","name: Publish package to GitHub Packages
on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      # Setup .npmrc file to publish to GitHub Packages
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://npm.pkg.github.com'
          # Defaults to the user or organization that owns the workflow file
          scope: '@octocat'
      - run: npm ci
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","on:
  release:
    types: [published]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        registry-url: 'https://npm.pkg.github.com'
    - name: Install dependencies
      run: npm install
    - name: Run tests
      run: npm test
    - name: Publish package
      env:
        NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: npm publish
",0
764,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-nodejs-packages,Publishing Node.js packages - Publishing packages using Yarn,"If you use the Yarn package manager, you can install and publish packages using Yarn.","name: Publish Package to npmjs
on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # Setup .npmrc file to publish to npm
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          # Defaults to the user or organization that owns the workflow file
          scope: '@octocat'
      - run: yarn
      - run: yarn npm publish // for Yarn version 1, use `yarn publish` instead
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'yarn'
      - name: Install dependencies
        run: yarn install
      - name: Publish package
        run: yarn publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
",0
765,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - run-name - Example of run-name,"The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's ""Actions"" tab. If run-name is omitted or is only whitespace, then the run name is set to event-specific information for the workflow run. For example, for a workflow triggered by a push or pull_request event, it is set as the commit message or the title of the pull request. This value can include expressions and can reference the github and inputs contexts.",run-name: Deploy to ${{ inputs.deploy_target }} by @${{ github.actor }},"run-name: Example of run-name
",0
766,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using a single event,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. For example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:",on: push,"on: push
",0
767,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using multiple events,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. You can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:","on: [push, fork]","on:
  push:
  fork:
",0
768,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using activity types,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.","on:
  label:
    types:
      - created","on:
  issue_comment:
    types: [created, edited, deleted]
  label:
    types: [created]
",0
769,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using activity types,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted. If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.","on:
  issues:
    types:
      - opened
      - labeled","on:
  issues:
    types: [opened, labeled]
",0
770,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using filters,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.","on:
  push:
    branches:
      - main
      - 'releases/**'","on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
771,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on - Using activity types and filters with multiple events,"To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows . You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections. If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon ( : ) to all events, including events without configuration. For example, a workflow with the following on value will run when:","on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:","on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
  pull_request:
    branches:
      - main
  schedule:
    - cron: '0 0 * * 0'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm test
",0
772,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<event_name>.types,"Use on.<event_name>.types to define the type of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the label is triggered when a label is created , edited , or deleted . The types keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the types keyword is unnecessary. You can use an array of event types . For more information about each event and their activity types, see Events that trigger workflows .","on:
  label:
    types: [created, edited]","on:
  label:
    types: [created, edited, deleted]
",0
773,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<pull_request|pull_request_target>.<branches|branches-ignore> - Example: Including branches,"When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'","on:
  pull_request:
    branches:
      - 'main'
      - 'release/*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm test
",0
774,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<pull_request|pull_request_target>.<branches|branches-ignore> - Example: Excluding branches,"When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'","on:
  pull_request:
    branches-ignore:
      - 'main'
      - 'release/*'
",0
775,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<pull_request|pull_request_target>.<branches|branches-ignore> - Example: Including and excluding branches,"When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. The order that you define patterns matters. The following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona , but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  pull_request:
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/**-alpha'
",0
776,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.push.<branches|tags|branches-ignore|tags-ignore> - Example: Including branches and tags,"When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*","on:
  push:
    branches:
      - 'main'
      - 'release/*'
    tags:
      - 'v*'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
777,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.push.<branches|tags|branches-ignore|tags-ignore> - Example: Excluding branches and tags,"When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*","on:
  push:
    branches-ignore:
      - 'main'
      - 'release/*'
    tags-ignore:
      - 'v*'
",0
778,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.push.<branches|tags|branches-ignore|tags-ignore> - Example: Including and excluding branches and tags,"When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead. The order that you define patterns matters. The following workflow will run on pushes to releases/10 or releases/beta/mona , but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  push:
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/**-alpha'
",0
779,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<push|pull_request|pull_request_target>.<paths|paths-ignore> - Example: Including paths,"When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . If at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file ( .js ).","on:
  push:
    paths:
      - '**.js'","on:
  push:
    paths:
      - '**/*.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, JavaScript!""
",0
780,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<push|pull_request|pull_request_target>.<paths|paths-ignore> - Example: Excluding paths,"When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . When all the path names match patterns in paths-ignore , the workflow will not run. If any path names do not match patterns in paths-ignore , even if some path names match the patterns, the workflow will run. A workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.","on:
  push:
    paths-ignore:
      - 'docs/**'","on:
  push:
    paths-ignore:
      - 'docs/**'
",0
781,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.<push|pull_request|pull_request_target>.<paths|paths-ignore> - Example: Including and excluding paths,"When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . You cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. If you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead. This example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.","on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'","on:
  push:
    paths:
      - sub-project/**
      - '!sub-project/docs/**'
",0
782,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.schedule,You can use on.schedule to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC:,"on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'","on:
  schedule:
    - cron: '30 5,17 * * *'
",0
783,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.schedule,"You can use on.schedule to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC: A single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.","on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo ""This step will be skipped on Monday and Wednesday""
      - name: Every time
        run: echo ""This step will always run""","on:
  schedule:
    - cron: '30 5 * * 1-4'
jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: ${{ github.event.schedule != '30 5 * * 1' && github.event.schedule != '30 5 * * 3' }}
        run: echo ""This step does not run on Monday or Wednesday""
      - name: Always runs
        run: echo ""This step runs every scheduled time""
",0
784,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_call.inputs - Example of on.workflow_call.inputs,"When using the workflow_call keyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow. For more information about the workflow_call keyword, see Events that trigger workflows . In addition to the standard input parameters that are available, on.workflow_call.inputs requires a type parameter. For more information, see on.workflow_call.inputs.<input_id>.type . If a default parameter is not set, the default value of the input is false for a boolean, 0 for a number, and """" for a string. Within the called workflow, you can use the inputs context to refer to an input. For more information, see Accessing contextual information about workflow runs . If a caller workflow passes an input that is not specified in the called workflow, this results in an error.","on:
  workflow_call:
    inputs:
      username:
        description: 'A username passed from the caller workflow'
        default: 'john-doe'
        required: false
        type: string

jobs:
  print-username:
    runs-on: ubuntu-latest

    steps:
      - name: Print the input name to STDOUT
        run: echo The username is ${{ inputs.username }}","on:
  workflow_call:
    inputs:
      example_input:
        type: string
        default: ""default_value""
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""Input value: ${{ inputs.example_input }}""
",0
785,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_call.outputs - Example of on.workflow_call.outputs,"A map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optional description, and a value. The value must be set to the value of an output from a job within the called workflow. In the example below, two outputs are defined for this reusable workflow: workflow_output1 and workflow_output2 . These are mapped to outputs called job_output1 and job_output2 , both from a job called my_job .","on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      workflow_output1:
        description: ""The first job output""
        value: ${{ jobs.my_job.outputs.job_output1 }}
      workflow_output2:
        description: ""The second job output""
        value: ${{ jobs.my_job.outputs.job_output2 }}","on:
  workflow_call:
    outputs:
      workflow_output1:
        description: 'Description for workflow_output1'
        value: ${{ jobs.my_job.outputs.job_output1 }}
      workflow_output2:
        description: 'Description for workflow_output2'
        value: ${{ jobs.my_job.outputs.job_output2 }}
jobs:
  my_job:
    runs-on: ubuntu-latest
    outputs:
      job_output1: ${{ steps.step1.outputs.output1 }}
      job_output2: ${{ steps.step2.outputs.output2 }}
    steps:
      - id: step1
        run: echo ""::set-output name=output1::value1""
      - id: step2
        run: echo ""::set-output name=output2::value2""
",0
786,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_call.secrets - Example of on.workflow_call.secrets,"A map of the secrets that can be used in the called workflow. Within the called workflow, you can use the secrets context to refer to a secret. Note  If you are passing the secret to a nested reusable workflow, then you must usejobs.<job_id>.secretsagain to pass the secret. For more information, seeReusing workflows. Note If you are passing the secret to a nested reusable workflow, then you must use jobs.<job_id>.secrets again to pass the secret. For more information, see Reusing workflows . If a caller workflow passes a secret that is not specified in the called workflow, this results in an error.","on:
  workflow_call:
    secrets:
      access-token:
        description: 'A token passed from the caller workflow'
        required: false

jobs:

  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
    # passing the secret to an action
      - name: Pass the received secret to an action
        uses: ./.github/actions/my-action
        with:
          token: ${{ secrets.access-token }}

  # passing the secret to a nested reusable workflow
  pass-secret-to-workflow:
    uses: ./.github/workflows/my-workflow
    secrets:
       token: ${{ secrets.access-token }}","on:
  workflow_call:
    secrets:
      my_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print secret
        run: echo ${{ secrets.my_secret }}
",0
787,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_run.<branches|branches-ignore>,"When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - releases/**
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
788,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_run.<branches|branches-ignore>,"When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches-ignore:
      - ""canary""","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - ""releases/*""
    branches-ignore:
      - ""canary""
",0
789,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_run.<branches|branches-ignore>,"When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary : You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. The order that you define patterns matters. For example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha , releases/beta/3-alpha , or main .","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/10-alpha'
      - '!releases/beta/3-alpha'
      - '!main'
",0
790,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - on.workflow_dispatch.inputs - Example of on.workflow_dispatch.inputs,"The triggered workflow receives the inputs in the inputs context. For more information, see Contexts . Note    The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.The maximum number of top-level properties forinputsis 10.The maximum payload forinputsis 65,535 characters. Note","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
      print_tags:
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    if: ${{ inputs.print_tags }} 
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }}","on:
  workflow_dispatch:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        default: 'default_value'
        type: string

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print input
        run: echo ""Input value: ${{ github.event.inputs.example_input }}""
",0
791,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key.","permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none","permissions:
  contents: read
  issues: write
  pull-requests: none
",0
792,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: read-all,"permissions:
  contents: write
",0
793,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: write-all,"permissions:
  contents: read
",0
794,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Defining access for the GITHUB_TOKEN scopes,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions:",permissions: {},"permissions: {}
",0
795,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - permissions - Setting the GITHUB_TOKEN permissions for all jobs in a workflow - Example: Setting the GITHUB_TOKEN permissions for an entire workflow,"You can use permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can specify permissions at the top level of a workflow, so that the setting applies to all jobs in the workflow. This example shows permissions being set for the GITHUB_TOKEN that will apply to all jobs in the workflow. All permissions are granted read access.","name: ""My workflow""

on: [ push ]

permissions: read-all

jobs:
  ...","permissions:
  actions: read
  checks: read
  contents: read
  deployments: read
  issues: read
  packages: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read
",0
796,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - env - Example of env,"A map of variables that are available to the steps of all jobs in the workflow. You can also set variables that are only available to the steps of a single job or to a single step. For more information, see jobs.<job_id>.env and jobs.<job_id>.steps[*].env . Variables in the env map cannot be defined in terms of other variables in the map. When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.","env:
  SERVER: production","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      GLOBAL_VAR: global_value
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Print global variable
        run: echo $GLOBAL_VAR
      - name: Set job-specific variable
        env:
          JOB_VAR: job_value
        run: echo $JOB_VAR
      - name: Set step-specific variable
        env:
          STEP_VAR: step_value
        run: echo $STEP_VAR
",0
797,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - defaults.run - Example: Set the default shell and working directory,"You can use defaults.run to provide default shell and working-directory options for all run steps in a workflow. You can also set default settings for run that are only available to a job. For more information, see jobs.<job_id>.defaults.run . You cannot use contexts or expressions in this keyword. When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","defaults:
  run:
    shell: bash
    working-directory: ./scripts","jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./my-directory
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: ./script.sh
",0
798,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using concurrency and the default behavior,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:","on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true
",0
799,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using concurrency and the default behavior,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch: You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:","on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true
jobs:
  example-job:
    runs-on: ubuntu-latest
    concurrency:
      group: my-job-concurrency-group
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
800,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Concurrency groups,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.","jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job-1""
",0
801,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Concurrency groups,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled. Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:","on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
802,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using concurrency to cancel any in-progress job or run,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true :","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true
",0
803,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Using a fallback value,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.head_ref || github.run_id }}
      cancel-in-progress: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
804,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Only cancel in-progress jobs or runs for the current workflow,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow. To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}
      cancel-in-progress: true
",0
805,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - concurrency - Example: Only cancel in-progress jobs on specific branches,"Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github , inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches. To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: ${{ !startsWith(github.ref, 'refs/heads/release/') }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job""
",0
806,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id> - Example: Creating jobs,"Use jobs.<job_id> to give your job a unique identifier. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, - , or _ . In this example, two jobs have been created, and their job_id values are my_first_job and my_second_job .","jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
  my_second_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a different script
        run: echo ""This is my second job""
",0
807,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key.","permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none","jobs:
  example_job:
    permissions:
      contents: read
      issues: write
      actions: none
",0
808,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: read-all,"jobs:
  example_job:
    permissions:
      contents: read
      issues: write
",0
809,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: write-all,"jobs:
  example_job:
    permissions:
      contents: read
      issues: write
",0
810,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions:",permissions: {},"jobs:
  example_job:
    permissions:
      contents: read
",0
811,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.permissions - Defining access for the GITHUB_TOKEN scopes - Example: Setting the GITHUB_TOKEN permissions for one job in a workflow,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write , or none . write includes read . If you specify the access for any of these permissions, all of those that are not specified are set to none . Available permissions and details of what each allows an action to do: You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions: This example shows permissions being set for the GITHUB_TOKEN that will only apply to the job named stale . Write access is granted for the issues and pull-requests permissions. All other permissions will have no access.","jobs:
  stale:
    runs-on: ubuntu-latest

    permissions:
      issues: write
      pull-requests: write

    steps:
      - uses: actions/stale@v9","jobs:
  stale:
    permissions:
      issues: write
      pull-requests: write
",0
812,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.needs - Example: Requiring successful dependent jobs,"Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if .","jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building project""

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo ""Running tests""

  deploy:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - run: echo ""Deploying application""
",0
813,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.needs - Example: Not requiring successful dependent jobs,"Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if .","jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Job 1""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    if: always()
    steps:
      - run: echo ""Job 2""
",0
814,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.if,"You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . Note  Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied. Note The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","jobs:
  example_job:
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
815,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.if - Example: Only run job for specific repository,"You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . Note  Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied. Note The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied. When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . This example uses if to control when the production-deploy job can run. It will only run if the repository is named octo-repo-prod and is within the octo-org organization. Otherwise, the job will be marked as skipped .","name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats","jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
816,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu :","runs-on: [self-hosted, linux, x64, gpu]","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
817,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example:","on:
  workflow_dispatch:
    inputs:
      chosen-os:
        required: true
        type: choice
        options:
        - Ubuntu
        - macOS

jobs:
  test:
    runs-on: [self-hosted, ""${{ inputs.chosen-os }}""]
    steps:
    - run: echo Hello world!","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
818,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Standard GitHub-hosted runners for  private repositories - Example: Specifying an operating system,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions . In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners . Note  The-latestrunner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor. The -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor. Warning  Beta and Deprecated Images are provided ""as-is"", ""with all faults"" and ""as available"" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support. Warning Beta and Deprecated Images are provided ""as-is"", ""with all faults"" and ""as available"" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.",runs-on: ubuntu-latest,"jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
819,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Choosing self-hosted runners - Example: Using labels for runner selection,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels. Self-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted . You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify. Note that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.","runs-on: [self-hosted, linux]","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
820,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Choosing runners in a group - Example: Using groups to control where jobs are run,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels. Runner groups can only have larger runners or self-hosted runners as members. In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [self-hosted, linux, x64, gpu]
",0
821,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.runs-on - Choosing runners in a group - Example: Combining groups and labels,"Use jobs.<job_id>.runs-on to define the type of machine to run the job on. You can target runners based on the labels assigned to them, or their group membership, or a combination of these. You can provide runs-on as: If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux , x64 , and gpu : For more information, see Choosing self-hosted runners . You can mix strings and variables in an array. For example: If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy . Note  Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like""${{ inputs.chosen-os }}"". Note Quotation marks are not required around simple strings like self-hosted , but they are required for expressions like ""${{ inputs.chosen-os }}"" . You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels. Runner groups can only have larger runners or self-hosted runners as members. When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example_job:
    runs-on: [ubuntu-runners, ubuntu-20.04-16core]
",0
822,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using a single environment name,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .",environment: staging_environment,"jobs:
  example_job:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
823,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using environment name and URL,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .","environment:
  name: production_environment
  url: https://github.com","jobs:
  example_job:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
824,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using output as URL,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .","environment:
  name: production_environment
  url: ${{ steps.step_id.outputs.url_output }}","jobs:
  example_job:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run deployment script
        run: ./deploy.sh
",0
825,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.environment - Example: Using an expression as environment name,"Use jobs.<job_id>.environment to define the environment that the job references. You can provide the environment as only the environment name , or as an environment object with the name and url . The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories . Note  All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment. Note All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment .","environment:
  name: ${{ github.ref_name }}","jobs:
  example_job:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
826,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:","on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example-group
      cancel-in-progress: true
",0
827,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch: You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:","on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example-group
      cancel-in-progress: true
",0
828,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.","jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
829,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled. Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:","on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
830,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using concurrency to cancel any in-progress job or run,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true :","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: example-group
      cancel-in-progress: true
",0
831,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Using a fallback value,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.head_ref || github.run_id }}
      cancel-in-progress: ${{ github.event_name == 'pull_request' }}
",0
832,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Only cancel in-progress jobs or runs for the current workflow,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow. To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}
      cancel-in-progress: true
",0
833,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.concurrency - Example: Only cancel in-progress jobs on specific branches,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches. To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: ${{ !startsWith(github.ref, 'refs/heads/release/') }}
",0
834,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.outputs - Example: Defining outputs for a job,"You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs . Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions. If an output is skipped because it may contain a secret, you will see the following warning message: ""Skip output {output.Key} since it may contain secret."" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows . To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs .","jobs:
  job1:
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      output1: ${{ steps.step1.outputs.test }}
      output2: ${{ steps.step2.outputs.test }}
    steps:
      - id: step1
        run: echo ""test=hello"" >> ""$GITHUB_OUTPUT""
      - id: step2
        run: echo ""test=world"" >> ""$GITHUB_OUTPUT""
  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - env:
          OUTPUT1: ${{needs.job1.outputs.output1}}
          OUTPUT2: ${{needs.job1.outputs.output2}}
        run: echo ""$OUTPUT1 $OUTPUT2""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""output_value"" > output.txt
      - name: Set output
        id: set_output
        run: echo ""::set-output name=my_output::$(cat output.txt)""
    outputs:
      my_output: ${{ steps.set_output.outputs.my_output }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Use output
        run: echo ""The output from the build job is ${{ needs.build.outputs.my_output }}""
",0
835,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.outputs - Using Job Outputs in a Matrix Job,"You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs . Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding. Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions. If an output is skipped because it may contain a secret, you will see the following warning message: ""Skip output {output.Key} since it may contain secret."" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows . To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs . Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.","jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      output_1: ${{ steps.gen_output.outputs.output_1 }}
      output_2: ${{ steps.gen_output.outputs.output_2 }}
      output_3: ${{ steps.gen_output.outputs.output_3 }}
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - name: Generate output
        id: gen_output
        run: |
          version=""${{ matrix.version }}""
          echo ""output_${version}=${version}"" >> ""$GITHUB_OUTPUT""
  job2:
    runs-on: ubuntu-latest
    needs: [job1]
    steps:
      # Will show
      # {
      #   ""output_1"": ""1"",
      #   ""output_2"": ""2"",
      #   ""output_3"": ""3""
      # }
      - run: echo '${{ toJSON(needs.job1.outputs) }}'","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [12, 14, 16]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set output
        id: set_output
        run: echo ""::set-output name=node_version::${{ matrix.node }}""
    outputs:
      node_version: ${{ steps.set_output.outputs.node_version }}

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Use node version
        run: echo ""Node version from build job: ${{ needs.build.outputs.node_version }}""
",0
836,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.env - Example of jobs.<job_id>.env,"A map of variables that are available to all steps in the job. You can set variables for the entire workflow or an individual step. For more information, see env and jobs.<job_id>.steps[*].env . When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.","jobs:
  job1:
    env:
      FIRST_NAME: Mona","jobs:
  example_job:
    runs-on: ubuntu-latest
    env:
      JOB_VAR: job_value
    steps:
      - name: Print job variable
        run: echo $JOB_VAR
",0
837,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.defaults.run.working-directory - Example: Setting default run step options for a job,"Use working-directory to define the working directory for the shell for a step. This keyword can reference several contexts. For more information, see Contexts . Tip  Ensure theworking-directoryyou assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow. Tip Ensure the working-directory you assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.","jobs:
  job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts","jobs:
  example-job:
    defaults:
      run:
        working-directory: ./my-directory
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: ./script.sh
",0
838,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps - Example of jobs.<job_id>.steps,"A job contains a sequence of tasks called steps . Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job. GitHub only displays the first 1,000 checks, however, you can run an unlimited number of steps as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and Usage limits for self-hosted runners for self-hosted runner usage limits.","name: Greeting from Mona

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - name: Print a greeting
        env:
          MY_VAR: Hi there! My name is
          FIRST_NAME: Mona
          MIDDLE_NAME: The
          LAST_NAME: Octocat
        run: |
          echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
839,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example:","if: ${{ ! startsWith(github.ref, 'refs/tags/') }}","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""This step runs conditionally""
        if: success() && github.event_name == 'push'
",0
840,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if - Example: Using contexts,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . This step only runs when the event type is a pull_request and the event action is unassigned .","steps:
  - name: My first step
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}
    run: echo This event is a pull request that had an assignee removed.","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Example Step
        if: github.event_name == 'pull_request' && github.event.action == 'unassigned'
        run: echo ""This step runs only when a pull request is unassigned.""
",0
841,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if - Example: Using status check functions,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . The my backup step only runs when the previous step of a job fails. For more information, see Evaluate expressions in workflows and actions .","steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: My backup step
        if: failure()
        run: echo ""This step runs only if the previous step fails""
",0
842,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].if - Example: Using secrets,"You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs . When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere. You must always use the ${{ }} expression syntax or escape with '' , """" , or () when the expression starts with ! , since ! is reserved notation in YAML format. For example: For more information, see Evaluate expressions in workflows and actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string.","name: Run a step if a secret has been set
on: push
jobs:
  my-jobname:
    runs-on: ubuntu-latest
    env:
      super_secret: ${{ secrets.SuperSecret }}
    steps:
      - if: ${{ env.super_secret != '' }}
        run: echo 'This step will only run if the secret has a value set.'
      - if: ${{ env.super_secret == '' }}
        run: echo 'This step will only run if the secret does not have a value set.'","jobs:
  example_job:
    runs-on: ubuntu-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run step if secret is set
        if: env.SUPER_SECRET != ''
        run: echo ""Secret is set""
",0
843,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using versioned actions,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on .","steps:
  # Reference a specific commit
  - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
  # Reference the major version of a release
  - uses: actions/checkout@v4
  # Reference a specific version
  - uses: actions/checkout@v4.2.0
  # Reference a branch
  - uses: actions/checkout@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v3
        with:
          node-version: '14'
      - uses: docker://alpine:3.14
",0
844,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a public action,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . {owner}/{repo}@{ref} You can specify a branch, ref, or SHA in a public GitHub repository.","jobs:
  my_first_job:
    steps:
      - name: My first step
        # Uses the default branch of a public repository
        uses: actions/heroku@main
      - name: My second step
        # Uses a specific version tag of a public repository
        uses: actions/aws@v2.0.1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '14'
      - uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: user/repo:latest
",0
845,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a public action in a subdirectory,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . {owner}/{repo}/{path}@{ref} A subdirectory in a public GitHub repository at a specific branch, ref, or SHA.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/aws/ec2@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: owner/repo/path@ref
",0
846,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using an action in the same repository as the workflow,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . ./path/to/dir The path to the directory that contains the action in your workflow's repository. You must check out your repository before using the action. Example repository file structure: The path is relative ( ./ ) to the default working directory ( github.workspace , $GITHUB_WORKSPACE ). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated. Example workflow file:","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run local action
        uses: ./path/to/dir
",0
847,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a Docker Hub action,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . docker://{image}:{tag} A Docker image published on Docker Hub .","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://{image}:{tag}
",0
848,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using the GitHub Packages Container registry,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . docker://{host}/{image}:{tag} A public Docker image in the GitHub Packages Container registry.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://ghcr.io/OWNER/IMAGE_NAME","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://ghcr.io/owner/repo:tag
",0
849,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using a Docker public registry action,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . docker://{host}/{image}:{tag} A Docker image in a public registry. This example uses the Google Container Registry at gcr.io .","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://gcr.io/cloud-builders/gradle","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://gcr.io/my-image:latest
",0
850,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].uses - Example: Using an action inside a different private repository than the workflow,"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image . We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update. Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required. Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on . Your workflow must checkout the private repository and reference the action locally. Generate a personal access token and add the token as a secret. For more information, see Managing your personal access tokens and Using secrets in GitHub Actions . Replace PERSONAL_ACCESS_TOKEN in the example with the name of your secret.","jobs:
  my_first_job:
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          repository: octocat/my-private-repo
          ref: v1.0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          path: ./.github/actions/my-private-repo
      - name: Run my action
        uses: ./.github/actions/my-private-repo/my-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
      - name: Use action from private repository
        uses: owner/repo-name/path/to/action@v1
",0
851,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].run,"Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a name , the step name will default to the text specified in the run command. Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see jobs.<job_id>.steps[*].shell . Each run keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example: A single-line command:",#NAME?,"jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
852,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].run,"Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a name , the step name will default to the text specified in the run command. Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see jobs.<job_id>.steps[*].shell . Each run keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example: A single-line command: A multi-line command:","- name: Clean install dependencies and build
  run: |
    npm ci
    npm run build","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
      - run: |
          echo ""This is a multi-line command""
          echo ""Running in the same shell""
",0
853,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].working-directory,"Using the working-directory keyword, you can specify the working directory of where to run the command.","- name: Clean temp directory
  run: rm -rf *
  working-directory: ./temp","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        working-directory: ./src
      - name: Run script
        run: ./script.sh
        working-directory: ./scripts
",0
854,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running a command using Bash,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: bash
    run: echo $PATH","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run a command using Bash
        run: echo ""Hello, World!""
        shell: bash
",0
855,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running a command using Windows cmd,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: cmd
    run: echo %PATH%","jobs:
  example_job:
    runs-on: windows-latest
    steps:
      - run: echo Hello, World!
        shell: cmd
",0
856,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running a command using PowerShell Core,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: pwsh
    run: echo ${env:PATH}","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run a command using PowerShell Core
        run: |
          Write-Host ""Hello, PowerShell Core!""
        shell: pwsh
",0
857,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Using PowerShell Desktop to run a command,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: powershell
    run: echo ${env:PATH}","jobs:
  example_job:
    runs-on: windows-latest
    steps:
      - run: Write-Host ""Hello, PowerShell!""
        shell: pwsh
",0
858,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Example: Running an inline Python script,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell .","steps:
  - name: Display the path
    shell: python
    run: |
      import os
      print(os.environ['PATH'])","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run inline Python script
        shell: python
        run: |
          print(""Hello, World!"")
",0
859,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].shell - Custom shell,"You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword. Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell . You can set the shell value to a template string using command [options] {0} [more_options] . GitHub interprets the first whitespace-delimited word of the string as the command, and inserts the file name for the temporary script at {0} . For example:","steps:
  - name: Display the environment variables and their values
    shell: perl {0}
    run: |
      print %ENV","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
        shell: bash -c ""{0}""
",0
860,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].with - Example of jobs.<job_id>.steps[*].with,"A map of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed with INPUT_ and converted to upper case. Input parameters defined for a Docker container must use args . For more information, see jobs.<job_id>.steps[*].with.args . Defines the three input parameters ( first_name , middle_name , and last_name ) defined by the hello_world action. These input variables will be accessible to the hello-world action as INPUT_FIRST_NAME , INPUT_MIDDLE_NAME , and INPUT_LAST_NAME environment variables.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/hello_world@main
        with:
          first_name: Mona
          middle_name: The
          last_name: Octocat","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Hello World Action
        uses: actions/hello-world@v1
        with:
          first_name: John
          middle_name: F.
          last_name: Doe
",0
861,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].with.args - Example of jobs.<job_id>.steps[*].with.args,"A string that defines the inputs for a Docker container. GitHub passes the args to the container's ENTRYPOINT when the container starts up. An array of strings is not supported by this parameter. A single argument that includes spaces should be surrounded by double quotes """" .","steps:
  - name: Explain why this job ran
    uses: octo-org/action-name@main
    with:
      entrypoint: /bin/echo
      args: The ${{ github.event_name }} event triggered this step.","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run Docker container with args
        uses: docker://alpine:latest
        with:
          args: ""echo Hello, World!""
",0
862,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].with.entrypoint - Example of jobs.<job_id>.steps[*].with.entrypoint,"Overrides the Docker ENTRYPOINT in the Dockerfile , or sets it if one wasn't already specified. Unlike the Docker ENTRYPOINT instruction which has a shell and exec form, entrypoint keyword accepts only a single string defining the executable to be run.","steps:
  - name: Run a custom command
    uses: octo-org/action-name@main
    with:
      entrypoint: /a/different/executable","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Run Docker container with custom entrypoint
        uses: docker://alpine:latest
        with:
          entrypoint: ""/bin/sh""
",0
863,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.steps[*].env - Example of jobs.<job_id>.steps[*].env,"Sets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job. For more information, see env and jobs.<job_id>.env . When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes. Public actions may specify expected variables in the README file. If you are setting a secret or sensitive value, such as a password or token, you must set secrets using the secrets context. For more information, see Accessing contextual information about workflow runs .","steps:
  - name: My first action
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      FIRST_NAME: Mona
      LAST_NAME: Octocat","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Example Step
        env:
          EXAMPLE_VAR: example_value
        run: echo $EXAMPLE_VAR
",0
864,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] :","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  build:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
",0
865,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a single-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify a single variable to create a single-dimension matrix. For example, the following workflow defines the variable version with the values [10, 12, 14] . The workflow will run three jobs, one for each value in the variable. Each job will access the version value through the matrix.version context and pass the value as node-version to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
866,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
867,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s.","matrix:
  os:
    - ubuntu-latest
    - macos-latest
  node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
868,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s. This matrix produces 4 jobs with corresponding contexts.","- matrix.os: ubuntu-latest
  matrix.node.version: 14
- matrix.os: ubuntu-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
  matrix.node.version: 14
- matrix.os: macos-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
",0
869,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix - Example: Using contexts to create matrices,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs . For example, the following workflow triggers on the repository_dispatch event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix version variable will have a value of [12, 14, 16] . For more information about the repository_dispatch trigger, see Events that trigger workflows .","on:
  repository_dispatch:
    types:
      - test
 
jobs:
  example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        version: [12, 14, 16]
        os: [ubuntu-latest, windows-latest]
",0
870,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix:","strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
          - os: windows-latest
            node: 14
          - os: ubuntu-latest
            node: 16
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
871,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include - Example: Expanding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, the following workflow will run four jobs, one for each combination of os and node . When the job for the os value of windows-latest and node value of 16 runs, an additional variable called npm with the value of 6 will be included in the job.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
872,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 .","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [14, 16]
        include:
          - os: windows-latest
            version: 17
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
873,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.include - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 . If you don't specify any matrix variables, all configurations under include will run. For example, the following workflow would run two jobs, one for each include entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.","jobs:
  includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: ""production""
            datacenter: ""site-a""
          - site: ""staging""
            datacenter: ""site-b""","jobs:
  example-job:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            version: 16
          - os: windows-latest
            version: 17
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on ${{ matrix.os }} with version ${{ matrix.version }}""
",0
874,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.matrix.exclude,"To remove specific configurations defined in the matrix, use jobs.<job_id>.strategy.matrix.exclude . An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches {os: macos-latest, version: 12, environment: production} , and the two excluded jobs that match {os: windows-latest, version: 16} .","strategy:
  matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [12, 14, 16]
        environment: [development, production]
        exclude:
          - os: macos-latest
            version: 12
            environment: production
          - os: windows-latest
            version: 16
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on ${{ matrix.os }} with version ${{ matrix.version }} in ${{ matrix.environment }} environment""
",0
875,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.fail-fast,"You can control how job failures are handled with jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error . jobs.<job_id>.strategy.fail-fast applies to the entire matrix. If jobs.<job_id>.strategy.fail-fast is set to true or its expression evaluates to true , GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to true . jobs.<job_id>.continue-on-error applies to a single job. If jobs.<job_id>.continue-on-error is true , other jobs in the matrix will continue running even if the job with jobs.<job_id>.continue-on-error: true fails. You can use jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error together. For example, the following workflow will start four jobs. For each job, continue-on-error is determined by the value of matrix.experimental . If any of the jobs with continue-on-error: false fail, all jobs that are in progress or queued will be cancelled. If the job with continue-on-error: true fails, the other jobs will not be affected.","jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true","jobs:
  example:
    strategy:
      fail-fast: true
      matrix:
        experimental: [true, false]
    steps:
      - name: Run a job
        run: echo ""Running job""
    continue-on-error: ${{ matrix.experimental }}
",0
876,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.strategy.max-parallel,"By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a matrix job strategy, use jobs.<job_id>.strategy.max-parallel . For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.","jobs:
  example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  example-job:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node: [12, 14]
      max-parallel: 2
    runs-on: ${{ matrix.os }}
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
877,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.continue-on-error - Example: Preventing a specific failing matrix job from failing a workflow run,"Prevents a workflow run from failing when a job fails. Set to true to allow a workflow run to pass when this job fails. You can allow specific jobs in a job matrix to fail without failing the workflow run. For example, if you wanted to only allow an experimental job with node set to 15 to fail without failing the workflow run.","runs-on: ${{ matrix.os }}
continue-on-error: ${{ matrix.experimental }}
strategy:
  fail-fast: false
  matrix:
    node: [13, 14]
    os: [macos-latest, ubuntu-latest]
    experimental: [false]
    include:
      - node: 15
        os: ubuntu-latest
        experimental: true","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [12, 14, 15]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
    continue-on-error: ${{ matrix.node == 15 }}
",0
878,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container - Example: Running a job within a container,"Note  If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:  If you are using GitHub-hosted runners, you must use an Ubuntu runner.If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed. Note If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner: Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell .","name: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:20.04
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
879,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container - Example: Running a job within a container,"Note  If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:  If you are using GitHub-hosted runners, you must use an Ubuntu runner.If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed. Note If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner: Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts. If you do not set a container , all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container. Note  The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell. The default shell for run steps inside a container is sh instead of bash . This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell . When you only specify a container image, you can omit the image keyword.","jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container: node:18","jobs:
  example-job:
    runs-on: ubuntu-latest
    container: node:14
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script
        run: echo ""Hello, world!""
",0
880,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container.credentials - Example: Defining credentials for a container registry,"If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password . The credentials are the same values that you would provide to the docker login command.","container:
  image: ghcr.io/owner/image
  credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: my-container-image:latest
      credentials:
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
    steps:
      - name: Check out code
        uses: actions/checkout@v2
",0
881,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.container.volumes - Example: Mounting volumes in a container,"Use jobs.<job_id>.container.volumes to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host. To specify a volume, you specify the source and destination path: <source>:<destinationPath> . The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.","volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: node:14
      volumes:
        - /host/path:/container/path
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
882,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services - Example: Using localhost,"Note  If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:  If you are using GitHub-hosted runners, you must use an Ubuntu runner.If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed. Note If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner: Used to host service containers for a job in a workflow. Service containers are useful for creating databases or cache services like Redis. The runner automatically creates a Docker network and manages the life cycle of the service containers. If you configure your job to run in a container, or your step uses container actions, you don't need to map ports to access the service or action. Docker automatically exposes all ports between containers on the same Docker user-defined bridge network. You can directly reference the service container by its hostname. The hostname is automatically mapped to the label name you configure for the service in the workflow. If you configure the job to run directly on the runner machine and your step doesn't use a container action, you must map any required Docker service container ports to the Docker host (the runner machine). You can access the service container using localhost and the mapped port. For more information about the differences between networking service containers, see About service containers . This example creates two services: nginx and redis. When you specify the container port but not the host port, the container port is randomly assigned to a free port on the host. GitHub sets the assigned host port in the ${{job.services.<service_name>.ports}} context. In this example, you can access the service host ports using the ${{ job.services.nginx.ports['80'] }} and ${{ job.services.redis.ports['6379'] }} contexts.","services:
  nginx:
    image: nginx
    # Map port 8080 on the Docker host to port 80 on the nginx container
    ports:
      - 8080:80
  redis:
    image: redis
    # Map random free TCP port on Docker host to port 6379 on redis container
    ports:
      - 6379/tcp
steps:
  - run: |
      echo ""Redis available on 127.0.0.1:${{ job.services.redis.ports['6379'] }}""
      echo ""Nginx available on 127.0.0.1:${{ job.services.nginx.ports['80'] }}""","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      nginx:
        image: nginx:latest
        ports:
          - 80
      redis:
        image: redis:latest
        ports:
          - 6379
    steps:
      - name: Check nginx and redis
        run: |
          echo ""Nginx is running on port ${{ job.services.nginx.ports['80'] }}""
          echo ""Redis is running on port ${{ job.services.redis.ports['6379'] }}""
",0
883,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services.<service_id>.image,"The Docker image to use as the service container to run the action. The value can be the Docker Hub image name or a registry name. If jobs.<job_id>.services.<service_id>.image is assigned an empty string, the service will not start. You can use this to set up conditional services, similar to the following example.","services:
  nginx:
    image: ${{ options.nginx == true && 'nginx' || '' }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      my-service:
        image: ''
",0
884,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services.<service_id>.credentials - Example of jobs.<job_id>.services.<service_id>.credentials,"If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password . The credentials are the same values that you would provide to the docker login command.","services:
  myservice1:
    image: ghcr.io/owner/myservice1
    credentials:
      username: ${{ github.actor }}
      password: ${{ secrets.github_token }}
  myservice2:
    image: dockerhub_org/myservice2
    credentials:
      username: ${{ secrets.DOCKER_USER }}
      password: ${{ secrets.DOCKER_PASSWORD }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      example-service:
        image: example-image:latest
        credentials:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
",0
885,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.services.<service_id>.volumes - Example of jobs.<job_id>.services.<service_id>.volumes,"Sets an array of volumes for the service container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host. To specify a volume, you specify the source and destination path: <source>:<destinationPath> . The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.","volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      example-service:
        image: some-docker-image:latest
        volumes:
          - my-named-volume:/path/in/container
          - /host/path:/path/in/container
",0
886,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.uses - Example of jobs.<job_id>.uses,"The location and version of a reusable workflow file to run as a job. Use one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword.","jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1","jobs:
  example_job:
    uses: owner/repo/.github/workflows/workflow.yml@main
",0
887,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.with - Example of jobs.<job_id>.with,"When a job is used to call a reusable workflow, you can use with to provide a map of inputs that are passed to the called workflow. Any inputs that you pass must match the input specifications defined in the called workflow. Unlike jobs.<job_id>.steps[*].with , the inputs you pass with jobs.<job_id>.with are not available as environment variables in the called workflow. Instead, you can reference the inputs by using the inputs context.","jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    with:
      username: mona","jobs:
  example_job:
    uses: owner/repo/.github/workflows/called-workflow.yml@main
    with:
      input1: value1
      input2: value2
",0
888,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.secrets - Example of jobs.<job_id>.secrets,"When a job is used to call a reusable workflow, you can use secrets to provide a map of secrets that are passed to the called workflow. Any secrets that you pass must match the names defined in the called workflow.","jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    secrets:
      access-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}","jobs:
  example_job:
    uses: ./.github/workflows/reusable-workflow.yml
    secrets:
      SECRET_NAME: ${{ secrets.SECRET_NAME }}
",0
889,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.secrets.inherit - Example of jobs.<job_id>.secrets.inherit,"Use the inherit keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The inherit keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.","on:
  workflow_dispatch:

jobs:
  pass-secrets-to-workflow:
    uses: ./.github/workflows/called-workflow.yml
    secrets: inherit","jobs:
  example_job:
    secrets:
      inherit: true
",0
890,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - jobs.<job_id>.secrets.inherit - Example of jobs.<job_id>.secrets.inherit,"Use the inherit keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The inherit keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.","on:
  workflow_call:

jobs:
  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
      - name: Use a repo or org secret from the calling workflow.
        run: echo ${{ secrets.CALLING_WORKFLOW_SECRET }}","jobs:
  example_job:
    secrets:
      inherit: true
",0
891,https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions,Workflow syntax for GitHub Actions - Filter pattern cheat sheet,"You can use special characters in path, branch, and tag filters. The characters * , [ , and ! are special characters in YAML. If you start a pattern with * , [ , or ! , you must enclose the pattern in quotes. Also, if you use a flow sequence with a pattern containing [ and/or ] , the pattern must be enclosed in quotes.","# Valid
paths:
  - '**/README.md'

# Invalid - creates a parse error that
# prevents your workflow from running.
paths:
  - **/README.md

# Valid
branches: [ main, 'release/v[0-9].[0-9]' ]

# Invalid - creates a parse error
branches: [ main, release/v[0-9].[0-9] ]","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
892,https://docs.github.com/en/actions/managing-issues-and-pull-requests/commenting-on-an-issue-when-a-label-is-added,Commenting on an issue when a label is added - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Add comment
on:
  issues:
    types:
      - labeled
jobs:
  add-comment:
    if: github.event.label.name == 'help wanted'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Add comment
        run: gh issue comment ""$NUMBER"" --body ""$BODY""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          NUMBER: ${{ github.event.issue.number }}
          BODY: >
            This issue is available for anyone to work on.
            **Make sure to reference this issue in your pull request.**
            :sparkles: Thank you for your contribution! :sparkles:","on:
  issues:
    types: [labeled]
jobs:
  comment_on_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Comment on issue
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'A label was added to this issue.'
            })
",0
893,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-pypi,Configuring OpenID Connect in PyPI - Updating your GitHub Actions workflow,"Once your trusted publisher is registered on PyPI, you can update your release workflow to use trusted publishing. Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The pypa/gh-action-pypi-publish action has built-in support for trusted publishing, which can be enabled by giving its containing job the id-token: write permission and omitting username and password . The following example uses the pypa/gh-action-pypi-publish action to exchange an OIDC token for a PyPI API token, which is then used to upload a package's release distributions to PyPI.","jobs:
  release-build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ""3.x""

      - name: build release distributions
        run: |
          # NOTE: put your own distribution build steps here.
          python -m pip install build
          python -m build

      - name: upload windows dists
        uses: actions/upload-artifact@v4
        with:
          name: release-dists
          path: dist/

  pypi-publish:
    runs-on: ubuntu-latest
    needs:
      - release-build
    permissions:
      id-token: write

    steps:
      - name: Retrieve release distributions
        uses: actions/download-artifact@v4
        with:
          name: release-dists
          path: dist/

      - name: Publish release distributions to PyPI
        uses: pypa/gh-action-pypi-publish@3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f","jobs:
  release:
    permissions:
      id-token: write
    steps:
      - uses: actions/checkout@v3
      - uses: pypa/gh-action-pypi-publish@release/v1
        with:
          package: ./dist/*
",0
894,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow?learn=hosting_your_own_runners&learnProduct=actions,Using self-hosted runners in a workflow - Using default labels to route jobs,"A self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform: You can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:","runs-on: [self-hosted, linux, ARM64]","jobs:
  example_job:
    runs-on: [self-hosted, linux, x64]
    steps:
      - run: echo ""Running on a self-hosted runner with Linux x64""
",0
895,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow?learn=hosting_your_own_runners&learnProduct=actions,Using self-hosted runners in a workflow - Using custom labels to route jobs,"You can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled. For example, if you have a job that requires a specific type of graphics hardware, you can create a custom label called gpu and assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job. This example shows a job that combines default and custom labels:","runs-on: [self-hosted, linux, x64, gpu]","jobs:
  build:
    runs-on: [self-hosted, gpu]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run build
        run: make build
",0
896,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow?learn=hosting_your_own_runners&learnProduct=actions,Using self-hosted runners in a workflow - Using groups to route jobs,"In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
897,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow?learn=hosting_your_own_runners&learnProduct=actions,Using self-hosted runners in a workflow - Using labels and groups to route jobs,"When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [group:ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
898,https://docs.github.com/en/actions/using-containerized-services/about-service-containers,About service containers - Creating service containers,"You can use the services keyword to create service containers that are part of a job in your workflow. For more information, see jobs.<job_id>.services . This example creates a service called redis in a job called container-job . The Docker host in this example is the node:16-bullseye container.","name: Redis container example
on: push

jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:16-bullseye

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis","jobs:
  container-job:
    runs-on: ubuntu-latest
    container:
      image: node:16-bullseye
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
",0
899,https://docs.github.com/en/actions/using-containerized-services/about-service-containers,About service containers - Mapping Docker host and service container ports - Example mapping Redis ports,"If your job runs in a Docker container, you do not need to map ports on the host or the service container. If your job runs directly on the runner machine, you'll need to map any required service container ports to ports on the host runner machine. You can map service containers ports to the Docker host using the ports keyword. For more information, see jobs.<job_id>.services . When you map ports using the ports keyword, GitHub uses the --publish command to publish the containers ports to the Docker host. For more information, see Docker container networking in the Docker documentation. When you specify the container port but not the Docker host port, the container port is randomly assigned to a free port. GitHub sets the assigned container port in the service container context. For example, for a redis service container, if you configured the Docker host port 5432, you can access the corresponding container port using the job.services.redis.ports[5432] context. For more information, see Accessing contextual information about workflow runs . This example maps the service container redis port 6379 to the Docker host port 6379.","name: Redis Service Example
on: push

jobs:
  # Label of the container job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        #
        ports:
          # Opens tcp port 6379 on the host and service container
          - 6379:6379","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
",0
900,https://docs.github.com/en/actions/using-containerized-services/about-service-containers,About service containers - Authenticating with image registries,You can specify credentials for your service containers in case you need to authenticate with an image registry. This allows you to use images from private registries or to increase your DockerHub rate limit . Heres an example of authenticating with Docker Hub and the GitHub Container registry:,"jobs:
  build:
    services:
      redis:
        # Docker Hub image
        image: redis
        ports:
          - 6379:6379
        credentials:
          username: ${{ secrets.dockerhub_username }}
          password: ${{ secrets.dockerhub_password }}
      db:
        # Private registry image
        image: ghcr.io/octocat/testdb:latest
        credentials:
          username: ${{ github.repository_owner }}
          password: ${{ secrets.ghcr_password }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      my-service:
        image: my-private-registry/my-image:latest
        credentials:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      another-service:
        image: ghcr.io/my-org/my-image:latest
        credentials:
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
",0
901,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Creating an action metadata file,"Create a new action.yml file in the hello-world-docker-action directory you created above. For more information, see Metadata syntax for GitHub Actions . action.yml","# action.yml
name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.who-to-greet }}","name: 'Hello World Docker Action'
description: 'A simple Docker container action'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'Hello'
    - 'World'
",0
902,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Testing out your action in a workflow - Example using a public action,"Now you're ready to test your action out in a workflow. The following workflow code uses the completed hello world action in the public actions/hello-world-docker-action repository. Copy the following workflow example code into a .github/workflows/main.yml file, but replace the actions/hello-world-docker-action with your repository and action name. You can also replace the who-to-greet input with your name. Public actions can be used even if they're not published to GitHub Marketplace. For more information, see Publishing actions in GitHub Marketplace . .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: actions/hello-world-docker-action@v2
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","on: [push]

jobs:
  test-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run my Docker action
        uses: your-repo/your-action-name
        with:
          who-to-greet: 'Your Name'
",0
903,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Testing out your action in a workflow - Example using a private action,"Now you're ready to test your action out in a workflow. Copy the following example workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. This private action can't be published to GitHub Marketplace, and can only be used in this repository. .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","name: ""Test Docker Action""
on:
  push:
    branches:
      - main
jobs:
  test-action:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run Docker Action
        uses: ./  # Uses the action in the root of the repository
        with:
          who-to-greet: ""Your Name""
",0
904,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Accessing files created by a container action,"When a container action runs, it will automatically map the default working directory ( GITHUB_WORKSPACE ) on the runner with the /github/workspace directory on the container. Any files added to this directory on the container will be available to any subsequent steps in the same job. For example, if you have a container action that builds your project, and you would like to upload the build output as an artifact, you can use the following steps. workflow.yml","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Output build artifacts to /github/workspace on the container.
      - name: Containerized Build
        uses: ./.github/actions/my-container-action

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workspace_artifacts
          path: ${{ github.workspace }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build with Docker
        uses: docker://<your-docker-image>
        with:
          args: build
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: build-output
          path: /github/workspace/<your-build-output-directory>
",0
905,https://docs.github.com/en/actions/using-github-hosted-runners/running-jobs-on-larger-runners?platform=mac,Running jobs on larger runners - Targeting macOS larger runners in a workflow,"To run your workflows on macOS larger runners, set the value of the runs-on key to a label associated with a macOS larger runner. For a list of macOS larger runner labels, see Available macOS larger runners . In this example, the workflow uses a label that is associated with macOS XL runners. The runs-on key sends the job to any available runner with a matching label:","name: learn-github-actions-testing
on: [push]
jobs:
  build:
    runs-on: macos-13-xlarge
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: swift build
      - name: Run tests
        run: swift test","jobs:
  build:
    runs-on: macos-12-xl
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on a macOS XL runner""
",0
906,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services,Configuring OpenID Connect in Amazon Web Services - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
907,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services,Configuring OpenID Connect in Amazon Web Services - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
",0
908,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services,Configuring OpenID Connect in Amazon Web Services - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: The aws-actions/configure-aws-credentials action receives a JWT from the GitHub OIDC provider, and then requests an access token from AWS. For more information, see the AWS documentation .","# Sample workflow to access AWS resources when workflow is tied to branch
# The workflow Creates static website using aws s3
name: AWS example workflow
on:
  push
env:
  BUCKET_NAME : ""BUCKET-NAME""
  AWS_REGION : ""AWS-REGION""
# permission can be added at job level or workflow level
permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read    # This is required for actions/checkout
jobs:
  S3PackageUpload:
    runs-on: ubuntu-latest
    steps:
      - name: Git clone the repository
        uses: actions/checkout@v4
      - name: configure aws credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ROLE-TO-ASSUME
          role-session-name: samplerolesession
          aws-region: ${{ env.AWS_REGION }}
      # Upload a file to AWS s3
      - name: Copy index.html to s3
        run: |
          aws s3 cp ./index.html s3://${{ env.BUCKET_NAME }}/","jobs:
  oidc:
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::123456789012:role/example-role
          aws-region: us-east-1
",0
909,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-java-to-azure-app-service,Deploying Java to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy a Java project to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If you want to use a Java version other than 11 , change JAVA_VERSION . If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and deploy JAR app to Azure Web App

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name
  JAVA_VERSION: '11'                  # set this to the Java version to use

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Java version
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven
        run: mvn clean install

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: java-app
          path: '${{ github.workspace }}/target/*.jar'

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: java-app

      - name: Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: '*.jar'","on:
  push:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up JDK 11
        uses: actions/setup-java@v2
        with:
          java-version: 11
      - name: Build with Maven
        run: mvn clean install
      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          package: target/*.jar
",0
910,https://docs.github.com/en/actions/learn-github-actions/variables,Store information in variables - Defining environment variables for a single workflow,"To set a custom environment variable for a single workflow, you can define it using the env key in the workflow file. The scope of a custom variable set by this method is limited to the element in which it is defined. You can define variables that are scoped for:","name: Greeting on variable day

on:
  workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: ""Say Hello Mona it's Monday""
        run: echo ""$Greeting $First_Name. Today is $DAY_OF_WEEK!""
        env:
          First_Name: Mona","env:
  CUSTOM_VARIABLE: ""value""
",0
911,https://docs.github.com/en/actions/learn-github-actions/variables,Store information in variables - Using contexts to access variable values - Using the env context to access environment variable values,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs . There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs . You can access environment variable values using the env context and configuration variable values using the vars context. In addition to runner environment variables, GitHub Actions allows you to set and read env key values using contexts. Environment variables and contexts are intended for use at different points in the workflow. The run steps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example, $NAME for the bash shell on a Linux runner, or $env:NAME for PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax ${{ CONTEXT.PROPERTY }} , to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner. However, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, an if conditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in an if conditional statement to access the value of an variable.","name: Conditional env variable

on: workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: ""Say Hello Mona it's Monday""
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        run: echo ""$Greeting $First_Name. Today is $DAY_OF_WEEK!""
        env:
          First_Name: Mona","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      MY_ENV_VAR: 'Hello World'
    steps:
      - name: Print environment variable
        run: echo $MY_ENV_VAR

      - name: Print environment variable using context
        run: echo ${{ env.MY_ENV_VAR }}

      - name: Conditional step
        if: ${{ env.MY_ENV_VAR == 'Hello World' }}
        run: echo ""Condition met""
",0
912,https://docs.github.com/en/actions/learn-github-actions/variables,Store information in variables - Using contexts to access variable values - Using the env context to access environment variable values,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs . There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs . You can access environment variable values using the env context and configuration variable values using the vars context. In addition to runner environment variables, GitHub Actions allows you to set and read env key values using contexts. Environment variables and contexts are intended for use at different points in the workflow. The run steps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example, $NAME for the bash shell on a Linux runner, or $env:NAME for PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax ${{ CONTEXT.PROPERTY }} , to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner. However, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, an if conditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in an if conditional statement to access the value of an variable. In this modification of the earlier example, we've introduced an if conditional. The workflow step is now only run if DAY_OF_WEEK is set to ""Monday"". We access this value from the if conditional statement by using the env context . The env context is not required for the variables referenced within the run command. They are referenced as runner environment variables and are interpolated after the job is received by the runner. We could, however, have chosen to interpolate those variables before sending the job to the runner, by using contexts. The resulting output would be the same.","run: echo ""${{ env.Greeting }} ${{ env.First_Name }}. Today is ${{ env.DAY_OF_WEEK }}!""","jobs:
  example_job:
    runs-on: ubuntu-latest
    env:
      DAY_OF_WEEK: Monday
    steps:
      - name: Check day of the week
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        run: echo ""Today is $DAY_OF_WEEK""
",0
913,https://docs.github.com/en/actions/learn-github-actions/variables,Store information in variables - Using contexts to access variable values - Using the vars context to access configuration variable values,"Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs . There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs . You can access environment variable values using the env context and configuration variable values using the vars context. Configuration variables can be accessed across the workflow using vars context. For more information, see Accessing contextual information about workflow runs . If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string. The following example shows using configuration variables with the vars context across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels.","on:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo ""repository variable : $REPOSITORY_VAR""
        echo ""organization variable : $ORGANIZATION_VAR""
        echo ""overridden variable : $OVERRIDE_VAR""
        echo ""variable from shell environment : $env_var""
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Print configuration variables
        run: |
          echo ""Repository variable: ${{ vars.repository_variable }}""
          echo ""Organization variable: ${{ vars.organization_variable }}""
          echo ""Environment variable: ${{ vars.environment_variable }}""
",0
914,https://docs.github.com/en/actions/learn-github-actions/variables,Store information in variables - Detecting the operating system,"You can write a single workflow file that can be used for different operating systems by using the RUNNER_OS default environment variable and the corresponding context property ${{ runner.os }} . For example, the following workflow could be run successfully if you changed the operating system from macos-latest to windows-latest without having to alter the syntax of the environment variables, which differs depending on the shell being used by the runner.","on: workflow_dispatch

jobs:
  if-Windows-else:
    runs-on: macos-latest
    steps:
      - name: condition 1
        if: runner.os == 'Windows'
        run: echo ""The operating system on the runner is $env:RUNNER_OS.""
      - name: condition 2
        if: runner.os != 'Windows'
        run: echo ""The operating system on the runner is not Windows, it's $RUNNER_OS.""","jobs:
  detect-os:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
    steps:
      - name: Print operating system
        run: echo ""The operating system is $RUNNER_OS""
",0
915,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Understanding the risk of script injections - Example of a script injection attack,"When creating workflows, custom actions , and composite actions , you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner. Attackers can add their own malicious content to the github context , which should be treated as potentially untrusted input. These contexts typically end with body , default_branch , email , head_ref , label , message , name , page_name , ref , and title . For example: github.event.issue.title , or github.event.pull_request.body . You should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions . In addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, zzz"";echo${IFS}""hello"";# would be a valid branch name and would be a possible attack vector for a target repository. The following sections explain how you can help mitigate the risk of script injection. A script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:","- name: Check PR title
        run: |
          title=""${{ github.event.pull_request.title }}""
          if [[ $title =~ ^octocat ]]; then
          echo ""PR title starts with 'octocat'""
          exit 0
          else
          echo ""PR title did not start with 'octocat'""
          exit 1
          fi","jobs:
  check-pr-title:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Validate PR title
        run: |
          if [[ ""${{ github.event.pull_request.title }}"" =~ [^a-zA-Z0-9\ ] ]]; then
            echo ""Invalid PR title""
            exit 1
          fi
",0
916,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Good practices for mitigating script injection attacks - Using an action instead of an inline script (recommended),"There are a number of different approaches available to help you mitigate the risk of script injection: The recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:","uses: fakeaction/checktitle@v3
with:
    title: ${{ github.event.pull_request.title }}","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: your-username/your-action-repo@v1
        with:
          context-value: ${{ github.event.some_context_value }}
",0
917,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Good practices for mitigating script injection attacks - Using an intermediate environment variable,"There are a number of different approaches available to help you mitigate the risk of script injection: For inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable. The following example uses Bash to process the github.event.pull_request.title value as an environment variable:","- name: Check PR title
        env:
          TITLE: ${{ github.event.pull_request.title }}
        run: |
          if [[ ""$TITLE"" =~ ^octocat ]]; then
          echo ""PR title starts with 'octocat'""
          exit 0
          else
          echo ""PR title did not start with 'octocat'""
          exit 1
          fi","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - name: Set up intermediate environment variable
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          echo ""Processing pull request title: $PR_TITLE""
",0
918,https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Potential impact of a compromised runner - Accessing secrets,"These sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner. Note  GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library. Note GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library. Workflows triggered from a forked repository using the pull_request event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as issue_comment , issues , push and pull_request from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's GITHUB_TOKEN . If the secret or token is set to an environment variable, it can be directly accessed through the environment using printenv . If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible. For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:","uses: fakeaction/publish@v3
with:
    key: ${{ secrets.PUBLISH_KEY }}","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run security checks
        run: |
          echo ""Running security checks""
          # Add security checks here

      - name: Use secrets safely
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}
        run: |
          echo ""Using secrets safely""
          # Use the secret in a secure manner
",0
919,https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-azure/deploying-nodejs-to-azure-app-service,Deploying Node.js to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build, test, and deploy the Node.js project to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If the path to your project is not the repository root, change AZURE_WEBAPP_PACKAGE_PATH to your project path. If you use a version of Node.js other than 10.x , change NODE_VERSION to the version that you use. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

on:
  push:
    branches:
      - main

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name
  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root
  NODE_VERSION: '14.x'                # set this to the node version to use

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: npm install, build, and test
      run: |
        npm install
        npm run build --if-present
        npm run test --if-present
    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: .

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app

    - name: 'Deploy to Azure WebApp'
      id: deploy-to-webapp
      uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}","name: Node.js CI/CD

on:
  push:
    branches:
      - main

env:
  AZURE_WEBAPP_NAME: your-webapp-name
  AZURE_WEBAPP_PACKAGE_PATH: .
  NODE_VERSION: 14.x

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install dependencies
      run: npm install

    - name: Run tests
      run: npm test

    - name: Build project
      run: npm run build

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
",0
920,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Using workflow commands to access toolkit functions - Example: Creating an annotation for an error,"The actions/toolkit includes a number of functions that can be executed as workflow commands. Use the :: syntax to run the workflow commands within your YAML file; these commands are then sent to the runner over stdout . For example, instead of using code to create an error annotation, as below: You can use the error command in your workflow to create the same error annotation:","- name: Create annotation for build error
        run: echo ""::error file=app.js,line=1::Missing semicolon""","jobs:
  create-error-annotation:
    runs-on: ubuntu-latest
    steps:
      - name: Create error annotation
        run: echo ""::error file=app.js,line=10,col=15::Syntax error""
",0
921,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Grouping log lines - Example: Grouping log lines,"Creates an expandable group in the log. To create a group, use the group command and specify a title . Anything you print to the log between the group and endgroup commands is nested inside an expandable entry in the log.","jobs:
  bash-example:
    runs-on: ubuntu-latest
    steps:
      - name: Group of log lines
        run: |
            echo ""::group::My title""
            echo ""Inside group""
            echo ""::endgroup::""","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Group log lines
        run: |
          echo ""::group::My expandable group""
          echo ""This is inside the group""
          echo ""Another line inside the group""
          echo ""::endgroup::""
",0
922,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking an environment variable,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. When you print the variable MY_NAME or the value ""Mona The Octocat"" in the log, you'll see ""***"" instead of ""Mona The Octocat"" .","jobs:
  bash-example:
    runs-on: ubuntu-latest
    env:
      MY_NAME: ""Mona The Octocat""
    steps:
      - name: bash-version
        run: echo ""::add-mask::$MY_NAME""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Mask environment variable
        run: |
          echo ""MY_NAME=Mona The Octocat"" >> $GITHUB_ENV
          echo ""::add-mask::$MY_NAME""
          echo ""The name is $MY_NAME""
",0
923,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking a generated output within a single job,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you do not need to pass your secret from one job to another job, you can:","on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        run: |
          the_secret=$((RANDOM))
          echo ""::add-mask::$the_secret""
          echo ""secret-number=$the_secret"" >> ""$GITHUB_OUTPUT""
      - name: Use that secret output (protected by a mask)
        run: |
          echo ""the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}""","jobs:
  mask-value:
    runs-on: ubuntu-latest
    steps:
      - name: Generate secret
        id: generate_secret
        run: echo ""SECRET_VALUE=super_secret_value"" >> $GITHUB_ENV

      - name: Mask secret
        run: echo ""::add-mask::$SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}

      - name: Use secret
        run: echo ""The secret is $SECRET_VALUE""
        env:
          SECRET_VALUE: ${{ env.SECRET_VALUE }}
",0
924,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Masking a value in a log - Example: Masking and passing a secret between jobs or workflows - Workflow,"Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value . When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output. If you want to pass a masked secret between jobs or workflows, you should store the secret in a store and then retrieve it in the subsequent job or workflow. Note  This workflow uses an imaginary secret store,secret-store, which has imaginary commandsstore-secretandretrieve-secret.some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29is an imaginary action that installs thesecret-storeapplication and configures it to connect to aninstancewithcredentials. Note This workflow uses an imaginary secret store, secret-store , which has imaginary commands store-secret and retrieve-secret . some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29 is an imaginary action that installs the secret-store application and configures it to connect to an instance with credentials .","on: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    outputs:
      handle: ${{ steps.generate-secret.outputs.handle }}
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      id: generate-secret
      shell: bash
      run: |
        GENERATED_SECRET=$((RANDOM))
        echo ""::add-mask::$GENERATED_SECRET""
        SECRET_HANDLE=$(secret-store store-secret ""$GENERATED_SECRET"")
        echo ""handle=$SECRET_HANDLE"" >> ""$GITHUB_OUTPUT""
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: bash
      run: |
        SECRET_HANDLE=""${{ needs.secret-generator.outputs.handle }}""
        RETRIEVED_SECRET=$(secret-store retrieve-secret ""$SECRET_HANDLE"")
        echo ""::add-mask::$RETRIEVED_SECRET""
        echo ""We retrieved our masked secret: $RETRIEVED_SECRET""","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Store secret
        run: echo ""my_secret_value"" | store-secret my_secret_key
      - name: Mask secret
        run: echo ""::add-mask::my_secret_value""

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install secret store
        uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      - name: Retrieve secret
        run: retrieve-secret my_secret_key
",0
925,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Stopping and starting workflow commands - Example: Stopping and starting workflow commands,"Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command. For example, you could stop logging to output an entire script that has comments. To stop the processing of workflow commands, pass a unique token to stop-commands . To resume processing workflow commands, pass the same token that you used to stop workflow commands. Warning  Make sure the token you're using is randomly generated and unique for each run. Warning Make sure the token you're using is randomly generated and unique for each run.","jobs:
  workflow-command-job:
    runs-on: ubuntu-latest
    steps:
      - name: Disable workflow commands
        run: |
          echo '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          stopMarker=$(uuidgen)
          echo ""::stop-commands::$stopMarker""
          echo '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          echo ""::$stopMarker::""
          echo '::warning:: This is a warning again, because stop-commands has been turned off.'","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Stop workflow commands
        run: echo ""::stop-commands::${{ secrets.UNIQUE_TOKEN }}""
      
      - name: Log script
        run: |
          echo ""This is a script with comments""
          echo ""# This is a comment""
          echo ""echo Hello World""
      
      - name: Start workflow commands
        run: echo ""::${{ secrets.UNIQUE_TOKEN }}::""
",0
926,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how:","name: Example Workflow for Environment Files

on: push

jobs:
  set_and_use_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_ENV_VAR=myValue"" >> $GITHUB_ENV

      - name: Use environment variable
        run: |
          echo ""The value of MY_ENV_VAR is $MY_ENV_VAR""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variable
        run: echo ""MY_VAR=HelloWorld"" >> $GITHUB_ENV

      - name: Use environment variable
        run: echo $MY_VAR
",0
927,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Environment files,"During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables . You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands. Here's how: Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names:","steps:
  - name: Store build timestamp
    run: echo ""BUILD_TIME=$(date +'%T')"" >> $GITHUB_ENV

  - name: Deploy using stored timestamp
    run: echo ""Deploying at $BUILD_TIME""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variables
        run: |
          echo ""BUILD_TIMESTAMP=$(date +%Y%m%d%H%M%S)"" >> $GITHUB_ENV
          echo ""COMMIT_SHA=$(git rev-parse HEAD)"" >> $GITHUB_ENV
          echo ""ARTIFACT_NAME=my-artifact"" >> $GITHUB_ENV

      - name: Use environment variables
        run: |
          echo ""Build Timestamp: $BUILD_TIMESTAMP""
          echo ""Commit SHA: $COMMIT_SHA""
          echo ""Artifact Name: $ARTIFACT_NAME""
",0
928,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Setting an environment variable - Example of writing an environment variable to GITHUB_ENV,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable.","steps:
  - name: Set the value
    id: step_one
    run: |
      echo ""action_state=yellow"" >> ""$GITHUB_ENV""
  - name: Use the value
    id: step_two
    run: |
      printf '%s\n' ""$action_state"" # This will output 'yellow'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_VARIABLE=some_value"" >> $GITHUB_ENV
      - name: Use environment variable
        run: echo ""The value of MY_VARIABLE is $MY_VARIABLE""
",0
929,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Setting an environment variable - Multiline strings - Example of a multiline string,"Note  To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. Note To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using. You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access. You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_* . Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables . Note  Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable. Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable. For multiline strings, you may use a delimiter with the following syntax. Warning  Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. Warning Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead. This example uses EOF as the delimiter, and sets the JSON_RESPONSE environment variable to the value of the curl response.","steps:
  - name: Set the value in bash
    id: step_one
    run: |
      {
        echo 'JSON_RESPONSE<<EOF'
        curl https://example.com
        echo EOF
      } >> ""$GITHUB_ENV""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set JSON_RESPONSE environment variable
        run: |
          echo ""JSON_RESPONSE<<EOF"" >> $GITHUB_ENV
          curl -s https://api.example.com/data
          EOF
",0
930,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Setting an output parameter - Example of setting an output parameter,Sets a step's output parameter. Note that the step will need an id to be defined to later retrieve the output value. You can set multi-line output values with the same technique used in the Multiline strings section to define multi-line environment variables. This example demonstrates how to set the SELECTED_COLOR output parameter and later retrieve it:,"- name: Set color
        id: color-selector
        run: echo ""SELECTED_COLOR=green"" >> ""$GITHUB_OUTPUT""
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: echo ""The selected color is $SELECTED_COLOR""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - id: set-output
        run: echo ""SELECTED_COLOR=blue"" >> $GITHUB_ENV
      - run: echo ""The selected color is ${{ steps.set-output.outputs.SELECTED_COLOR }}""
",0
931,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Adding a job summary - Multiline Markdown content - Example of multiline Markdown content,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. For multiline Markdown content, you can use >> to continuously append content for the current step. With every append operation, a newline character is automatically added.","- name: Generate list using Markdown
  run: |
    echo ""This is the lead in sentence for the list"" >> $GITHUB_STEP_SUMMARY
    echo """" >> $GITHUB_STEP_SUMMARY # this is a blank line
    echo ""- Lets add a bullet point"" >> $GITHUB_STEP_SUMMARY
    echo ""- Lets add a second bullet point"" >> $GITHUB_STEP_SUMMARY
    echo ""- How about a third one?"" >> $GITHUB_STEP_SUMMARY","jobs:
  add-summary:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: |
          echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY
          echo ""This is a summary of the job execution."" >> $GITHUB_STEP_SUMMARY
          echo ""- Test results: All tests passed"" >> $GITHUB_STEP_SUMMARY
          echo ""- No errors encountered"" >> $GITHUB_STEP_SUMMARY
",0
932,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Adding a job summary - Overwriting job summaries - Example of overwriting job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To clear all content for the current step, you can use > to overwrite any previously added content in Bash, or remove -Append in PowerShell","- name: Overwrite Markdown
  run: |
    echo ""Adding some Markdown content"" >> $GITHUB_STEP_SUMMARY
    echo ""There was an error, we need to clear the previous Markdown with some new content."" > $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" > $GITHUB_STEP_SUMMARY
      - name: Overwrite job summary
        run: echo ""## Overwritten Summary"" > $GITHUB_STEP_SUMMARY
",0
933,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions?tool=bash,Workflow commands for GitHub Actions - Adding a job summary - Removing job summaries - Example of removing job summaries,"You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures. Job summaries support GitHub flavored Markdown , and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files . When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time. To completely remove a summary for the current step, the file that GITHUB_STEP_SUMMARY references can be deleted.","- name: Delete all summary content
  run: |
    echo ""Adding Markdown content that we want to remove before the step ends"" >> $GITHUB_STEP_SUMMARY
    rm $GITHUB_STEP_SUMMARY","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Add job summary
        run: echo ""## Job Summary"" >> $GITHUB_STEP_SUMMARY

      - name: Remove job summary
        run: rm $GITHUB_STEP_SUMMARY
",0
934,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Jobs - GitLab CI/CD syntax for jobs,"Jobs in GitLab CI/CD are very similar to jobs in GitHub Actions. In both systems, jobs have the following characteristics: You can run a script or a shell command in a job. In GitLab CI/CD, script steps are specified using the script key. In GitHub Actions, all scripts are specified using the run key. Below is an example of the syntax for each system.","job1:
  variables:
    GIT_CHECKOUT: ""true""
  script:
    - echo ""Run your script here""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script
        run: echo ""Hello, World!""
",0
935,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Jobs - GitHub Actions syntax for jobs,"Jobs in GitLab CI/CD are very similar to jobs in GitHub Actions. In both systems, jobs have the following characteristics: You can run a script or a shell command in a job. In GitLab CI/CD, script steps are specified using the script key. In GitHub Actions, all scripts are specified using the run key. Below is an example of the syntax for each system.","jobs:
  job1:
    steps:
      - uses: actions/checkout@v4
      - run: echo ""Run your script here""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script
        run: echo ""Hello, World!""
",0
936,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Runners - GitLab CI/CD syntax for runners,"Runners are machines on which the jobs run. Both GitLab CI/CD and GitHub Actions offer managed and self-hosted variants of runners. In GitLab CI/CD, tags are used to run jobs on different platforms, while in GitHub Actions it is done with the runs-on key. Below is an example of the syntax for each system.","windows_job:
  tags:
    - windows
  script:
    - echo Hello, %USERNAME%!

linux_job:
  tags:
    - linux
  script:
    - echo ""Hello, $USER!""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
937,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Runners - GitHub Actions syntax for runners,"Runners are machines on which the jobs run. Both GitLab CI/CD and GitHub Actions offer managed and self-hosted variants of runners. In GitLab CI/CD, tags are used to run jobs on different platforms, while in GitHub Actions it is done with the runs-on key. Below is an example of the syntax for each system.","windows_job:
  runs-on: windows-latest
  steps:
    - run: echo Hello, %USERNAME%!

linux_job:
  runs-on: ubuntu-latest
  steps:
    - run: echo ""Hello, $USER!""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
938,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Docker images - GitLab CI/CD syntax for Docker images,"Both GitLab CI/CD and GitHub Actions support running jobs in a Docker image. In GitLab CI/CD, Docker images are defined with an image key, while in GitHub Actions it is done with the container key. Below is an example of the syntax for each system.","my_job:
  image: node:20-bookworm-slim","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: your-docker-image:tag
    steps:
      - uses: actions/checkout@v2
      - name: Run a command
        run: echo ""Hello, world!""
",0
939,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Docker images - GitHub Actions syntax for Docker images,"Both GitLab CI/CD and GitHub Actions support running jobs in a Docker image. In GitLab CI/CD, Docker images are defined with an image key, while in GitHub Actions it is done with the container key. Below is an example of the syntax for each system.","jobs:
  my_job:
    container: node:20-bookworm-slim","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: your-docker-image:latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run a script
        run: echo ""Hello, world!""
",0
940,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Condition and expression syntax - GitLab CI/CD syntax for conditions and expressions,GitLab CI/CD uses rules to determine if a job will run for a specific condition. GitHub Actions uses the if keyword to prevent a job from running unless a condition is met. Below is an example of the syntax for each system.,"deploy_prod:
  stage: deploy
  script:
    - echo ""Deploy to production server""
  rules:
    - if: '$CI_COMMIT_BRANCH == ""master""'","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run script
        if: ${{ condition }}
        run: echo ""Running script based on condition""
",0
941,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Condition and expression syntax - GitHub Actions syntax for conditions and expressions,GitLab CI/CD uses rules to determine if a job will run for a specific condition. GitHub Actions uses the if keyword to prevent a job from running unless a condition is met. Below is an example of the syntax for each system.,"jobs:
  deploy_prod:
    if: contains( github.ref, 'master')
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Deploy to production server""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run job if condition is met
        if: ${{ condition }}
        run: echo ""Condition met, running job""
",0
942,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Dependencies between Jobs - GitLab CI/CD syntax for dependencies between jobs,"Both GitLab CI/CD and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies in GitHub Actions can be specified explicitly with the needs key. GitLab CI/CD also has a concept of stages , where jobs in a stage run concurrently, but the next stage will start when all the jobs in the previous stage have completed. You can recreate this scenario in GitHub Actions with the needs key. Below is an example of the syntax for each system. The workflows start with two jobs named build_a and build_b running in parallel, and when those jobs complete, another job called test_ab will run. Finally, when test_ab completes, the deploy_ab job will run.","stages:
  - build
  - test
  - deploy

build_a:
  stage: build
  script:
    - echo ""This job will run first.""

build_b:
  stage: build
  script:
    - echo ""This job will run first, in parallel with build_a.""

test_ab:
  stage: test
  script:
    - echo ""This job will run after build_a and build_b have finished.""

deploy_ab:
  stage: deploy
  script:
    - echo ""This job will run after test_ab is complete""","jobs:
  build_a:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building A""

  build_b:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building B""

  test_ab:
    runs-on: ubuntu-latest
    needs: [build_a, build_b]
    steps:
      - run: echo ""Testing AB""

  deploy_ab:
    runs-on: ubuntu-latest
    needs: test_ab
    steps:
      - run: echo ""Deploying AB""
",0
943,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Dependencies between Jobs - GitHub Actions syntax for dependencies between jobs,"Both GitLab CI/CD and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies in GitHub Actions can be specified explicitly with the needs key. GitLab CI/CD also has a concept of stages , where jobs in a stage run concurrently, but the next stage will start when all the jobs in the previous stage have completed. You can recreate this scenario in GitHub Actions with the needs key. Below is an example of the syntax for each system. The workflows start with two jobs named build_a and build_b running in parallel, and when those jobs complete, another job called test_ab will run. Finally, when test_ab completes, the deploy_ab job will run.","jobs:
  build_a:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This job will be run first.""

  build_b:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This job will be run first, in parallel with build_a""

  test_ab:
    runs-on: ubuntu-latest
    needs: [build_a,build_b]
    steps:
      - run: echo ""This job will run after build_a and build_b have finished""

  deploy_ab:
    runs-on: ubuntu-latest
    needs: [test_ab]
    steps:
      - run: echo ""This job will run after test_ab is complete""","jobs:
  build_a:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building A""

  build_b:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building B""

  test_ab:
    runs-on: ubuntu-latest
    needs: [build_a, build_b]
    steps:
      - run: echo ""Testing AB""

  deploy_ab:
    runs-on: ubuntu-latest
    needs: test_ab
    steps:
      - run: echo ""Deploying AB""
",0
944,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Caching - GitLab CI/CD syntax for caching,GitLab CI/CD and GitHub Actions provide a method in the configuration file to manually cache workflow files. Below is an example of the syntax for each system.,"image: node:latest

cache:
  key: $CI_COMMIT_REF_SLUG
  paths:
    - .npm/

before_script:
  - npm ci --cache .npm --prefer-offline

test_async:
  script:
    - node ./specs/start.js ./specs/async.spec.js","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ./path/to/dependencies
          key: ${{ runner.os }}-build-${{ hashFiles('**/lockfiles') }}
          restore-keys: |
            ${{ runner.os }}-build-
      - name: Install dependencies
        run: |
          # Command to install dependencies
",0
945,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Caching - GitHub Actions syntax for caching,GitLab CI/CD and GitHub Actions provide a method in the configuration file to manually cache workflow files. Below is an example of the syntax for each system.,"jobs:
  test_async:
    runs-on: ubuntu-latest
    steps:
    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}
        restore-keys: v1-npm-deps-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: path/to/dependencies
          key: ${{ runner.os }}-build-${{ hashFiles('**/lockfiles') }}
          restore-keys: |
            ${{ runner.os }}-build-
      - name: Install dependencies
        run: |
          # Command to install dependencies
",0
946,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Artifacts - GitLab CI/CD syntax for artifacts,"Both GitLab CI/CD and GitHub Actions can upload files and directories created by a job as artifacts. In GitHub Actions, artifacts can be used to persist data across multiple jobs. Below is an example of the syntax for each system.","script:
artifacts:
  paths:
    - math-homework.txt","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build
        run: echo ""Building project...""
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: build-artifact
          path: ./path/to/artifact
",0
947,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Artifacts - GitHub Actions syntax for artifacts,"Both GitLab CI/CD and GitHub Actions can upload files and directories created by a job as artifacts. In GitHub Actions, artifacts can be used to persist data across multiple jobs. Below is an example of the syntax for each system.","- name: Upload math result for job 1
  uses: actions/upload-artifact@v4
  with:
    name: homework
    path: math-homework.txt","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build project
        run: echo ""Building project...""
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: my-artifact
          path: path/to/artifact
",0
948,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Databases and service containers - GitLab CI/CD syntax for databases and service containers,"Both systems enable you to include additional containers for databases, caching, or other dependencies. In GitLab CI/CD, a container for the job is specified with the image key, while GitHub Actions uses the container key. In both systems, additional service containers are specified with the services key. Below is an example of the syntax for each system.","container-job:
  variables:
    POSTGRES_PASSWORD: postgres
    # The hostname used to communicate with the
    # PostgreSQL service container
    POSTGRES_HOST: postgres
    # The default PostgreSQL port
    POSTGRES_PORT: 5432
  image: node:20-bookworm-slim
  services:
    - postgres
  script:
    # Performs a clean installation of all dependencies
    # in the `package.json` file
    - npm ci
    # Runs a script that creates a PostgreSQL client,
    # populates the client with data, and retrieves data
    - node client.js
  tags:
    - docker","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: my-job-image:latest
    services:
      database:
        image: postgres:latest
        ports:
          - 5432:5432
      cache:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Run my job
        run: |
          echo ""Running job in container with services""
",0
949,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions,Migrating from GitLab CI/CD to GitHub Actions - Databases and service containers - GitHub Actions syntax for databases and service containers,"Both systems enable you to include additional containers for databases, caching, or other dependencies. In GitLab CI/CD, a container for the job is specified with the image key, while GitHub Actions uses the container key. In both systems, additional service containers are specified with the services key. Below is an example of the syntax for each system.","jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node:20-bookworm-slim

    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies
      # in the `package.json` file
      - name: Install dependencies
        run: npm ci

      - name: Connect to PostgreSQL
        # Runs a script that creates a PostgreSQL client,
        # populates the client with data, and retrieves data
        run: node client.js
        env:
          # The hostname used to communicate with the
          # PostgreSQL service container
          POSTGRES_HOST: postgres
          # The default PostgreSQL port
          POSTGRES_PORT: 5432","jobs:
  example-job:
    runs-on: ubuntu-latest
    container:
      image: my-job-image:latest
    services:
      database:
        image: postgres:latest
        ports:
          - 5432:5432
      cache:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run application
        run: |
          echo ""Running application with database and cache services""
",0
950,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Specifying the Node.js version,"The easiest way to specify a Node.js version is by using the setup-node action provided by GitHub. For more information see, setup-node . The setup-node action takes a Node.js version as an input and configures that version on the runner. The setup-node action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. Using the setup-node action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to PATH . The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in node-version . The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the node-version array creates a job that runs the same steps. Each job can access the value defined in the matrix node-version array using the matrix context. The setup-node action uses the context as the node-version input. The setup-node action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs .","strategy:
  matrix:
    node-version: ['18.x', '20.x']

steps:
- uses: actions/checkout@v4
- name: Use Node.js ${{ matrix.node-version }}
  uses: actions/setup-node@v4
  with:
    node-version: ${{ matrix.node-version }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - run: npm test
",0
951,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Specifying the Node.js version,"The easiest way to specify a Node.js version is by using the setup-node action provided by GitHub. For more information see, setup-node . The setup-node action takes a Node.js version as an input and configures that version on the runner. The setup-node action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. Using the setup-node action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to PATH . The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in node-version . The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the node-version array creates a job that runs the same steps. Each job can access the value defined in the matrix node-version array using the matrix context. The setup-node action uses the context as the node-version input. The setup-node action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs . Alternatively, you can build and test with exact Node.js versions.","strategy:
  matrix:
    node-version: ['10.17.0', '17.9.0']","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm install
    - run: npm test
",0
952,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Specifying the Node.js version,"The easiest way to specify a Node.js version is by using the setup-node action provided by GitHub. For more information see, setup-node . The setup-node action takes a Node.js version as an input and configures that version on the runner. The setup-node action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to PATH , which persists for the rest of the job. Using the setup-node action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to PATH . The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in node-version . The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the node-version array creates a job that runs the same steps. Each job can access the value defined in the matrix node-version array using the matrix context. The setup-node action uses the context as the node-version input. The setup-node action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see Workflow syntax for GitHub Actions and Accessing contextual information about workflow runs . Alternatively, you can build and test with exact Node.js versions. Or, you can build and test using a single version of Node.js too.","name: Node.js CI

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm install
    - run: npm test
",0
953,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using npm,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the versions in the package-lock.json or npm-shrinkwrap.json file and prevents updates to the lock file. Using npm ci is generally faster than running npm install . For more information, see npm ci and Introducing npm ci for faster, more reliable builds .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: npm ci","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm ci
",0
954,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using npm,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the versions in the package-lock.json or npm-shrinkwrap.json file and prevents updates to the lock file. Using npm ci is generally faster than running npm install . For more information, see npm ci and Introducing npm ci for faster, more reliable builds . Using npm install installs the dependencies defined in the package.json file. For more information, see npm install .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: npm install","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '14'
    - name: Install dependencies
      run: npm ci
    - name: Build
      run: npm run build
    - name: Test
      run: npm test
",0
955,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using Yarn,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the dependencies defined in the yarn.lock file and prevents updates to the yarn.lock file. For more information, see yarn install .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: yarn --frozen-lockfile","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: yarn install --frozen-lockfile
",0
956,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using Yarn,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . This example installs the dependencies defined in the yarn.lock file and prevents updates to the yarn.lock file. For more information, see yarn install . Alternatively, you can install the dependencies defined in the package.json file.","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: yarn","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: yarn install --frozen-lockfile
",0
957,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example using a private registry and creating the .npmrc file,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can use the setup-node action to create a local .npmrc file on the runner that configures the default registry and scope. The setup-node action also accepts an authentication token as input, used to access private registries or publish node packages. For more information, see setup-node . To authenticate to your private registry, you'll need to store your npm authentication token as a secret. For example, create a repository secret called NPM_TOKEN . For more information, see Using secrets in GitHub Actions . In the example below, the secret NPM_TOKEN stores the npm authentication token. The setup-node action configures the .npmrc file to read the npm authentication token from the NODE_AUTH_TOKEN environment variable. When using the setup-node action to create an .npmrc file, you must set the NODE_AUTH_TOKEN environment variable with the secret that contains your npm authentication token. Before installing dependencies, use the setup-node action to create the .npmrc file. The action has two input parameters. The node-version parameter sets the Node.js version, and the registry-url parameter sets the default registry. If your package registry uses scopes, you must use the scope parameter. For more information, see npm-scope .","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    always-auth: true
    node-version: '20.x'
    registry-url: https://registry.npmjs.org
    scope: '@octocat'
- name: Install dependencies
  run: npm ci
  env:
    NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '14'
        registry-url: 'https://registry.npmjs.org'
    - name: Authenticate to npm registry
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      run: echo ""//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}"" > ~/.npmrc
    - name: Install dependencies
      run: npm install
    - name: Build
      run: npm run build
    - name: Test
      run: npm test
",0
958,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example caching dependencies,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-node action . The following example caches dependencies for npm.","steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'
- run: npm install
- run: npm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'npm'
      - run: npm install
      - run: npm test
",0
959,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example caching dependencies,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-node action . The following example caches dependencies for npm. The following example caches dependencies for Yarn.","steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'yarn'
- run: yarn
- run: yarn test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: '14'
        cache: 'npm'
    - run: npm install
    - run: npm test

  build-yarn:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v3
      with:
        node-version: '14'
        cache: 'yarn'
    - run: yarn install
    - run: yarn test
",0
960,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Installing dependencies - Example caching dependencies,"GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed. You can also cache dependencies to speed up your workflow. For more information, see Caching dependencies to speed up workflows . You can cache and restore the dependencies using the setup-node action . The following example caches dependencies for npm. The following example caches dependencies for Yarn. The following example caches dependencies for pnpm (v6.10+).","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# NOTE: pnpm caching support requires pnpm version >= 6.10.0

steps:
- uses: actions/checkout@v4
- uses: pnpm/action-setup@0609f0983b7a228f052f81ef4c3d6510cae254ad
  with:
    version: 6.10.0
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'pnpm'
- run: pnpm install
- run: pnpm test","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'

    - run: npm install

    - run: npm test

  build-yarn:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'yarn'

    - run: yarn install

    - run: yarn test

  build-pnpm:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'pnpm'

    - run: pnpm install

    - run: pnpm test
",0
961,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs,Building and testing Node.js - Building and testing your code,"You can use the same commands that you use locally to build and test your code. For example, if you run npm run build to run build steps defined in your package.json file and npm test to run your test suite, you would add those commands in your workflow file.","steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- run: npm install
- run: npm run build --if-present
- run: npm test","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      - run: npm install
      - run: npm run build
      - run: npm test
",0
962,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: If your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually. Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
963,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: If your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually. Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write

jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
964,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Using custom actions - Requesting the JWT using the Actions core toolkit,"If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider. If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN , ACTIONS_ID_TOKEN_REQUEST_URL . To update your workflows using this approach, you will need to make three changes to your YAML: The following example demonstrates how to use actions/github-script with the core toolkit to request the JWT from GitHub's OIDC provider. For more information, see Creating a JavaScript action .","jobs:
  job:
    environment: Production
    runs-on: ubuntu-latest
    steps:
    - name: Install OIDC Client from Core Package
      run: npm install @actions/core@1.6.0 @actions/http-client
    - name: Get Id Token
      uses: actions/github-script@v7
      id: idtoken
      with:
        script: |
          const coredemo = require('@actions/core')
          let id_token = await coredemo.getIDToken()
          coredemo.setOutput('id_token', id_token)","jobs:
  request-jwt:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Request JWT
        uses: actions/github-script@v6
        with:
          script: |
            const core = require('@actions/core');
            const { getIDToken } = require('@actions/core/lib/id-token');
            async function run() {
              try {
                const idToken = await getIDToken();
                console.log(`ID Token: ${idToken}`);
              } catch (error) {
                core.setFailed(error.message);
              }
            }
            run();
",0
965,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Using custom actions - Requesting the JWT using environment variables,"If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider. If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN , ACTIONS_ID_TOKEN_REQUEST_URL . To update your workflows using this approach, you will need to make three changes to your YAML: The following example demonstrates how to use environment variables to request a JSON Web Token. For your deployment job, you will need to define the token settings, using actions/github-script with the core toolkit. For more information, see Creating a JavaScript action . For example:","jobs:
  job:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/github-script@v7
      id: script
      timeout-minutes: 10
      with:
        debug: true
        script: |
          const token = process.env['ACTIONS_RUNTIME_TOKEN']
          const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']
          core.setOutput('TOKEN', token.trim())
          core.setOutput('IDTOKENURL', runtimeUrl.trim())","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Request JWT
        id: request_jwt
        run: |
          echo ""Requesting JWT...""
          export JWT=$(curl -H ""Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"" \
            ""${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}?audience=my-audience"")
          echo ""JWT=$JWT"" >> $GITHUB_ENV
      - name: Use JWT
        run: |
          echo ""Using JWT: ${{ env.JWT }}""
",0
966,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers,Configuring OpenID Connect in cloud providers - Using custom actions - Requesting the JWT using environment variables,"If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider. If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token: ACTIONS_ID_TOKEN_REQUEST_TOKEN , ACTIONS_ID_TOKEN_REQUEST_URL . To update your workflows using this approach, you will need to make three changes to your YAML: The following example demonstrates how to use environment variables to request a JSON Web Token. For your deployment job, you will need to define the token settings, using actions/github-script with the core toolkit. For more information, see Creating a JavaScript action . For example: You can then use curl to retrieve a JWT from the GitHub OIDC provider. For example:","- run: |
        IDTOKEN=$(curl -H ""Authorization: Bearer ${{steps.script.outputs.TOKEN}}"" ${{steps.script.outputs.IDTOKENURL}}  -H ""Accept: application/json; api-version=2.0"" -H ""Content-Type: application/json"" -d ""{}"" | jq -r '.value')
        echo $IDTOKEN
        jwtd() {
            if [[ -x $(command -v jq) ]]; then
                jq -R 'split(""."") | .[0],.[1] | @base64d | fromjson' <<< ""${1}""
                echo ""Signature: $(echo ""${1}"" | awk -F'.' '{print $3}')""
            fi
        }
        jwtd $IDTOKEN
        echo ""idToken=${IDTOKEN}"" >> $GITHUB_OUTPUT
      id: tokenid","jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Request JWT
        id: request_jwt
        run: |
          echo ""Requesting JWT...""
          export TOKEN=""$(curl -H ""Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"" \
            ""${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}?audience=YOUR_AUDIENCE"")""
          echo ""TOKEN=$TOKEN"" >> $GITHUB_ENV

      - name: Use JWT
        run: |
          echo ""Using JWT...""
          echo $TOKEN
",0
967,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Adding an action to your workflow - Adding an action from the same repository,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in the same repository where your workflow file uses the action, you can reference the action with either the  {owner}/{repo}@{ref} or ./path/to/dir syntax in your workflow file. Example repository file structure: The path is relative ( ./ ) to the default working directory ( github.workspace , $GITHUB_WORKSPACE ). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated. Example workflow file:","jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run local action
        uses: ./path/to/dir
",0
968,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Adding an action to your workflow - Adding an action from a different repository,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in a different repository than your workflow file, you can reference the action with the {owner}/{repo}@{ref} syntax in your workflow file. The action must be stored in a public repository.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/setup-node@v4","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run external action
        uses: owner/repo@ref
",0
969,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Adding an action to your workflow - Referencing a container on Docker Hub,"You can add an action to your workflow by referencing the action in your workflow file. You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  About the dependency graph . Note  To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. Note To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail. If an action is defined in a published Docker container image on Docker Hub, you must reference the action with the docker://{image}:{tag} syntax in your workflow file. To protect your code and data, we strongly recommend you verify the integrity of the Docker container image from Docker Hub before using it in your workflow.","jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use Docker container
        uses: docker://{image}:{tag}
",0
970,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using tags,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . Tags are useful for letting you decide when to switch between major and minor versions, but these are more ephemeral and can be moved or deleted by the maintainer. This example demonstrates how to target an action that's been tagged as v1.0.1 :","steps:
  - uses: actions/javascript-action@v1.0.1","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v1.0.1
",0
971,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using SHAs,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . If you need more reliable versioning, you should use the SHA value associated with the version of the action. SHAs are immutable and therefore more reliable than tags or branches. However, this approach means you will not automatically receive updates for an action, including important bug fixes and security updates. You must use a commit's full SHA value, and not an abbreviated value. When selecting a SHA, you should verify it is from the action's repository and not a repository fork. This example targets an action's SHA:","steps:
  - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@<full-sha-value>
",0
972,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Using release management for your custom actions - Using branches,"The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action. You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use. Note  We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts. Note We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts . Specifying a target branch for the action means it will always run the version currently on that branch. This approach can create problems if an update to the branch includes breaking changes. This example targets a branch named @main :","steps:
  - uses: actions/javascript-action@main","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
",0
973,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions,Using pre-written building blocks in your workflow - Using inputs and outputs with an action,"An action often accepts or requires inputs and generates outputs that you can use. For example, an action might require you to specify a path to a file, the name of a label, or other data it will use as part of the action processing. To see the inputs and outputs of an action, check the action.yml in the root directory of the repository. In this example action.yml , the inputs keyword defines a required input called file-path , and includes a default value that will be used if none is specified. The outputs keyword defines an output called results-file , which tells you where to locate the results.","name: ""Example""
description: ""Receives file and generates output""
inputs:
  file-path: # id of input
    description: ""Path to test script""
    required: true
    default: ""test-file.js""
outputs:
  results-file: # id of output
    description: ""Path to results file""","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run example action
        uses: example/action@v1
        with:
          file-path: './path/to/file'
      - name: Use action output
        run: echo ""Results file: ${{ steps.example_action.outputs.results-file }}""
",0
974,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Creating a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call :","on:
  workflow_call:","on:
  workflow_call:
",0
975,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow.","on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      personal_access_token:
        required: true","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
976,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions .","jobs:
  reusable_workflow_job:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.personal_access_token }}
        configuration-path: ${{ inputs.config-path }}","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
977,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions . In the example above, personal_access_token is a secret that's defined at the repository or organization level. Warning  Environment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions. Warning Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions . Pass the input or secret from the caller workflow. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}","on:
  workflow_call:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        type: string
    secrets:
      example_secret:
        description: 'An example secret'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
978,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Creating a reusable workflow - Using inputs and secrets in a reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow. In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow. For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets . In the reusable workflow, reference the input or secret that you defined in the on key in the previous step. Note  If the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions. Note If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions . In the example above, personal_access_token is a secret that's defined at the repository or organization level. Warning  Environment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions. Warning Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions . Pass the input or secret from the caller workflow. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string). Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit","on:
  workflow_call:
    inputs:
      example_input:
        required: true
        type: string
    secrets:
      example_secret:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
979,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Creating a reusable workflow - Example reusable workflow,"Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported. For a workflow to be reusable, the values for on must include workflow_call : This reusable workflow file named workflow-B.yml (we'll refer to this later in the example caller workflow ) takes an input string and a secret from the caller workflow and uses them in an action.","name: Reusable workflow example

on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      token:
        required: true

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.token }}
        configuration-path: ${{ inputs.config-path }}","on:
  workflow_call:
    inputs:
      example_input:
        type: string
    secrets:
      example_secret:
        required: true

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use input and secret
        run: echo ""Input: ${{ inputs.example_input }}, Secret: ${{ secrets.example_secret }}""
",0
980,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Calling a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job.","jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1","jobs:
  job1:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
  job2:
    uses: ./.github/workflows/another-reusable-workflow.yml
",0
981,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Calling a reusable workflow - Passing inputs and secrets to a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      input_name: input_value
    secrets:
      secret_name: ${{ secrets.SECRET_VALUE }}
",0
982,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Calling a reusable workflow - Passing inputs and secrets to a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string). Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.","jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit","jobs:
  call-reusable-workflow:
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      input_name: input_value
    secrets:
      secret_name: ${{ secrets.SECRET_VALUE }}
",0
983,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Calling a reusable workflow - Using a matrix strategy with a reusable workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. Jobs using the matrix strategy can call a reusable workflow. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, see Running variations of jobs in a workflow . This example job below calls a reusable workflow and references the matrix context by defining the variable target with the values [dev, stage, prod] . It will run three jobs, one for each value in the variable.","jobs:
  ReuseableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}","jobs:
  call-reusable-workflow:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: owner/repo/.github/workflows/reusable-workflow.yml@commit-sha
    with:
      target: ${{ matrix.target }}
",0
984,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Calling a reusable workflow - Example caller workflow,"You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps. jobs.<job_id>.uses You reference reusable workflow files using one of the following syntaxes: In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions . If you use the second syntax option (without {owner}/{repo} and @{ref} ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword. You can call multiple workflows, referencing each in a separate job. This workflow file calls two workflow files. The second of these, workflow-B.yml (shown in the example reusable workflow ), is passed an input ( config-path ) and a secret ( token ).","name: Call a reusable workflow

on:
  pull_request:
    branches:
      - main

jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1

  call-workflow-passing-data:
    permissions:
      contents: read
      pull-requests: write
    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}","jobs:
  call-workflow-a:
    uses: owner/repo/.github/workflows/workflow-A.yml@main

  call-workflow-b:
    uses: owner/repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: 'path/to/config'
    secrets:
      token: ${{ secrets.TOKEN }}
",0
985,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Nesting reusable workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow.","name: Reusable workflow

on:
  workflow_call:

jobs:
  call-another-reusable:
    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1","jobs:
  call-workflow-1:
    uses: ./called-workflow-1.yml
",0
986,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Nesting reusable workflows - Passing secrets to nested workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow. You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions . Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C. In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.","jobs:
  workflowA-calls-workflowB:
    uses: octo-org/example-repo/.github/workflows/B.yml@main
    secrets: inherit # pass all secrets","jobs:
  call-workflow-b:
    uses: ./called-workflow-1.yml
    secrets: inherit

  call-workflow-c:
    uses: ./called-workflow-2.yml
    secrets:
      my_secret: ${{ secrets.my_secret }}
",0
987,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Nesting reusable workflows - Passing secrets to nested workflows,"You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml  called-workflow-1.yml  called-workflow-2.yml  called-workflow-3.yml . Loops in the workflow tree are not permitted. From within a reusable workflow you can call another reusable workflow. You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions . Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C. In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.","jobs:
  workflowB-calls-workflowC:
    uses: different-org/example-repo/.github/workflows/C.yml@main
    secrets:
      repo-token: ${{ secrets.personal_access_token }} # pass just this secret","jobs:
  call-workflow-b:
    uses: ./called-workflow-1.yml
    secrets: inherit

  call-workflow-c:
    uses: ./called-workflow-2.yml
    secrets:
      my_secret: ${{ secrets.my_secret }}

  call-workflow-d:
    uses: ./called-workflow-3.yml
",0
988,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Using outputs from a reusable workflow,"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow. If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow. The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: ""hello"" and ""world."" In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2 . In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1 , and one called secondword which we map to output2 . The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below. For more information, see Passing information between jobs and Workflow syntax for GitHub Actions .","name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: ""The first output string""
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: ""The second output string""
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo ""firstword=hello"" >> $GITHUB_OUTPUT
      - id: step2
        run: echo ""secondword=world"" >> $GITHUB_OUTPUT","jobs:
  example_job:
    runs-on: ubuntu-latest
    outputs:
      output1: ${{ steps.step1.outputs.step_output }}
      output2: ${{ steps.step2.outputs.step_output }}
    steps:
      - id: step1
        run: echo ""::set-output name=step_output::hello""
      - id: step2
        run: echo ""::set-output name=step_output::world""

on:
  workflow_call:
    outputs:
      firstword:
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        value: ${{ jobs.example_job.outputs.output2 }}
",0
989,https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions,Reusing workflows - Using outputs from a reusable workflow,"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow. If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow. The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: ""hello"" and ""world."" In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2 . In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1 , and one called secondword which we map to output2 . The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below. For more information, see Passing information between jobs and Workflow syntax for GitHub Actions . We can now use the outputs in the caller workflow, in the same way you would use the outputs from a job within the same workflow. We reference the outputs using the names defined at the workflow level in the reusable workflow: firstword and secondword . In this workflow, job1 calls the reusable workflow and job2 prints the outputs from the reusable workflow (""hello world"") to standard output in the workflow log.","name: Call a reusable workflow and use its outputs

on:
  workflow_dispatch:

jobs:
  job1:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}","jobs:
  reusable_workflow:
    runs:
      steps:
        - id: step1
          run: echo ""::set-output name=step_output1::hello""
        - id: step2
          run: echo ""::set-output name=step_output2::world""
    outputs:
      output1: ${{ steps.step1.outputs.step_output1 }}
      output2: ${{ steps.step2.outputs.step_output2 }}

on:
  workflow_call:
    outputs:
      firstword:
        value: ${{ jobs.reusable_workflow.outputs.output1 }}
      secondword:
        value: ${{ jobs.reusable_workflow.outputs.output2 }}

jobs:
  job1:
    uses: ./.github/workflows/reusable_workflow.yml
    outputs:
      firstword: ${{ steps.step1.outputs.step_output1 }}
      secondword: ${{ steps.step2.outputs.step_output2 }}

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ""${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}""
",0
990,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service,Deploying to Azure Kubernetes Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy a project to Azure Kubernetes Service when code is pushed to your repository. Under the workflow env key, change the following values: This workflow uses the helm render engine for the azure/k8s-bake action . If you will use the helm render engine, change the value of CHART_PATH to the path to your helm file. Change CHART_OVERRIDE_PATH to an array of override file paths. If you use a different render engine, update the input parameters sent to the azure/k8s-bake action.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and deploy to Azure Kubernetes Service

env:
  AZURE_CONTAINER_REGISTRY: MY_REGISTRY_NAME # set this to the name of your container registry
  PROJECT_NAME: MY_PROJECT_NAME              # set this to your project's name
  RESOURCE_GROUP: MY_RESOURCE_GROUP          # set this to the resource group containing your AKS cluster
  CLUSTER_NAME: MY_CLUSTER_NAME              # set this to the name of your AKS cluster
  REGISTRY_URL: MY_REGISTRY_URL              # set this to the URL of your registry
  # If you bake using helm:
  CHART_PATH: MY_HELM_FILE                   # set this to the path to your helm file
  CHART_OVERRIDE_PATH: MY_OVERRIDE_FILES     # set this to an array of override file paths

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@14a755a4e2fd6dff25794233def4f2cf3f866955
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Build image on ACR
      uses: azure/CLI@61bb69d64d613b52663984bf12d6bac8fd7b3cc8
      with:
        azcliversion: 2.29.1
        inlineScript: |
          az configure --defaults acr=${{ env.AZURE_CONTAINER_REGISTRY }}
          az acr build -t -t ${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}:${{ github.sha }}

    - name: Gets K8s context
      uses: azure/aks-set-context@94ccc775c1997a3fcfbfbce3c459fec87e0ab188
      with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          resource-group: ${{ env.RESOURCE_GROUP }}
          cluster-name: ${{ env.CLUSTER_NAME }}
      id: login

    - name: Configure deployment
      uses: azure/k8s-bake@61041e8c2f75c1f01186c8f05fb8b24e1fc507d8
      with:
        renderEngine: 'helm'
        helmChart: ${{ env.CHART_PATH }}
        overrideFiles: ${{ env.CHART_OVERRIDE_PATH }}
        overrides: |
          replicas:2
        helm-version: 'latest'
      id: bake

    - name: Deploys application
      uses: Azure/k8s-deploy@dd4bbd13a5abd2fc9ca8bdcb8aee152bb718fa78
      with:
        manifests: ${{ steps.bake.outputs.manifestsBundle }}
        images: |
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.PROJECT_NAME }}:${{ github.sha }}
        imagepullsecrets: |
          ${{ env.PROJECT_NAME }}","jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Azure CLI
      uses: azure/setup-azure-cli@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to Azure
      run: az login --service-principal -u ${{ secrets.AZURE_CLIENT_ID }} -p ${{ secrets.AZURE_CLIENT_SECRET }} --tenant ${{ secrets.AZURE_TENANT_ID }}

    - name: Set up Kubernetes
      run: az aks get-credentials --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} --name ${{ secrets.AZURE_AKS_CLUSTER }}

    - name: Bake manifest
      uses: azure/k8s-bake@v1
      with:
        renderEngine: helm
        CHART_PATH: ./path/to/helm/chart
        CHART_OVERRIDE_PATH: |
          ./path/to/override1.yaml
          ./path/to/override2.yaml

    - name: Deploy to AKS
      uses: azure/k8s-deploy@v1
      with:
        manifests: ${{ steps.bake.outputs.manifestsBundle }}
",0
991,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=cli,Using secrets in GitHub Actions - Using secrets in a workflow,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions .","steps:
  - name: Hello world action
    with: # Set the secret as an input
      super_secret: ${{ secrets.SuperSecret }}
    env: # Or as an environment variable
      super_secret: ${{ secrets.SuperSecret }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Use secret as environment variable
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}
        run: echo ""Using secret in the workflow""

      - name: Authenticate with cloud provider
        uses: actions/oidc-auth@v1
        with:
          provider: my-cloud-provider
          role: my-cloud-role
",0
992,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=cli,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Bash,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: bash
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$SUPER_SECRET""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret in Bash
        env:
          SUPER_SECRET: ${{ secrets.SuperSecret }}
        run: echo ""The secret is $SUPER_SECRET""
",0
993,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=cli,Using secrets in GitHub Actions - Using secrets in a workflow - Example using PowerShell,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: pwsh
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$env:SUPER_SECRET""","jobs:
  example:
    runs-on: ubuntu-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run PowerShell script
        shell: pwsh
        run: |
          Write-Host ""The secret is $env:SUPER_SECRET""
",0
994,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=cli,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Cmd.exe,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: cmd
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""%SUPER_SECRET%""","jobs:
  example:
    runs-on: windows-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run command with secret
        run: |
          echo %SUPER_SECRET%
        shell: cmd
",0
995,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=cli,Using secrets in GitHub Actions - Limits for secrets - Storing large secrets,"You can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets. A workflow created in a repository can access the following number of secrets: Secrets are limited to 48 KB in size. To store larger secrets, see the Storing large secrets workaround below. To use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can use gpg to encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see the gpg manpage . Warning  Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Warning Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Run the following command from your terminal to encrypt the file containing your secret using gpg and the AES256 cipher algorithm. In this example, my_secret.json is the file containing the secret. You will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value. Create a new secret that contains the passphrase. For example, create a new secret with the name LARGE_SECRET_PASSPHRASE and set the value of the secret to the passphrase you used in the step above. Copy your encrypted file to a path in your repository and commit it. In this example, the encrypted file is my_secret.json.gpg . Warning  Make sure to copy the encryptedmy_secret.json.gpgfile ending with the.gpgfile extension, andnotthe unencryptedmy_secret.jsonfile. Make sure to copy the encrypted my_secret.json.gpg file ending with the .gpg file extension, and not the unencrypted my_secret.json file. Create a shell script in your repository to decrypt the secret file. In this example, the script is named decrypt_secret.sh . Ensure your shell script is executable before checking it in to your repository. In your GitHub Actions workflow, use a step to call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use the actions/checkout action. Reference your shell script using the run command relative to the root of your repository.","name: Workflows with large secrets

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Decrypt large secret
        run: ./decrypt_secret.sh
        env:
          LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      # This command is just an example to show your secret being printed
      # Ensure you remove any print statements of your secrets. GitHub does
      # not hide secrets that use this workaround.
      - name: Test printing your secret (Remove this step in production)
        run: cat $HOME/secrets/my_secret.json","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Decrypt secret
      env:
        PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      run: |
        gpg --quiet --batch --yes --decrypt --passphrase=""$PASSPHRASE"" --output my_secret.json my_secret.json.gpg
        ./decrypt_secret.sh
",0
996,https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions?tool=cli,Using secrets in GitHub Actions - Storing Base64 binary blobs as secrets,"You can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, see Using secrets in GitHub Actions . Note  Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Note Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Use base64 to encode your file into a Base64 string. For example: On macOS, you could run: On Linux, you could run: Create a secret that contains the Base64 string. For example: To access the Base64 string from your runner, pipe the secret to base64 --decode . For example:","name: Retrieve Base64 secret
on:
  push:
    branches: [ octo-branch ]
jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Retrieve the secret and decode it to a file
        env:
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
        run: |
          echo $CERTIFICATE_BASE64 | base64 --decode > cert.der
      - name: Show certificate information
        run: |
          openssl x509 -in cert.der -inform DER -text -noout","jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Decode Base64 secret
        run: echo ${{ secrets.BASE64_SECRET }} | base64 --decode > decoded_file
",0
997,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-with-github-actions,Deploying with GitHub Actions - Triggering your deployment,"You can use a variety of events to trigger your deployment workflow. Some of the most common are: pull_request , push , and workflow_dispatch . For example, a workflow with the following triggers runs whenever:","on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:","on:
  pull_request:
  push:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    - name: Deploy
      run: echo ""Deploying application...""
",0
998,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-with-github-actions,Deploying with GitHub Actions - Using concurrency,"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see Control the concurrency of workflows and jobs . Note  concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. Note concurrency and environment are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. For example, when the following workflow runs, it will be paused with the status pending if any job or workflow that uses the production concurrency group is in progress. It will also cancel any job or workflow that uses the production concurrency group and has the status pending . This means that there will be a maximum of one running and one pending job or workflow in that uses the production concurrency group.","name: Deployment

concurrency: production

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: production
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying to production""
",0
999,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-with-github-actions,Deploying with GitHub Actions - Using concurrency,"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see Control the concurrency of workflows and jobs . Note  concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. Note concurrency and environment are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. For example, when the following workflow runs, it will be paused with the status pending if any job or workflow that uses the production concurrency group is in progress. It will also cancel any job or workflow that uses the production concurrency group and has the status pending . This means that there will be a maximum of one running and one pending job or workflow in that uses the production concurrency group. You can also specify concurrency at the job level. This will allow other jobs in the workflow to proceed even if the concurrent job is pending .","name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    concurrency: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying application""
",0
1000,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-with-github-actions,Deploying with GitHub Actions - Using concurrency,"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see Control the concurrency of workflows and jobs . Note  concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. Note concurrency and environment are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules. For example, when the following workflow runs, it will be paused with the status pending if any job or workflow that uses the production concurrency group is in progress. It will also cancel any job or workflow that uses the production concurrency group and has the status pending . This means that there will be a maximum of one running and one pending job or workflow in that uses the production concurrency group. You can also specify concurrency at the job level. This will allow other jobs in the workflow to proceed even if the concurrent job is pending . You can also use cancel-in-progress to cancel any currently running job or workflow in the same concurrency group.","name: Deployment

concurrency:
  group: production
  cancel-in-progress: true

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: production
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying application""
",0
1001,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:","on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true

jobs:
  example_job:
    concurrency: my-concurrency-group
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job with concurrency control""
",0
1002,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using concurrency and the default behavior,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs. For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch: You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:","on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true","jobs:
  example_job:
    concurrency: example-group
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Hello, World!""
",0
1003,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.","jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
",0
1004,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Concurrency groups,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key. The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables. It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group. This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary. In this example, job-1 is part of a concurrency group named staging_environment . This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled. Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:","on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true","jobs:
  job-1:
    concurrency:
      group: staging_environment
      cancel-in-progress: true
  job-2:
    concurrency:
      group: ci-${{ github.ref }}
      cancel-in-progress: true
",0
1005,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using concurrency to cancel any in-progress job or run,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true :","concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: my-concurrency-group
  cancel-in-progress: true
jobs:
  example_job:
    runs-on: ubuntu-latest
    concurrency:
      group: my-concurrency-group
      cancel-in-progress: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
1006,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Using a fallback value,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true","concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}
",0
1007,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Only cancel in-progress jobs or runs for the current workflow,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow. To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true","concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false
",0
1008,https://docs.github.com/en/actions/using-jobs/using-concurrency,Control the concurrency of workflows and jobs - Using concurrency in different scenarios - Example: Only cancel in-progress jobs on specific branches,"You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github , inputs , vars , needs , strategy , and matrix . For more information about expressions, see Evaluate expressions in workflows and actions . You can also specify concurrency at the workflow level. For more information, see concurrency . This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending . Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts. Note    The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order. Note If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches. To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:","concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}","jobs:
  example_job:
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: ${{ !startsWith(github.ref, 'refs/heads/release/') }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job""
",0
1009,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token,Controlling permissions for GITHUB_TOKEN - Defining access for the GITHUB_TOKEN permissions,"You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key.","permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none","permissions:
  contents: read
  issues: write
  actions: none
",0
1010,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token,Controlling permissions for GITHUB_TOKEN - Defining access for the GITHUB_TOKEN permissions,"You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: read-all,"permissions:
  contents: write
",0
1011,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token,Controlling permissions for GITHUB_TOKEN - Defining access for the GITHUB_TOKEN permissions,"You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions:",permissions: write-all,"permissions:
  contents: write
",0
1012,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token,Controlling permissions for GITHUB_TOKEN - Defining access for the GITHUB_TOKEN permissions,"You can define the access that the GITHUB_TOKEN will permit by specifying read , write , or none as the value of the available permissions within the permissions key. If you specify the access for any of these permissions, all of those that are not specified are set to none . You can use the following syntax to define one of read-all or write-all access for all of the available permissions: You can use the following syntax to disable permissions for all of the available permissions:",permissions: {},"permissions:
  contents: read
",0
1013,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token,Controlling permissions for GITHUB_TOKEN - Setting the GITHUB_TOKEN permissions for all jobs in a workflow - Example: Setting the GITHUB_TOKEN permissions for an entire workflow,"You can specify permissions at the top level of a workflow, so that the setting applies to all jobs in the workflow. This example shows permissions being set for the GITHUB_TOKEN that will apply to all jobs in the workflow. All permissions are granted read access.","name: ""My workflow""

on: [ push ]

permissions: read-all

jobs:
  ...","permissions:
  actions: read
  checks: read
  contents: read
  deployments: read
  issues: read
  packages: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read
",0
1014,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token,Controlling permissions for GITHUB_TOKEN - Setting the GITHUB_TOKEN permissions for a specific job - Example: Setting the GITHUB_TOKEN permissions for one job in a workflow,"For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication . By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions . This example shows permissions being set for the GITHUB_TOKEN that will only apply to the job named stale . Write access is granted for the issues and pull-requests permissions. All other permissions will have no access.","jobs:
  stale:
    runs-on: ubuntu-latest

    permissions:
      issues: write
      pull-requests: write

    steps:
      - uses: actions/stale@v9","jobs:
  stale:
    permissions:
      issues: write
      pull-requests: write
",0
1015,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-github-cli-in-workflows,Using GitHub CLI in workflows,"You can script with GitHub CLI in GitHub Actions workflows. NoteTo learn more about GitHub CLI, seeAbout GitHub CLI.  GitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable calledGH_TOKENto a token with the required scopes.  You can execute any GitHub CLI command. For example, this workflow uses thegh issue commentsubcommand to add a comment when an issue is opened. You can also execute API calls through GitHub CLI. For example, this workflow first uses thegh apisubcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step. In the second step, it uses thegh issue createsubcommand to create an issue containing the information from the first step. Note  To learn more about GitHub CLI, seeAbout GitHub CLI. Note To learn more about GitHub CLI, see About GitHub CLI . GitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable called GH_TOKEN to a token with the required scopes. You can execute any GitHub CLI command. For example, this workflow uses the gh issue comment subcommand to add a comment when an issue is opened.","name: Comment when opened
on:
  issues:
    types:
      - opened
jobs:
  comment:
    runs-on: ubuntu-latest
    steps:
      - run: gh issue comment $ISSUE --body ""Thank you for opening this issue!""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE: ${{ github.event.issue.html_url }}","jobs:
  github-cli:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Add comment to issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh issue comment 1 --body ""This is a comment added by GitHub CLI""
",0
1016,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-github-cli-in-workflows,Using GitHub CLI in workflows,"You can also execute API calls through GitHub CLI. For example, this workflow first uses the gh api subcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step. In the second step, it uses the gh issue create subcommand to create an issue containing the information from the first step.","name: Report remaining open issues
on: 
  schedule: 
    # Daily at 8:20 UTC
    - cron: '20 8 * * *'
jobs:
  track_pr:
    runs-on: ubuntu-latest
    steps:
      - run: |
          numOpenIssues=""$(gh api graphql -F owner=$OWNER -F name=$REPO -f query='
            query($name: String!, $owner: String!) {
              repository(owner: $owner, name: $name) {
                issues(states:OPEN){
                  totalCount
                }
              }
            }
          ' --jq '.data.repository.issues.totalCount')""

          echo 'NUM_OPEN_ISSUES='$numOpenIssues >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
      - run: |
          gh issue create --title ""Issue report"" --body ""$NUM_OPEN_ISSUES issues remaining"" --repo $GITHUB_REPOSITORY
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  use-gh-cli:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Query GraphQL API
        run: |
          result=$(gh api graphql -f query='
            {
              viewer {
                login
              }
            }
          ' --jq '.data.viewer.login')
          echo ""result=$result"" >> $GITHUB_ENV
      - name: Create issue
        run: |
          gh issue create --title ""GraphQL Query Result"" --body ""The login is ${{ env.result }}""
",0
1017,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=windows,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run a one-line script
      run: echo ""Hello, world!""
",0
1018,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=windows,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: OWNER/REPO@SHA
        with:
          who-to-greet: ""Your Name""
",0
1019,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions&platform=windows,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
    - run: ./goodbye.sh
      shell: bash
",0
1020,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-maven,Publishing Java packages with Maven - Publishing packages to the Maven Central Repository,"Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the release event triggers with type created . The workflow publishes the package to the Maven Central Repository if CI tests pass. For more information on the release event, see Events that trigger workflows . In this workflow, you can use the setup-java action. This action installs the given version of the JDK into the PATH , but it also configures a Maven settings.xml for publishing packages. By default, the settings file will be configured for GitHub Packages, but it can be configured to deploy to another package registry, such as the Maven Central Repository. If you already have a distribution management repository configured in pom.xml , then you can specify that id during the setup-java action invocation. For example, if you were deploying to the Maven Central Repository through the OSSRH hosting project, your pom.xml could specify a distribution management repository with the id of ossrh . With this configuration, you can create a workflow that publishes your package to the Maven Central Repository by specifying the repository management id to the setup-java action. Youll also need to provide environment variables that contain the username and password to authenticate to the repository. In the deploy step, youll need to set the environment variables to the username that you authenticate with to the repository, and to a secret that youve configured with the password or token to authenticate with. For more information, see Using secrets in GitHub Actions .","name: Publish package to the Maven Central Repository
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Maven Central Repository
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          server-id: ossrh
          server-username: MAVEN_USERNAME
          server-password: MAVEN_PASSWORD
      - name: Publish package
        run: mvn --batch-mode deploy
        env:
          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}","on:
  release:
    types: [created]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
        server-id: 'ossrh'
        settings-path: ${{ github.workspace }}
    - name: Build with Maven
      run: mvn clean install
    - name: Deploy to Maven Central
      env:
        OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
        OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
      run: mvn deploy -s ${{ github.workspace }}/settings.xml
",0
1021,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-maven,Publishing Java packages with Maven - Publishing packages to GitHub Packages,"Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the release event triggers with type created . The workflow publishes the package to GitHub Packages if CI tests pass. For more information on the release event, see Events that trigger workflows . In this workflow, you can use the setup-java action. This action installs the given version of the JDK into the PATH , and also sets up a Maven settings.xml for publishing the package to GitHub Packages. The generated settings.xml defines authentication for a server with an id of github , using the GITHUB_ACTOR environment variable as the username and the GITHUB_TOKEN environment variable as the password. The GITHUB_TOKEN environment variable is assigned the value of the special GITHUB_TOKEN secret. The GITHUB_TOKEN secret is set to an access token for the repository each time a job in a workflow begins. You should set the permissions for this access token in the workflow file to grant read access for the contents permission and write access for the packages permission. For more information, see Automatic token authentication . For a Maven-based project, you can make use of these settings by creating a distribution repository in your pom.xml file with an id of github that points to your GitHub Packages endpoint. For example, if your organization is named ""octocat"" and your repository is named ""hello-world"", then the GitHub Packages configuration in pom.xml would look similar to the below example. With this configuration, you can create a workflow that publishes your package to GitHub Packages by making use of the automatically generated settings.xml .","name: Publish package to GitHub Packages
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
      - name: Publish package
        run: mvn --batch-mode deploy
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}","permissions:
  contents: read
  packages: write

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
        server-id: github
        server-username: GITHUB_ACTOR
        server-password: GITHUB_TOKEN
    - name: Build with Maven
      run: mvn clean install
    - name: Publish to GitHub Packages
      run: mvn deploy
",0
1022,https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-maven,Publishing Java packages with Maven - Publishing packages to the Maven Central Repository and GitHub Packages,"You can publish your packages to both the Maven Central Repository and GitHub Packages by using the setup-java action for each registry. Ensure your pom.xml file includes a distribution management repository for both your GitHub repository and your Maven Central Repository provider. For example, if you deploy to the Central Repository through the OSSRH hosting project, you might want to specify it in a distribution management repository with the id set to ossrh , and you might want to specify GitHub Packages in a distribution management repository with the id set to github .","name: Publish package to the Maven Central Repository and GitHub Packages
on:
  release:
    types: [created]
jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up Java for publishing to Maven Central Repository
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          server-id: ossrh
          server-username: MAVEN_USERNAME
          server-password: MAVEN_PASSWORD
      - name: Publish to the Maven Central Repository
        run: mvn --batch-mode deploy
        env:
          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}
      - name: Set up Java for publishing to GitHub Packages
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
      - name: Publish to GitHub Packages
        run: mvn --batch-mode deploy
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'adopt'
    - name: Publish to Maven Central
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'adopt'
        server-id: ossrh
        settings-path: ${{ github.workspace }}
    - name: Publish to GitHub Packages
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'adopt'
        server-id: github
        settings-path: ${{ github.workspace }}
    - name: Build and Publish
      run: mvn deploy --settings ${{ github.workspace }}/settings.xml
",0
1023,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog,Configuring OpenID Connect in JFrog - Updating your GitHub Actions workflow,"Once you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file. In your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform. The following example uses the placeholder YOUR_PROVIDER_NAME .","- name: Fetch Access Token from Artifactory
        id: fetch_access_token
        env:
          ID_TOKEN: $
        run: |
          ACCESS_TOKEN=$(curl \
          -X POST \
          -H ""Content-type: application/json"" \
          https://example.jfrog.io/access/api/v1/oidc/token \
          -d \
          ""{\""grant_type\"": \""urn:ietf:params:oauth:grant-type:token-exchange\"", \""subject_token_type\"":\""urn:ietf:params:oauth:token-type:id_token\"", \""subject_token\"": \""$ID_TOKEN\"", \""provider_name\"": \""YOUR_PROVIDER_NAME\""}"" | jq .access_token | tr -d '""')
          echo ACCESS_TOKEN=$ACCESS_TOKEN >> $GITHUB_OUTPUT","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Authenticate with JFrog
        uses: jfrog/setup-jfrog-cli@v2
        with:
          provider: YOUR_PROVIDER_NAME
          audience: YOUR_AUDIENCE
",0
1024,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog,Configuring OpenID Connect in JFrog - Updating your GitHub Actions workflow,"Once you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file. In your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform. The following example uses the placeholder YOUR_PROVIDER_NAME . The following example shows part of a GitHub Actions workflow file using cURL.","- name: Get ID Token (cURL method)
        id: idtoken
        run: |
          ID_TOKEN=$(curl -sLS -H ""User-Agent: actions/oidc-client"" -H ""Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN"" \
          ""${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=jfrog-github"" | jq .value | tr -d '""')
          echo ""ID_TOKEN=${ID_TOKEN}"" >> $GITHUB_OUTPUT","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Authenticate with JFrog
        uses: actions/github-script@v6
        with:
          script: |
            const { execSync } = require('child_process');
            execSync('curl -X POST -H ""Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"" -H ""Content-Type: application/json"" -d \'{""audience"": ""YOUR_AUDIENCE"", ""provider"": ""YOUR_PROVIDER_NAME""}\' https://your.jfrog.instance/api/security/token');
",0
1025,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog,Configuring OpenID Connect in JFrog - Updating your GitHub Actions workflow,"Once you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file. In your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform. The following example uses the placeholder YOUR_PROVIDER_NAME . The following example shows part of a GitHub Actions workflow file using cURL. Alternatively, you can set the audience as an environment variable using the env context. For more information about the env context, see Accessing contextual information about workflow runs . Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment .","jobs:
  build:
    runs-on: ubuntu-latest
    env:
      OIDC_AUDIENCE: 'YOUR_AUDIENCE'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Authenticate with JFrog
        id: auth
        uses: actions/github-script@v6
        with:
          script: |
            const { getIDToken } = require('@actions/core');
            const idToken = await getIDToken('YOUR_PROVIDER_NAME');
            return idToken;

      - name: Use cURL with JFrog
        run: |
          curl -H ""Authorization: Bearer ${{ steps.auth.outputs.idToken }}"" https://your.jfrog.instance/api/your-endpoint
",0
1026,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog,Configuring OpenID Connect in JFrog - Updating your GitHub Actions workflow,"Once you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file. In your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform. The following example uses the placeholder YOUR_PROVIDER_NAME . The following example shows part of a GitHub Actions workflow file using cURL. Alternatively, you can set the audience as an environment variable using the env context. For more information about the env context, see Accessing contextual information about workflow runs . Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . Then, in your workflow file, retrieve the value of the variables stored in the env context. The following example uses the env context to retrieve the OIDC audience.","- name: Get ID Token (using env context)
        uses: actions/github-script@v7
        id: idtoken
        with:
          script: |
            const coredemo = require('@actions/core');
            let id_token = await coredemo.getIDToken(process.env.OIDC_AUDIENCE);
            coredemo.setOutput('id_token', id_token);","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Retrieve OIDC token
        id: oidc
        uses: actions/github-script@v6
        with:
          script: |
            return {
              audience: process.env.YOUR_AUDIENCE
            }

      - name: Use cURL with OIDC
        run: |
          curl -H ""Authorization: Bearer ${{ steps.oidc.outputs.audience }}"" https://your.jfrog.instance/api/your-endpoint
",0
1027,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action?learn=create_actions&learnProduct=actions,Creating a Docker container action - Creating an action metadata file,"Create a new action.yml file in the hello-world-docker-action directory you created above. For more information, see Metadata syntax for GitHub Actions . action.yml","# action.yml
name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.who-to-greet }}","name: 'Hello World Docker Action'
description: 'A simple Docker container action'
inputs:
  who-to-greet:
    description: 'Who to greet'
    required: true
    default: 'World'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.who-to-greet }}
",0
1028,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action?learn=create_actions&learnProduct=actions,Creating a Docker container action - Testing out your action in a workflow - Example using a public action,"Now you're ready to test your action out in a workflow. The following workflow code uses the completed hello world action in the public actions/hello-world-docker-action repository. Copy the following workflow example code into a .github/workflows/main.yml file, but replace the actions/hello-world-docker-action with your repository and action name. You can also replace the who-to-greet input with your name. Public actions can be used even if they're not published to GitHub Marketplace. For more information, see Publishing actions in GitHub Marketplace . .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: actions/hello-world-docker-action@v2
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run my Docker action
        uses: your-repo/your-action-name
        with:
          who-to-greet: 'Your Name'
",0
1029,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action?learn=create_actions&learnProduct=actions,Creating a Docker container action - Testing out your action in a workflow - Example using a private action,"Now you're ready to test your action out in a workflow. Copy the following example workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. This private action can't be published to GitHub Marketplace, and can only be used in this repository. .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","on: push
jobs:
  test-action:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run action
        uses: ./ # Uses an action in the root directory
        with:
          who-to-greet: 'Your Name'
",0
1030,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action?learn=create_actions&learnProduct=actions,Creating a Docker container action - Accessing files created by a container action,"When a container action runs, it will automatically map the default working directory ( GITHUB_WORKSPACE ) on the runner with the /github/workspace directory on the container. Any files added to this directory on the container will be available to any subsequent steps in the same job. For example, if you have a container action that builds your project, and you would like to upload the build output as an artifact, you can use the following steps. workflow.yml","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Output build artifacts to /github/workspace on the container.
      - name: Containerized Build
        uses: ./.github/actions/my-container-action

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workspace_artifacts
          path: ${{ github.workspace }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build project
        uses: ./path-to-your-container-action

      - name: Upload build artifact
        uses: actions/upload-artifact@v2
        with:
          name: build-output
          path: /github/workspace/build-output
",0
1031,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-circleci-with-github-actions-importer,Migrating from CircleCI with GitHub Actions Importer - Reference - Optional arguments - --config-file-path - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from CircleCI. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. The --config-file-path argument can also be used to specify which repository a converted composite action should be migrated to. In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit. To audit a CircleCI instance using a config file, the config file must be in the following format, and each repository_slug must be unique:","source_files:
  - repository_slug: circle-org-name/circle-project-name
    path: path/to/.circleci/config.yml
  - repository_slug: circle-org-name/some-other-circle-project-name
    path: path/to/.circleci/config.yml","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer Audit
        run: |
          gh actions-importer audit --config-file-path path/to/config.yml
",0
1032,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-circleci-with-github-actions-importer,Migrating from CircleCI with GitHub Actions Importer - Reference - Optional arguments - --config-file-path - Specify the repository of converted composite actions,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from CircleCI. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. The --config-file-path argument can also be used to specify which repository a converted composite action should be migrated to. GitHub Actions Importer uses the YAML file provided to the --config-file-path argument to determine the repository that converted composite actions are migrated to. To begin, you should run an audit without the --config-file-path argument: The output of this command will contain a file named config.yml that contains a list of all the composite actions that were converted by GitHub Actions Importer. For example, the config.yml file may have the following contents:","composite_actions:
  - name: my-composite-action.yml
    target_url: https://github.com/octo-org/octo-repo
    ref: main","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer
        run: |
          gh actions-importer audit
          gh actions-importer dry-run --config-file-path config.yml
          gh actions-importer migrate --config-file-path config.yml
",0
1033,https://docs.github.com/en/actions/managing-issues-and-pull-requests/scheduling-issue-creation,Scheduling issue creation - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Weekly Team Sync
on:
  schedule:
    - cron: 20 07 * * 1

jobs:
  create_issue:
    name: Create team sync issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Create team sync issue
        run: |
          if [[ $CLOSE_PREVIOUS == true ]]; then
            previous_issue_number=$(gh issue list \
              --label ""$LABELS"" \
              --json number \
              --jq '.[0].number')
            if [[ -n $previous_issue_number ]]; then
              gh issue close ""$previous_issue_number""
              gh issue unpin ""$previous_issue_number""
            fi
          fi
          new_issue_url=$(gh issue create \
            --title ""$TITLE"" \
            --assignee ""$ASSIGNEES"" \
            --label ""$LABELS"" \
            --body ""$BODY"")
          if [[ $PINNED == true ]]; then
            gh issue pin ""$new_issue_url""
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          TITLE: Team sync
          ASSIGNEES: monalisa,doctocat,hubot
          LABELS: weekly sync,docs-team
          BODY: |
            ### Agenda

            - [ ] Start the recording
            - [ ] Check-ins
            - [ ] Discussion points
            - [ ] Post the recording

            ### Discussion Points
            Add things to discuss below

            - [Work this week](https://github.com/orgs/github/projects/3)
          PINNED: false
          CLOSE_PREVIOUS: false","on:
  schedule:
    - cron: '0 9 * * 1'

jobs:
  create_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub Issue
        uses: actions/github-script@v6
        with:
          script: |
            const { data: issue } = await github.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'Weekly Update',
              body: 'Please provide your weekly update.',
            });
",0
1034,https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Creating an action metadata file,"Create a new action.yml file in the hello-world-docker-action directory you created above. For more information, see Metadata syntax for GitHub Actions . action.yml","# action.yml
name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.who-to-greet }}","name: 'Hello World Docker Action'
description: 'A simple Docker container action'
inputs:
  myInput:
    description: 'An example input'
    required: true
    default: 'World'
outputs:
  myOutput:
    description: 'An example output'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.myInput }}
",0
1035,https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Testing out your action in a workflow - Example using a public action,"Now you're ready to test your action out in a workflow. The following workflow code uses the completed hello world action in the public actions/hello-world-docker-action repository. Copy the following workflow example code into a .github/workflows/main.yml file, but replace the actions/hello-world-docker-action with your repository and action name. You can also replace the who-to-greet input with your name. Public actions can be used even if they're not published to GitHub Marketplace. For more information, see Publishing actions in GitHub Marketplace . .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: actions/hello-world-docker-action@v2
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","name: Test Docker Action
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run my Docker action
        uses: your-repo/your-action-name
        with:
          who-to-greet: Your Name
",0
1036,https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Testing out your action in a workflow - Example using a private action,"Now you're ready to test your action out in a workflow. Copy the following example workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. This private action can't be published to GitHub Marketplace, and can only be used in this repository. .github/workflows/main.yml","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo ""The time was ${{ steps.hello.outputs.time }}""","name: ""Test Docker Action""
on:
  push:
    branches:
      - main
jobs:
  test-action:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      - name: Run Docker Action
        uses: ./ # Uses an action in the root directory
        with:
          who-to-greet: ""Your Name""
",0
1037,https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action,Creating a Docker container action - Accessing files created by a container action,"When a container action runs, it will automatically map the default working directory ( GITHUB_WORKSPACE ) on the runner with the /github/workspace directory on the container. Any files added to this directory on the container will be available to any subsequent steps in the same job. For example, if you have a container action that builds your project, and you would like to upload the build output as an artifact, you can use the following steps. workflow.yml","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Output build artifacts to /github/workspace on the container.
      - name: Containerized Build
        uses: ./.github/actions/my-container-action

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workspace_artifacts
          path: ${{ github.workspace }}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Build project
        uses: ./path-to-your-container-action

      - name: Upload build artifact
        uses: actions/upload-artifact@v2
        with:
          name: build-output
          path: /github/workspace/build-output
",0
1038,https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Understanding the risk of script injections - Example of a script injection attack,"When creating workflows, custom actions , and composite actions , you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner. Attackers can add their own malicious content to the github context , which should be treated as potentially untrusted input. These contexts typically end with body , default_branch , email , head_ref , label , message , name , page_name , ref , and title . For example: github.event.issue.title , or github.event.pull_request.body . You should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions . In addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, zzz"";echo${IFS}""hello"";# would be a valid branch name and would be a possible attack vector for a target repository. The following sections explain how you can help mitigate the risk of script injection. A script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:","- name: Check PR title
        run: |
          title=""${{ github.event.pull_request.title }}""
          if [[ $title =~ ^octocat ]]; then
          echo ""PR title starts with 'octocat'""
          exit 0
          else
          echo ""PR title did not start with 'octocat'""
          exit 1
          fi","jobs:
  check-pr-title:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Validate PR title
        run: |
          title=""${{ github.event.pull_request.title }}""
          if [[ ""$title"" =~ [^a-zA-Z0-9\ ] ]]; then
            echo ""Invalid PR title""
            exit 1
          fi
",0
1039,https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Good practices for mitigating script injection attacks - Using an action instead of an inline script (recommended),"There are a number of different approaches available to help you mitigate the risk of script injection: The recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:","uses: fakeaction/checktitle@v3
with:
    title: ${{ github.event.pull_request.title }}","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: your-username/your-action-repo@v1
        with:
          context-value: ${{ github.event.some_context_value }}
",0
1040,https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Good practices for mitigating script injection attacks - Using an intermediate environment variable,"There are a number of different approaches available to help you mitigate the risk of script injection: For inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable. The following example uses Bash to process the github.event.pull_request.title value as an environment variable:","- name: Check PR title
        env:
          TITLE: ${{ github.event.pull_request.title }}
        run: |
          if [[ ""$TITLE"" =~ ^octocat ]]; then
          echo ""PR title starts with 'octocat'""
          exit 0
          else
          echo ""PR title did not start with 'octocat'""
          exit 1
          fi","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - name: Set up environment
        run: echo ""PR_TITLE=${{ github.event.pull_request.title }}"" >> $GITHUB_ENV
      - name: Process title
        run: |
          echo ""Processing PR title: $PR_TITLE""
",0
1041,https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions,Security hardening for GitHub Actions - Potential impact of a compromised runner - Accessing secrets,"These sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner. Note  GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library. Note GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library. Workflows triggered from a forked repository using the pull_request event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as issue_comment , issues , push and pull_request from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's GITHUB_TOKEN . If the secret or token is set to an environment variable, it can be directly accessed through the environment using printenv . If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible. For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:","uses: fakeaction/publish@v3
with:
    key: ${{ secrets.PUBLISH_KEY }}","jobs:
  security_hardening:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run security checks
        run: |
          echo ""Running security checks""
          # Example of accessing environment variables
          printenv

      - name: Use custom action
        uses: ./custom-action
        with:
          secret: ${{ secrets.MY_SECRET }}
",0
1042,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - branch_protection_rule,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, see About protected branches . For information about the branch protection rule APIs, see Objects in the GraphQL API documentation or REST API endpoints for branches and their settings . For example, you can run a workflow when a branch protection rule has been created or deleted :","on:
  branch_protection_rule:
    types: [created, deleted]","on:
  branch_protection_rule:
    types: [created, deleted]

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1043,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - check_run,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, see Using the REST API to interact with checks . For information about the check run APIs, see Objects in the GraphQL API documentation or REST API endpoints for check runs . For example, you can run a workflow when a check run has been rerequested or completed .","on:
  check_run:
    types: [rerequested, completed]","on:
  check_run:
    types: [rerequested, completed]

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1044,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - check_suite,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. Although only thecompletedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . Although only the completed activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions. To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions. Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, see Using the REST API to interact with checks . For information about the check suite APIs, see Objects in the GraphQL API documentation or REST API endpoints for check suites . For example, you can run a workflow when a check suite has been completed .","on:
  check_suite:
    types: [completed]","on:
  check_suite:
    types: [completed]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1045,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - create,"Note  An event will not be created when you create more than three tags at once. Note An event will not be created when you create more than three tags at once. Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references . For example, you can run a workflow when the create event occurs.","on:
  create","on:
  create:
jobs:
  run-on-create:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""A Git reference was created.""
",0
1046,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - delete,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Note  An event will not be created when you delete more than three tags at once. An event will not be created when you delete more than three tags at once. Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references . For example, you can run a workflow when the delete event occurs.","on:
  delete","on: 
  delete:
jobs:
  run-on-delete:
    runs-on: ubuntu-latest
    steps:
      - name: Run on delete
        run: echo ""A Git reference was deleted.""
",0
1047,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - deployment,"Runs your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, see Mutations in the GraphQL API documentation or REST API endpoints for repositories . For example, you can run a workflow when the deployment event occurs.","on:
  deployment","on:
  deployment:

jobs:
  deployment_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run deployment script
        run: echo ""Deployment triggered""
",0
1048,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - deployment_status,"Note  When a deployment status's state is set toinactive, a workflow run will not be triggered. Note When a deployment status's state is set to inactive , a workflow run will not be triggered. Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, see Mutations in the GraphQL API documentation or REST API endpoints for deployments . For example, you can run a workflow when the deployment_status event occurs.","on:
  deployment_status","on:
  deployment_status

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Print deployment status
        run: echo ""Deployment status event triggered""
",0
1049,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - discussion,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  Webhook events for GitHub Discussions are currently in public preview and subject to change. Webhook events for GitHub Discussions are currently in public preview and subject to change. Runs your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use the discussion_comment event. For more information about discussions, see About discussions . For information about the GraphQL API, see Objects . For example, you can run a workflow when a discussion has been created , edited , or answered .","on:
  discussion:
    types: [created, edited, answered]","on:
  discussion:
    types: [created, edited, answered]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1050,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - discussion_comment,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  Webhook events for GitHub Discussions are currently in public preview and subject to change. Webhook events for GitHub Discussions are currently in public preview and subject to change. Runs your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the discussion event. For more information about discussions, see About discussions . For information about the GraphQL API, see Objects . For example, you can run a workflow when a discussion comment has been created or deleted .","on:
  discussion_comment:
    types: [created, deleted]","on:
  discussion_comment:
    types: [created, edited]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1051,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - fork,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when someone forks a repository. For information about the REST API, see REST API endpoints for forks . For example, you can run a workflow when the fork event occurs.","on:
  fork","on:
  fork:
jobs:
  run-on-fork:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run a script
        run: echo ""Fork event triggered""
",0
1052,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - gollum,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when someone creates or updates a Wiki page. For more information, see About wikis . For example, you can run a workflow when the gollum event occurs.","on:
  gollum","on: 
  gollum:
jobs:
  wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Log Wiki Update
        run: echo ""A Wiki page was created or updated.""
",0
1053,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - issue_comment,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see Objects in the GraphQL API documentation or Webhook events and payloads in the REST API documentation. For example, you can run a workflow when an issue or pull request comment has been created or deleted .","on:
  issue_comment:
    types: [created, deleted]","on:
  issue_comment:
    types: [created, deleted]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
1054,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - issue_comment - issue_comment on issues only or pull requests only,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see Objects in the GraphQL API documentation or Webhook events and payloads in the REST API documentation. For example, you can run a workflow when an issue or pull request comment has been created or deleted . The issue_comment event occurs for comments on both issues and pull requests. You can use the github.event.issue.pull_request property in a conditional to take different action depending on whether the triggering object was an issue or pull request. For example, this workflow will run the pr_commented job only if the issue_comment event originated from a pull request. It will run the issue_commented job only if the issue_comment event originated from an issue.","on: issue_comment

jobs:
  pr_commented:
    # This job only runs for pull request comments
    name: PR comment
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on PR $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}

  issue_commented:
    # This job only runs for issue comments
    name: Issue comment
    if: ${{ !github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on issue $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}","on:
  issue_comment:
    types: [created, deleted]

jobs:
  pr_commented:
    if: github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Comment on a pull request""

  issue_commented:
    if: ""!github.event.issue.pull_request""
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Comment on an issue""
",0
1055,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - issues,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use the issue_comment event. For more information about issues, see About issues . For information about the issue APIs, see Objects in the GraphQL API documentation or REST API endpoints for issues . For example, you can run a workflow when an issue has been opened , edited , or milestoned .","on:
  issues:
    types: [opened, edited, milestoned]","on:
  issues:
    types: [opened, edited, milestoned]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1056,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - label,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when a label in your workflow's repository is created or modified. For more information about labels, see Managing labels . For information about the label APIs, see Objects in the GraphQL API documentation or REST API endpoints for labels . If you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use the labeled or unlabeled activity types for the issues , pull_request , pull_request_target , or discussion events instead. For example, you can run a workflow when a label has been created or deleted .","on:
  label:
    types: [created, deleted]","on:
  label

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1057,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - merge_group,"Note    More than one activity type triggers this event. Although only thechecks_requestedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.If your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include themerge_groupevent as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. Themerge_groupevent is separate from thepull_requestandpushevents. Note Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information see Merging a pull request with a merge queue . For example, you can run a workflow when the checks_requested activity has occurred.","on:
  pull_request:
    branches: [ ""main"" ]
  merge_group:
    types: [checks_requested]","on:
  merge_group:
    types: [checks_requested]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'
      - run: npm install
      - run: npm test
",0
1058,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - milestone,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, see About milestones . For information about the milestone APIs, see Objects in the GraphQL API documentation or REST API endpoints for milestones . If you want to run your workflow when an issue is added to or removed from a milestone, use the milestoned or demilestoned activity types for the issues event instead. For example, you can run a workflow when a milestone has been opened or deleted .","on:
  milestone:
    types: [opened, deleted]","on:
  milestone:
    types: [created, edited, closed, opened, deleted]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1059,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - page_build,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, see Configuring a publishing source for your GitHub Pages site . For information about the REST API, see REST API endpoints for repositories . For example, you can run a workflow when the page_build event occurs.","on:
  page_build","on:
  page_build:
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Run a script
        run: echo ""Page build event triggered""
",0
1060,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - public,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when your workflow's repository changes from private to public. For information about the REST API, see REST API endpoints for repositories . For example, you can run a workflow when the public event occurs.","on:
  public","on:
  public:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Repository is now public!""
",0
1061,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened.","on:
  pull_request:
    types: [opened, reopened]","on:
  pull_request:
    types: [opened, reopened]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
1062,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested.","on:
  pull_request:
    types: [review_requested]
jobs:
  specific_review_requested:
    runs-on: ubuntu-latest
    if: ${{ github.event.requested_team.name == 'octo-team'}}
    steps:
      - run: echo 'A review from octo-team was requested'","on:
  pull_request:
    types:
      - review_requested

jobs:
  specific_review_requested:
    if: github.event.requested_reviewer.login == 'octo-team'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1063,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on the head or base branch of a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'","on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches:
      - 'releases/**'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1064,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on the head or base branch of a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
1065,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on the head or base branch of a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ : To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo ""The head of this PR starts with 'releases/'""","on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'

jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job for releases/* branch""
",0
1066,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on files changed in a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can also configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ):","on:
  pull_request:
    paths:
      - '**.js'","on:
  pull_request:
    paths:
      - '**/*.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
1067,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on files changed in a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can also configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ): Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
1068,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow when a pull request merges,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request  closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.","on:
  pull_request:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged","on:
  pull_request:
    types: [closed]

jobs:
  if_merged:
    runs-on: ubuntu-latest
    steps:
      - name: Check if merged
        if: github.event.pull_request.merged == true
        run: echo ""The pull request was merged.""
",0
1069,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_review,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the pull_request_review_comment or issue_comment events instead. For information about the pull request review APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . For example, you can run a workflow when a pull request review has been edited or dismissed .","on:
  pull_request_review:
    types: [edited, dismissed]","on:
  pull_request_review:
    types: [submitted, edited, dismissed]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Pull request review event triggered""
",0
1070,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_review - Running a workflow when a pull request is approved,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the pull_request_review_comment or issue_comment events instead. For information about the pull request review APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . For example, you can run a workflow when a pull request review has been edited or dismissed . To run your workflow when a pull request has been approved, you can trigger your workflow with the submitted type of pull_request_review event, then check the review state with the github.event.review.state property. For example, this workflow will run whenever a pull request review is submitted, but the approved job will only run if the submitted review is an approving review:","on:
  pull_request_review:
    types: [submitted]

jobs:
  approved:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This PR was approved""","on:
  pull_request_review:
    types: [submitted]

jobs:
  approved:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1071,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_review_comment,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use the pull_request_review or issue_comment events instead. For information about the pull request review comment APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . For example, you can run a workflow when a pull request review comment has been created or deleted .","on:
  pull_request_review_comment:
    types: [created, deleted]","on:
  pull_request_review_comment:
    types: [edited]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v3
",0
1072,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened .","on:
  pull_request_target:
    types: [assigned, opened, synchronize, reopened]","on:
  pull_request_target:
    types: [assigned, opened, synchronize, reopened]
",0
1073,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on the head or base branch of a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'","on:
  pull_request_target:
    branches:
      - 'releases/*'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1074,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on the head or base branch of a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request_target:
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1075,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on the head or base branch of a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ : To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo ""The head of this PR starts with 'releases/'""","on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'

jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1076,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on files changed in a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the paths or paths-ignore filter to configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ):","on:
  pull_request_target:
    paths:
      - '**.js'","on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    paths:
      - '**.js'

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1077,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on files changed in a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the paths or paths-ignore filter to configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ): Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    paths:
      - '**/*.js'
    branches:
      - 'releases/**'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1078,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow when a pull request merges,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request_target  closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.","on:
  pull_request_target:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged","on:
  pull_request_target:
    types: [closed]

jobs:
  if_merged:
    runs-on: ubuntu-latest
    steps:
      - name: Check if merged
        if: github.event.pull_request.merged == true
        run: echo ""The pull request was merged.""
",0
1079,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - push,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs.","on:
  push","on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
1080,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push to specific branches occurs,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the branches or branches-ignore filter to configure your workflow to only run when specific branches are pushed. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes to main or to a branch that starts with releases/ .","on:
  push:
    branches:
      - 'main'
      - 'releases/**'","on:
  push:
    branches:
      - main
      - 'releases/**'
",0
1081,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push to specific branches occurs,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the branches or branches-ignore filter to configure your workflow to only run when specific branches are pushed. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes to main or to a branch that starts with releases/ . Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript ( .js ) file is made to a branch whose name starts with releases/ :","on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  push:
    branches:
      - main
      - 'releases/*'
    paths:
      - '**.js'
",0
1082,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push of specific tags occurs,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the tags or tags-ignore filter to configure your workflow to only run when specific tags are pushed. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes a tag that starts with v1. .","on:
  push:
    tags:
      - v1.**","on:
  push:
    tags:
      - 'v1.*'
",0
1083,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push affects specific files,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the paths or paths-ignore filter to configure your workflow to run when a push to specific files occurs. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes a change to a JavaScript file ( .js ):","on:
  push:
    paths:
      - '**.js'","on:
  push:
    paths:
      - '**/*.js'
",0
1084,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push affects specific files,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the paths or paths-ignore filter to configure your workflow to run when a push to specific files occurs. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes a change to a JavaScript file ( .js ): Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript ( .js ) file is made to a branch whose name starts with releases/ :","on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
",0
1085,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - registry_package,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional: When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:","jobs:
    job_name:
        if: $true","on:
  registry_package

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
1086,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - registry_package,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional: When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional: Runs your workflow when activity related to GitHub Packages occurs in your repository. For more information, see GitHub Packages Documentation . For example, you can run a workflow when a new package version has been published .","on:
  registry_package:
    types: [published]","on:
  registry_package

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1087,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - release,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  Workflows are not triggered for thecreated,edited, ordeletedactivity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft. Workflows are not triggered for the created , edited , or deleted activity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft. Note  Theprereleasedtype will not trigger for pre-releases published from draft releases, but thepublishedtype will trigger. If you want a workflow to run when stableandpre-releases publish, subscribe topublishedinstead ofreleasedandprereleased. The prereleased type will not trigger for pre-releases published from draft releases, but the published type will trigger. If you want a workflow to run when stable and pre-releases publish, subscribe to published instead of released and prereleased . Runs your workflow when release activity in your repository occurs. For information about the release APIs, see Objects in the GraphQL API documentation or REST API endpoints for releases and release assets in the REST API documentation. For example, you can run a workflow when a release has been published .","on:
  release:
    types: [published]","on:
  release:
    types: [published]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Release published!""
",0
1088,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - repository_dispatch,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. You can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see REST API endpoints for repositories . When you make a request to create a repository_dispatch event, you must specify an event_type to describe the activity type. By default, all repository_dispatch activity types trigger a workflow to run. You can use the types keyword to limit your workflow to run when a specific event_type value is sent in the repository_dispatch webhook payload.","on:
  repository_dispatch:
    types: [test_result]","on:
  repository_dispatch:
    types:
      - your_event_type

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1089,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - repository_dispatch,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. You can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see REST API endpoints for repositories . When you make a request to create a repository_dispatch event, you must specify an event_type to describe the activity type. By default, all repository_dispatch activity types trigger a workflow to run. You can use the types keyword to limit your workflow to run when a specific event_type value is sent in the repository_dispatch webhook payload. Note  Theevent_typevalue is limited to 100 characters. The event_type value is limited to 100 characters. Any data that you send through the client_payload parameter will be available in the github.event context in your workflow. For example, if you send this request body when you create a repository dispatch event: then you can access the payload in a workflow like this:","on:
  repository_dispatch:
    types: [test_result]

jobs:
  run_if_failure:
    if: ${{ !github.event.client_payload.passed }}
    runs-on: ubuntu-latest
    steps:
      - env:
          MESSAGE: ${{ github.event.client_payload.message }}
        run: echo $MESSAGE","on:
  repository_dispatch:
    types: [your_event_type]

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Access client payload
        run: echo ""${{ toJson(github.event.client_payload) }}""
",0
1090,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - schedule,"Note    Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.This event will only trigger a workflow run if the workflow file is on the default branch.Scheduled workflows will only run on the default branch.In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example: Note The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. This event will only trigger a workflow run if the workflow file is on the default branch. Scheduled workflows will only run on the default branch. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow . For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor . Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located. Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows. For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change. Example:","on:
  schedule:
    - cron: ""15 4,5 * * *""   # <=== Change this value","on:
  schedule:
    - cron: '15 3 * * *'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
1091,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - schedule,"Note    Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.This event will only trigger a workflow run if the workflow file is on the default branch.Scheduled workflows will only run on the default branch.In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example: Note The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. This event will only trigger a workflow run if the workflow file is on the default branch. Scheduled workflows will only run on the default branch. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow . For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor . Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located. Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows. For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change. Example: The schedule event allows you to trigger a workflow at a scheduled time. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC:","on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'","on:
  schedule:
    - cron: '30 5,17 * * *'
",0
1092,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - schedule,"Note    Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.This event will only trigger a workflow run if the workflow file is on the default branch.Scheduled workflows will only run on the default branch.In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example: Note The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. This event will only trigger a workflow run if the workflow file is on the default branch. Scheduled workflows will only run on the default branch. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow . For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor . Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located. Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows. For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change. Example: The schedule event allows you to trigger a workflow at a scheduled time. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC: A single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.","on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo ""This step will be skipped on Monday and Wednesday""
      - name: Every time
        run: echo ""This step will always run""","on:
  schedule:
    - cron: '30 5,17 * * *'

jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Check day
        id: check_day
        run: echo ""day=$(date +'%u')"" >> $GITHUB_ENV

      - name: Not on Monday or Wednesday
        if: ${{ env.day != '1' && env.day != '3' }}
        run: echo ""This step runs on days other than Monday and Wednesday""
",0
1093,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - status,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when the status of a Git commit changes. For example, commits can be marked as error , failure , pending , or success . If you want to provide more details about the status change, you may want to use the check_run event. For information about the commit status APIs, see Objects in the GraphQL API documentation or REST API endpoints for commits . For example, you can run a workflow when the status event occurs.","on:
  status","on:
  status

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1094,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - status,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when the status of a Git commit changes. For example, commits can be marked as error , failure , pending , or success . If you want to provide more details about the status change, you may want to use the check_run event. For information about the commit status APIs, see Objects in the GraphQL API documentation or REST API endpoints for commits . For example, you can run a workflow when the status event occurs. If you want to run a job in your workflow based on the new commit state, you can use the github.event.state context. For example, the following workflow triggers when a commit status changes, but the if_error_or_failure job only runs if the new commit state is error or failure .","on:
  status
jobs:
  if_error_or_failure:
    runs-on: ubuntu-latest
    if: >-
      github.event.state == 'error' ||
      github.event.state == 'failure'
    steps:
      - env:
          DESCRIPTION: ${{ github.event.description }}
        run: |
          echo The status is error or failed: $DESCRIPTION","on:
  status

jobs:
  if_error_or_failure:
    runs-on: ubuntu-latest
    if: github.event.state == 'error' || github.event.state == 'failure'
    steps:
      - run: echo ""Commit status is error or failure""
",0
1095,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - watch,"Note  More than one activity type triggers this event. Although only thestartedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. Although only the started activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when the workflow's repository is starred. For information about the pull request APIs, see Mutations in the GraphQL API documentation or REST API endpoints for starring . For example, you can run a workflow when someone stars a repository, which is the started activity type for a watch event.","on:
  watch:
    types: [started]","on:
  watch:
    types: [started]
jobs:
  run-on-star:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Print message
        run: echo ""Repository starred!""
",0
1096,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_call,"workflow_call is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the workflow_call event, the event payload in the called workflow is the same event payload from the calling workflow. For more information see, Reusing workflows . The example below only runs the workflow when it's called from another workflow:",on: workflow_call,"on:
  workflow_call:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1097,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_dispatch,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see Manually running a workflow .",on: workflow_dispatch,"on:
  workflow_dispatch:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1098,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_dispatch - Providing inputs,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see Manually running a workflow . You can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the ref and any inputs . When the workflow runs, you can access the input values in the inputs context. For more information, see Accessing contextual information about workflow runs . Note    The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.The maximum number of top-level properties forinputsis 10.The maximum payload forinputsis 65,535 characters. This example defines inputs called logLevel , tags , and environment . You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using the inputs.logLevel , inputs.tags , and inputs.environment context properties.","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug
      tags:
        description: 'Test scenario tags'
        required: false
        type: boolean
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  log-the-inputs:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo ""Log level: $LEVEL""
          echo ""Tags: $TAGS""
          echo ""Environment: $ENVIRONMENT""
        env:
          LEVEL: ${{ inputs.logLevel }}
          TAGS: ${{ inputs.tags }}
          ENVIRONMENT: ${{ inputs.environment }}","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'info'
      tags:
        description: 'Tags'
        required: false
      environment:
        description: 'Environment'
        required: true
        default: 'production'

jobs:
  print-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Print inputs
        run: |
          echo ""Log Level: ${{ inputs.logLevel }}""
          echo ""Tags: ${{ inputs.tags }}""
          echo ""Environment: ${{ inputs.environment }}""
",0
1099,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_run,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes.","on:
  workflow_run:
    workflows: [Run Tests]
    types:
      - completed","on:
  workflow_run:
    workflows: [""Run Tests""]
    types:
      - completed

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1100,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_run,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes.","on:
  workflow_run:
    workflows: [Staging, Lab]
    types:
      - completed","on:
  workflow_run:
    workflows: [""Run Tests""]
    types:
      - completed
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1101,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Running a workflow based on the conclusion of another workflow,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. A workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with the github.event.workflow_run.conclusion property. For example, this workflow will run whenever a workflow named ""Build"" completes, but the on-success job will only run if the ""Build"" workflow succeeded, and the on-failure job will only run if the ""Build"" workflow failed:","on:
  workflow_run:
    workflows: [Build]
    types: [completed]

jobs:
  on-success:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - run: echo 'The triggering workflow passed'
  on-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - run: echo 'The triggering workflow failed'","on:
  workflow_run:
    workflows: [""Build""]
    types:
      - completed

jobs:
  on-success:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Build succeeded!""

  on-failure:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Build failed!""
",0
1102,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Limiting your workflow to run based on branches,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. You can use the branches or branches-ignore filter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, see Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch named canary .","on:
  workflow_run:
    workflows: [Build]
    types: [requested]
    branches: [canary]","on:
  workflow_run:
    workflows: [""Run Tests""]
    types: [completed]
    branches: [canary]
",0
1103,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Using data from the triggering workflow,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. You can access the workflow_run event payload that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the workflow_run event can access these artifacts. The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)","name: Upload data

on:
  pull_request:

jobs:
  upload:
    runs-on: ubuntu-latest

    steps:
      - name: Save PR number
        env:
          PR_NUMBER: ${{ github.event.number }}
        run: |
          mkdir -p ./pr
          echo $PR_NUMBER > ./pr/pr_number
      - uses: actions/upload-artifact@v4
        with:
          name: pr_number
          path: pr/","workflow_run:
  workflows: [""Run Tests""]
  types: [completed]

jobs:
  upload-artifact:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Upload pull request number
        run: echo ${{ github.event.pull_request.number }} > pr_number.txt
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: pull-request-number
          path: pr_number.txt
",0
1104,https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Using data from the triggering workflow,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. You can access the workflow_run event payload that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the workflow_run event can access these artifacts. The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.) When a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses the github.event.workflow_run context and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact.","name: Use the data

on:
  workflow_run:
    workflows: [Upload data]
    types:
      - completed

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: 'Download artifact'
        uses: actions/github-script@v7
        with:
          script: |
            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: context.payload.workflow_run.id,
            });
            let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => {
              return artifact.name == ""pr_number""
            })[0];
            let download = await github.rest.actions.downloadArtifact({
               owner: context.repo.owner,
               repo: context.repo.repo,
               artifact_id: matchArtifact.id,
               archive_format: 'zip',
            });
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            if (!fs.existsSync(temp)){
              fs.mkdirSync(temp);
            }
            fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data));

      - name: 'Unzip artifact'
        run: unzip pr_number.zip -d ""${{ runner.temp }}/artifacts""

      - name: 'Comment on PR'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number')));
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: 'Thank you for the PR!'
            });","on:
  workflow_run:
    workflows: [""Run Tests""]
    types:
      - completed

jobs:
  download-artifact:
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: pull-request-number

      - name: Unzip artifact
        run: unzip pull-request-number.zip

      - name: Comment on PR
        uses: actions/github-script@v6
        with:
          script: |
            const prNumber = require('fs').readFileSync('pull-request-number', 'utf8').trim();
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: 'This is a comment from the workflow_run triggered workflow.'
            });
",0
1105,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=windows,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run a one-line script
      run: echo ""Hello, world!""
",0
1106,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=windows,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run hello world action
        uses: OWNER/REPO@SHA
        with:
          who-to-greet: 'Your Name'
",0
1107,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=windows,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - run: echo ""Goodbye, World!""
      shell: bash
      working-directory: ${{ github.action_path }}
",0
1108,https://docs.github.com/en/actions/using-github-hosted-runners/customizing-github-hosted-runners,Customizing GitHub-hosted runners - Installing software on Ubuntu runners,The following example demonstrates how to install an apt package as part of a job.,"name: Build on Ubuntu
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install jq tool
        run: |
          sudo apt-get update
          sudo apt-get install jq","jobs:
  install-package:
    runs-on: ubuntu-latest
    steps:
      - name: Install package
        run: sudo apt-get update && sudo apt-get install -y <package-name>
",0
1109,https://docs.github.com/en/actions/using-github-hosted-runners/customizing-github-hosted-runners,Customizing GitHub-hosted runners - Installing software on macOS runners,The following example demonstrates how to install Brew packages and casks as part of a job.,"name: Build on macOS
on: push

jobs:
  build:
    runs-on: macos-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install GitHub CLI
        run: |
          brew update
          brew install gh
      - name: Install Microsoft Edge
        run: |
          brew update
          brew install --cask microsoft-edge","jobs:
  install_software:
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Install Brew packages
        run: |
          brew update
          brew install wget
          brew install --cask google-chrome
",0
1110,https://docs.github.com/en/actions/using-github-hosted-runners/customizing-github-hosted-runners,Customizing GitHub-hosted runners - Installing software on Windows runners,The following example demonstrates how to use Chocolatey to install the GitHub CLI as part of a job.,"name: Build on Windows
on: push
jobs:
  build:
    runs-on: windows-latest
    steps:
      - run: choco install gh
      - run: gh version","jobs:
  install-gh-cli:
    runs-on: windows-latest
    steps:
      - name: Install Chocolatey
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force; `
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; `
          iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
      - name: Install GitHub CLI
        run: choco install gh -y
",0
1111,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Creating an example workflow,"GitHub Actions uses YAML syntax to define the workflow. Each workflow is stored as a separate YAML file in your code repository, in a directory named .github/workflows . You can create an example workflow in your repository that automatically triggers a series of commands whenever code is pushed. In this workflow, GitHub Actions checks out the pushed code, installs the bats testing framework, and runs a basic command to output the bats version: bats -v . In your repository, create the .github/workflows/ directory to store your workflow files. In the .github/workflows/ directory, create a new file called learn-github-actions.yml and add the following code.","name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v","name: Example Workflow
on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Install Bats
        run: |
          sudo apt-get update
          sudo apt-get install -y bats
      - name: Check Bats version
        run: bats -v
",0
1112,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.",name: learn-github-actions,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1113,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE.",run-name: ${{ github.actor }} is learning GitHub Actions,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1114,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE.",on: [push],"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1115,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in thelearn-github-actionsworkflow.",jobs:,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1116,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job.",check-bats-version:,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1117,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE",runs-on: ubuntu-latest,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1118,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script.",steps:,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1119,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE Groups together all the steps that run in the check-bats-version job. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.",- uses: actions/checkout@v4,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1120,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE Groups together all the steps that run in the check-bats-version job. Each item nested under this section is a separate action or shell script. The uses keyword specifies that this step will run v4 of the actions/checkout action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH.","- uses: actions/setup-node@v4
        with:
          node-version: '20'","name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1121,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE Groups together all the steps that run in the check-bats-version job. Each item nested under this section is a separate action or shell script. The uses keyword specifies that this step will run v4 of the actions/checkout action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses the actions/setup-node@v4 action to install the specified version of the Node.js. (This example uses version 20.) This puts both the node and npm commands in your PATH . Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package.",#NAME?,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1122,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE Groups together all the steps that run in the check-bats-version job. Each item nested under this section is a separate action or shell script. The uses keyword specifies that this step will run v4 of the actions/checkout action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses the actions/setup-node@v4 action to install the specified version of the Node.js. (This example uses version 20.) This puts both the node and npm commands in your PATH . The run keyword tells the job to execute a command on the runner. In this case, you are using npm to install the bats software testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version.",#NAME?,"name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1123,https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow,Creating an example workflow - Understanding the workflow file,"To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example: BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. BesideInline# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v Beside Inline Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE. Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE. Groups together all the jobs that run in thelearn-github-actionsworkflow. Defines a job namedcheck-bats-version. The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script. Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH. Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package. Finally, you'll run thebatscommand with a parameter that outputs the software version. Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead. Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the github context to display the username of the actor that triggered the workflow run. For more information, see AUTOTITLE . Specifies the trigger for this workflow. This example uses the push event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see AUTOTITLE . Groups together all the jobs that run in the learn-github-actions workflow. Defines a job named check-bats-version . The child keys will define properties of the job. Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see AUTOTITLE Groups together all the steps that run in the check-bats-version job. Each item nested under this section is a separate action or shell script. The uses keyword specifies that this step will run v4 of the actions/checkout action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code. This step uses the actions/setup-node@v4 action to install the specified version of the Node.js. (This example uses version 20.) This puts both the node and npm commands in your PATH . The run keyword tells the job to execute a command on the runner. In this case, you are using npm to install the bats software testing package. Finally, you'll run the bats command with a parameter that outputs the software version.","# Optional - The name of the workflow as it will appear in the ""Actions"" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.
name: learn-github-actions

# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's ""Actions"" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).
run-name: ${{ github.actor }} is learning GitHub Actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow.
jobs:

# Defines a job named `check-bats-version`. The child keys will define properties of the job.
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v","name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g bats
      - run: bats -v
",0
1124,https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication,Automatic token authentication - Using the GITHUB_TOKEN in a workflow - Example 1: passing the GITHUB_TOKEN as an input,"You can use the GITHUB_TOKEN by using the standard syntax for referencing secrets: ${{ secrets.GITHUB_TOKEN }} . Examples of using the GITHUB_TOKEN include passing the token as an input to an action, or using it to make an authenticated GitHub API request. Important  An action can access theGITHUB_TOKENthrough thegithub.tokencontext even if the workflow does not explicitly pass theGITHUB_TOKENto the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to theGITHUB_TOKEN. For more information, seePermissions for theGITHUB_TOKEN. Important An action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN . For more information, see Permissions for the GITHUB_TOKEN . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. Commits pushed by a GitHub Actions workflow that uses the GITHUB_TOKEN do not trigger a GitHub Pages build. This example workflow uses the GitHub CLI , which requires the GITHUB_TOKEN as the value for the GH_TOKEN input parameter:","name: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title ""Issue title"" --body ""Issue body""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Use GitHub CLI
        uses: actions/github-script@v6
        with:
          script: |
            const { exec } = require('@actions/exec');
            exec('gh auth login --with-token', { input: process.env.GITHUB_TOKEN });
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
",0
1125,https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication,Automatic token authentication - Using the GITHUB_TOKEN in a workflow - Example 2: calling the REST API,"You can use the GITHUB_TOKEN by using the standard syntax for referencing secrets: ${{ secrets.GITHUB_TOKEN }} . Examples of using the GITHUB_TOKEN include passing the token as an input to an action, or using it to make an authenticated GitHub API request. Important  An action can access theGITHUB_TOKENthrough thegithub.tokencontext even if the workflow does not explicitly pass theGITHUB_TOKENto the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to theGITHUB_TOKEN. For more information, seePermissions for theGITHUB_TOKEN. Important An action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN . For more information, see Permissions for the GITHUB_TOKEN . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. Commits pushed by a GitHub Actions workflow that uses the GITHUB_TOKEN do not trigger a GitHub Pages build. You can use the GITHUB_TOKEN to make authenticated API calls. This example workflow creates an issue using the GitHub REST API:","name: Create issue on commit

on: [ push ]

jobs:
  create_issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Create issue using REST API
        run: |
          curl --request POST \
          --url https://api.github.com/repos/${{ github.repository }}/issues \
          --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \
          --header 'content-type: application/json' \
          --data '{
            ""title"": ""Automated issue for commit: ${{ github.sha }}"",
            ""body"": ""This issue was automatically created by the GitHub Action workflow **${{ github.workflow }}**. \n\n The commit hash was: _${{ github.sha }}_.""
            }' \
          --fail","jobs:
  create_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub issue
        run: |
          curl -X POST \
          -H ""Authorization: token ${{ secrets.GITHUB_TOKEN }}"" \
          -H ""Accept: application/vnd.github.v3+json"" \
          https://api.github.com/repos/${{ github.repository }}/issues \
          -d '{""title"":""Automated Issue"",""body"":""This issue was created by a GitHub Actions workflow.""}'
",0
1126,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners,Running jobs on larger runners - Using groups to control where jobs are run,"In this example, Ubuntu runners have been added to a group called ubuntu-runners . The runs-on key sends the job to any available runner in the ubuntu-runners group:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: ubuntu-runners
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, world!""
",0
1127,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners,Running jobs on larger runners - Using labels to control where jobs are run,"You can implicitly pass a label to the runs-on key by using the syntax runs-on: LABEL . Alternatively, you can use the labels key, as shown in the example below. In this example, the runs-on key sends the job to any available runner that has been assigned the ubuntu-20.04-16core label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example_job:
    runs-on: ubuntu-20.04-16core
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on a larger runner""
",0
1128,https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners,Running jobs on larger runners - Using labels and groups to control where jobs are run,"When you combine groups and labels, the runner must meet both requirements to be eligible to run the job. In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core . The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:","name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v","jobs:
  example-job:
    runs-on: [ubuntu-runners, ubuntu-20.04-16core]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1129,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=mac,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - run: echo ""Hello, World!""
",0
1130,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=mac,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run hello world action
        uses: OWNER/REPO@SHA
        with:
          who-to-greet: 'Your Name'
",0
1131,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?platform=mac,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - name: Say Goodbye
      run: ./goodbye.sh
",0
1132,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure,Configuring OpenID Connect in Azure - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
",0
1133,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure,Configuring OpenID Connect in Azure - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write
",0
1134,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure,Configuring OpenID Connect in Azure - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . The azure/login action receives a JWT from the GitHub OIDC provider, and then requests an access token from Azure. For more information, see the azure/login documentation. The following example exchanges an OIDC ID token with Azure to receive an access token, which can then be used to access cloud resources.","name: Run Azure Login with OIDC
on: [push]

permissions:
  id-token: write
  contents: read
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 'Az CLI login'
        uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: 'Run az commands'
        run: |
          az account show
          az group list","jobs:
  oidc:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Login to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          federated-credential: ${{ secrets.AZURE_FEDERATED_CREDENTIAL }}
",0
1135,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Using a matrix strategy,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] :","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
1136,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a single-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify a single variable to create a single-dimension matrix. For example, the following workflow defines the variable version with the values [10, 12, 14] . The workflow will run three jobs, one for each value in the variable. Each job will access the version value through the matrix.version context and pass the value as node-version to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
1137,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
1138,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s.","matrix:
  os:
    - ubuntu-latest
    - macos-latest
  node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
1139,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using a multi-dimension matrix,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables. For example, the following workflow specifies two variables: The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action. A variable configuration in a matrix can be an array of object s. This matrix produces 4 jobs with corresponding contexts.","- matrix.os: ubuntu-latest
  matrix.node.version: 14
- matrix.os: ubuntu-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
  matrix.node.version: 14
- matrix.os: macos-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - run: node -v
",0
1140,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Using a matrix strategy - Example: Using contexts to create matrices,"Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest] : A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order: A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners. The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs . You can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs . For example, the following workflow triggers on the repository_dispatch event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix version variable will have a value of [12, 14, 16] . For more information about the repository_dispatch trigger, see Events that trigger workflows .","on:
  repository_dispatch:
    types:
      - test
 
jobs:
  example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}","jobs:
  build:
    strategy:
      matrix:
        version: [12, 14, 16]
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js ${{ matrix.version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
1141,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Expanding or adding matrix configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix:","strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [12, 14]
        include:
          - os: ubuntu-latest
            node: 16
            custom: true
          - os: windows-latest
            node: 16
            custom: true
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Run build
        run: npm run build
",0
1142,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Expanding or adding matrix configurations - Example: Expanding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, the following workflow will run four jobs, one for each combination of os and node . When the job for the os value of windows-latest and node value of 16 runs, an additional variable called npm with the value of 6 will be included in the job.","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
1143,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Expanding or adding matrix configurations - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 .","jobs:
  example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [14, 16]
        include:
          - os: windows-latest
            version: 17
    steps:
      - run: echo ""Building on ${{ matrix.os }} with version ${{ matrix.version }}""
",0
1144,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Expanding or adding matrix configurations - Example: Adding configurations,"Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects. For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten. For example, this matrix: will result in six jobs with the following matrix combinations: following this logic: For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17 . If you don't specify any matrix variables, all configurations under include will run. For example, the following workflow would run two jobs, one for each include entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.","jobs:
  includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: ""production""
            datacenter: ""site-a""
          - site: ""staging""
            datacenter: ""site-b""","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        version: [16, 18]
        include:
          - os: windows-latest
            version: 17
          - os: ubuntu-latest
            version: 20
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.version }}
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
",0
1145,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Excluding matrix configurations,"To remove specific configurations defined in the matrix, use jobs.<job_id>.strategy.matrix.exclude . An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches {os: macos-latest, version: 12, environment: production} , and the two excluded jobs that match {os: windows-latest, version: 16} .","strategy:
  matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}","jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        version: [12, 14, 16]
        environment: [development, staging, production]
        exclude:
          - os: macos-latest
            version: 12
            environment: production
          - os: windows-latest
            version: 16
    steps:
      - run: echo ""Running on ${{ matrix.os }} with version ${{ matrix.version }} in ${{ matrix.environment }} environment""
",0
1146,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Example: Using an output to define two matrices,"You can use the output from one job to define matrices for multiple jobs. For example, the following workflow demonstrates how to define a matrix of values in one job, use that matrix in a second jobs to produce artifacts, and then consume those artifacts in a third job. Each artifact is associated with a value from the matrix.","name: shared matrix
on:
  push:
  workflow_dispatch:

jobs:
  define-matrix:
    runs-on: ubuntu-latest

    outputs:
      colors: ${{ steps.colors.outputs.colors }}

    steps:
      - name: Define Colors
        id: colors
        run: |
          echo 'colors=[""red"", ""green"", ""blue""]' >> ""$GITHUB_OUTPUT""

  produce-artifacts:
    runs-on: ubuntu-latest
    needs: define-matrix
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
      - name: Define Color
        env:
          color: ${{ matrix.color }}
        run: |
          echo ""$color"" > color
      - name: Produce Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.color }}
          path: color

  consume-artifacts:
    runs-on: ubuntu-latest
    needs:
    - define-matrix
    - produce-artifacts
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
    - name: Retrieve Artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.color }}

    - name: Report Color
      run: |
        cat color","jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo ""::set-output name=matrix::{\""include\"":[{\""value\"":\""a\""},{\""value\"":\""b\""}]}""

  produce-artifacts:
    needs: set-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.set-matrix.outputs.matrix) }}
    steps:
      - run: echo ""Producing artifact for value: ${{ matrix.value }}""
      - run: echo ""artifact-${{ matrix.value }}"" > artifact.txt
      - uses: actions/upload-artifact@v3
        with:
          name: artifact-${{ matrix.value }}
          path: artifact.txt

  consume-artifacts:
    needs: produce-artifacts
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.set-matrix.outputs.matrix) }}
    steps:
      - uses: actions/download-artifact@v3
        with:
          name: artifact-${{ matrix.value }}
      - run: cat artifact.txt
",0
1147,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Handling failures,"You can control how job failures are handled with jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error . jobs.<job_id>.strategy.fail-fast applies to the entire matrix. If jobs.<job_id>.strategy.fail-fast is set to true or its expression evaluates to true , GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to true . jobs.<job_id>.continue-on-error applies to a single job. If jobs.<job_id>.continue-on-error is true , other jobs in the matrix will continue running even if the job with jobs.<job_id>.continue-on-error: true fails. You can use jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error together. For example, the following workflow will start four jobs. For each job, continue-on-error is determined by the value of matrix.experimental . If any of the jobs with continue-on-error: false fail, all jobs that are in progress or queued will be cancelled. If the job with continue-on-error: true fails, the other jobs will not be affected.","jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true","jobs:
  build:
    strategy:
      matrix:
        experimental: [true, false]
      fail-fast: true
    continue-on-error: ${{ matrix.experimental }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Running job with experimental=${{ matrix.experimental }}""
",0
1148,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow,Running variations of jobs in a workflow - Defining the maximum number of concurrent jobs,"By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a matrix job strategy, use jobs.<job_id>.strategy.max-parallel . For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.","jobs:
  example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]","jobs:
  example-job:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 2
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node: [12, 14]
    steps:
      - name: Check out code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - name: Run script
        run: node -v
",0
1149,https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions .","steps:
  - name: Hello world action
    with: # Set the secret as an input
      super_secret: ${{ secrets.SuperSecret }}
    env: # Or as an environment variable
      super_secret: ${{ secrets.SuperSecret }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Use secret as environment variable
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}
        run: echo ""Using secret in the workflow""

      - name: Authenticate with cloud provider
        uses: some-cloud-provider/auth-action@v1
        with:
          oidc-token: ${{ steps.auth.outputs.oidc-token }}
",0
1150,https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Bash,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: bash
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$SUPER_SECRET""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret in Bash
        env:
          SUPER_SECRET: ${{ secrets.SuperSecret }}
        run: echo ""$SUPER_SECRET""
",0
1151,https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow - Example using PowerShell,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: pwsh
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""$env:SUPER_SECRET""","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret in PowerShell
        shell: pwsh
        env:
          SUPER_SECRET: ${{ secrets.SuperSecret }}
        run: |
          Write-Host ""The secret is $env:SUPER_SECRET""
",0
1152,https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Using secrets in a workflow - Example using Cmd.exe,"Note    With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. Note To provide an action with a secret as an input or environment variable, you can use the secrets context to access secrets you've created in your repository. For more information, see Accessing contextual information about workflow runs and Workflow syntax for GitHub Actions . Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, see Accessing contextual information about workflow runs and jobs.<job_id>.steps[*].if . If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string. Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using the ps command) or captured by security audit events . To help protect secrets, consider using environment variables, STDIN , or other mechanisms supported by the target process. If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:","steps:
  - shell: cmd
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    run: |
      example-command ""%SUPER_SECRET%""","jobs:
  example:
    runs-on: windows-latest
    env:
      SUPER_SECRET: ${{ secrets.SuperSecret }}
    steps:
      - name: Run command
        run: |
          echo %SUPER_SECRET%
        shell: cmd
",0
1153,https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Limits for secrets - Storing large secrets,"You can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets. A workflow created in a repository can access the following number of secrets: Secrets are limited to 48 KB in size. To store larger secrets, see the Storing large secrets workaround below. To use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can use gpg to encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see the gpg manpage . Warning  Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Warning Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs. Run the following command from your terminal to encrypt the file containing your secret using gpg and the AES256 cipher algorithm. In this example, my_secret.json is the file containing the secret. You will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value. Create a new secret that contains the passphrase. For example, create a new secret with the name LARGE_SECRET_PASSPHRASE and set the value of the secret to the passphrase you used in the step above. Copy your encrypted file to a path in your repository and commit it. In this example, the encrypted file is my_secret.json.gpg . Warning  Make sure to copy the encryptedmy_secret.json.gpgfile ending with the.gpgfile extension, andnotthe unencryptedmy_secret.jsonfile. Make sure to copy the encrypted my_secret.json.gpg file ending with the .gpg file extension, and not the unencrypted my_secret.json file. Create a shell script in your repository to decrypt the secret file. In this example, the script is named decrypt_secret.sh . Ensure your shell script is executable before checking it in to your repository. In your GitHub Actions workflow, use a step to call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use the actions/checkout action. Reference your shell script using the run command relative to the root of your repository.","name: Workflows with large secrets

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Decrypt large secret
        run: ./decrypt_secret.sh
        env:
          LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
      # This command is just an example to show your secret being printed
      # Ensure you remove any print statements of your secrets. GitHub does
      # not hide secrets that use this workaround.
      - name: Test printing your secret (Remove this step in production)
        run: cat $HOME/secrets/my_secret.json","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Decrypt secret
      run: |
        gpg --quiet --batch --yes --decrypt --passphrase=""$LARGE_SECRET_PASSPHRASE"" \
        --output my_secret.json my_secret.json.gpg
      env:
        LARGE_SECRET_PASSPHRASE: ${{ secrets.LARGE_SECRET_PASSPHRASE }}
",0
1154,https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions,Using secrets in GitHub Actions - Storing Base64 binary blobs as secrets,"You can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, see Using secrets in GitHub Actions . Note  Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Note Note that Base64 only converts binary to text, and is not a substitute for actual encryption. Use base64 to encode your file into a Base64 string. For example: On macOS, you could run: On Linux, you could run: Create a secret that contains the Base64 string. For example: To access the Base64 string from your runner, pipe the secret to base64 --decode . For example:","name: Retrieve Base64 secret
on:
  push:
    branches: [ octo-branch ]
jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Retrieve the secret and decode it to a file
        env:
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
        run: |
          echo $CERTIFICATE_BASE64 | base64 --decode > cert.der
      - name: Show certificate information
        run: |
          openssl x509 -in cert.der -inform DER -text -noout","jobs:
  decode-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Decode Base64 secret
        run: echo ${{ secrets.BASE64_SECRET }} | base64 --decode > decoded_file
",0
1155,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app,Deploying to Azure Static Web App - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy an Azure static web app when there is a push to the main branch or when a pull request targeting main is opened, synchronized, or reopened. The workflow also tears down the corresponding pre-production deployment when a pull request targeting main is closed. Under the workflow env key, change the following values: For more information about these values, see Build configuration for Azure Static Web Apps in the Azure documentation.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Deploy web app to Azure Static Web Apps

env:
  APP_LOCATION: ""/"" # location of your client code
  API_LOCATION: ""api"" # location of your api source code - optional
  OUTPUT_LOCATION: ""build"" # location of client code build output

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main

permissions:
  issues: write
  contents: read
  pull-requests: write

jobs:
  build_and_deploy:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')
    runs-on: ubuntu-latest
    name: Build and Deploy
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build And Deploy
        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: ""upload""
          app_location: ${{ env.APP_LOCATION }}
          api_location: ${{ env.API_LOCATION }}
          output_location: ${{ env.OUTPUT_LOCATION }}

  close_pull_request:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    name: Close Pull Request
    steps:
      - name: Close Pull Request
        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          action: ""close""","name: Azure Static Web Apps CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, closed]

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build and Deploy
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: ${{ github.event_name == 'pull_request' && github.event.action == 'closed' && 'close' || 'upload' }}
          branch: ${{ github.ref }}
          pr: ${{ github.event.pull_request.number || '' }}
",0
1156,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers,About service containers - Creating service containers,"You can use the services keyword to create service containers that are part of a job in your workflow. For more information, see jobs.<job_id>.services . This example creates a service called redis in a job called container-job . The Docker host in this example is the node:16-bullseye container.","name: Redis container example
on: push

jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:16-bullseye

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis","jobs:
  container-job:
    runs-on: ubuntu-latest
    container:
      image: node:16-bullseye
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
",0
1157,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers,About service containers - Mapping Docker host and service container ports - Example mapping Redis ports,"If your job runs in a Docker container, you do not need to map ports on the host or the service container. If your job runs directly on the runner machine, you'll need to map any required service container ports to ports on the host runner machine. You can map service containers ports to the Docker host using the ports keyword. For more information, see jobs.<job_id>.services . When you map ports using the ports keyword, GitHub uses the --publish command to publish the containers ports to the Docker host. For more information, see Docker container networking in the Docker documentation. When you specify the container port but not the Docker host port, the container port is randomly assigned to a free port. GitHub sets the assigned container port in the service container context. For example, for a redis service container, if you configured the Docker host port 5432, you can access the corresponding container port using the job.services.redis.ports[5432] context. For more information, see Accessing contextual information about workflow runs . This example maps the service container redis port 6379 to the Docker host port 6379.","name: Redis Service Example
on: push

jobs:
  # Label of the container job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        #
        ports:
          # Opens tcp port 6379 on the host and service container
          - 6379:6379","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
",0
1158,https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers,About service containers - Authenticating with image registries,You can specify credentials for your service containers in case you need to authenticate with an image registry. This allows you to use images from private registries or to increase your DockerHub rate limit . Heres an example of authenticating with Docker Hub and the GitHub Container registry:,"jobs:
  build:
    services:
      redis:
        # Docker Hub image
        image: redis
        ports:
          - 6379:6379
        credentials:
          username: ${{ secrets.dockerhub_username }}
          password: ${{ secrets.dockerhub_password }}
      db:
        # Private registry image
        image: ghcr.io/octocat/testdb:latest
        credentials:
          username: ${{ github.repository_owner }}
          password: ${{ secrets.ghcr_password }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    services:
      my-service:
        image: my-private-registry/my-image:latest
        credentials:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      another-service:
        image: ghcr.io/my-org/my-image:latest
        credentials:
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
",0
1159,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven,Building and testing Java with Maven - Using a Maven workflow template - Specifying the Java version and architecture,"To get started quickly, add a workflow template to the .github/workflows directory of your repository. GitHub provides a workflow template for Maven that should work for most Java with Maven projects. The subsequent sections of this guide give examples of how you can customize this workflow template. On GitHub, navigate to the main page of the repository. Under your repository name, click Actions . If you already have a workflow in your repository, click New workflow . The ""Choose a workflow"" page shows a selection of recommended workflow templates. Search for ""Java with Maven"". On the ""Java with Maven"" workflow, click Configure . Edit the workflow as required. For example, change the Java version. Click Commit changes . The maven.yml workflow file is added to the .github/workflows directory of your repository. The workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( x64 or x86 ), you can use the setup-java action to choose a different Java runtime environment. For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version , distribution and architecture parameters to '11' , 'temurin' and x64 .","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 11 for x64
    uses: actions/setup-java@v4
    with:
      java-version: '11'
      distribution: 'temurin'
      architecture: x64","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        architecture: 'x64'
    - name: Build with Maven
      run: mvn -B package --file pom.xml
",0
1160,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven,Building and testing Java with Maven - Building and testing your code,"You can use the same commands that you use locally to build and test your code. The workflow template will run the package target by default. In the default Maven configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file. If you use different commands to build your project, or you want to use a different target, you can specify those. For example, you may want to run the verify target that's configured in a pom-ci.xml file.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
  - name: Run the Maven verify phase
    run: mvn --batch-mode --update-snapshots verify","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
    - name: Build with Maven
      run: mvn -f pom-ci.xml verify
",0
1161,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven,Building and testing Java with Maven - Caching dependencies,"You can cache your dependencies to speed up your workflow runs. After a successful run, your local Maven repository will be stored in a cache. In future workflow runs, the cache will be restored so that dependencies don't need to be downloaded from remote Maven repositories. You can cache dependencies simply using the setup-java action or can use cache action for custom and more advanced configuration.","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 17
    uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
      cache: maven
  - name: Build with Maven
    run: mvn --batch-mode --update-snapshots verify","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          cache: maven
      - name: Build with Maven
        run: mvn clean install
",0
1162,https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven,Building and testing Java with Maven - Packaging workflow data as artifacts,"After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow . Maven will usually create output files like JARs, EARs, or WARs in the target directory. To upload those as artifacts, you can copy them into a new directory that contains artifacts to upload. For example, you can create a directory called staging . Then you can upload the contents of that directory using the upload-artifact action.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'
  - run: mvn --batch-mode --update-snapshots verify
  - run: mkdir staging && cp target/*.jar staging
  - uses: actions/upload-artifact@v4
    with:
      name: Package
      path: staging","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
    - name: Build with Maven
      run: mvn clean package
    - name: Prepare artifacts
      run: mkdir -p staging && cp target/*.jar staging/
    - name: Upload artifacts
      uses: actions/upload-artifact@v2
      with:
        name: java-packages
        path: staging/
",0
1163,https://docs.github.com/en/actions/use-cases-and-examples/project-management/adding-labels-to-issues,Adding labels to issues - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Label issues
on:
  issues:
    types:
      - reopened
      - opened
jobs:
  label_issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - run: gh issue edit ""$NUMBER"" --add-label ""$LABELS""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          NUMBER: ${{ github.event.issue.number }}
          LABELS: triage","on:
  issues:
    types: [opened]

jobs:
  add_labels:
    runs-on: ubuntu-latest
    steps:
      - name: Add labels to issue
        uses: actions-ecosystem/action-add-labels@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          labels: 'bug, help wanted'
",0
1164,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api,Authenticating to the GitHub API - Authenticating ARC with a GitHub App,"Create a GitHub App that is owned by an organization. For more information, see Registering a GitHub App . Configure the GitHub App as follows. For ""Homepage URL,"" enter https://github.com/actions/actions-runner-controller . Under ""Permissions,"" click Repository permissions . Then use the dropdown menus to select the following access permissions. Administration: Read and write Note  Administration: Read and writeis only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope. Note Administration: Read and write is only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope. Metadata: Read-only Under ""Permissions,"" click Organization permissions . Then use the dropdown menus to select the following access permissions. After creating the GitHub App, on the GitHub App's page, note the value for ""App ID"". You will use this value later. Under ""Private keys"", click Generate a private key , and save the .pem file. You will use this key later. In the menu at the top-left corner of the page, click Install app , and next to your organization, click Install to install the app on your organization. After confirming the installation permissions on your organization, note the app installation ID. You will use it later. You can find the app installation ID on the app installation page, which has the following URL format: https://github.com/organizations/ORGANIZATION/settings/installations/INSTALLATION_ID Register the app ID, installation ID, and the downloaded .pem private key file from the previous steps to Kubernetes as a secret. To create a Kubernetes secret with the values of your GitHub App, run the following command. Note  Create the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller. Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller . Then using the githubConfigSecret property in your copy of the values.yaml file, pass the secret name as a reference.",githubConfigSecret: pre-defined-secret,"jobs:
  authenticate:
    runs-on: ubuntu-latest
    steps:
      - name: Set up GitHub App authentication
        env:
          APP_ID: ${{ secrets.GITHUB_APP_ID }}
          INSTALLATION_ID: ${{ secrets.GITHUB_INSTALLATION_ID }}
          PRIVATE_KEY: ${{ secrets.GITHUB_PRIVATE_KEY }}
        run: |
          echo ""Authenticating with GitHub App""
          # Add your authentication logic here
",0
1165,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api,Authenticating to the GitHub API - Authenticating ARC with a personal access token (classic),"ARC can use personal access tokens (classic) to register self-hosted runners. Create a personal access token (classic) with the required scopes. The required scopes are different depending on whether you are registering runners at the repository or organization level. For more information on how to create a personal access token (classic), see Managing your personal access tokens . The following is the list of required personal access token scopes for ARC runners. To create a Kubernetes secret with the value of your personal access token (classic), use the following command. Note  Create the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller. Note Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller . In your copy of the values.yaml file, pass the secret name as a reference.",githubConfigSecret: pre-defined-secret,"jobs:
  authenticate:
    runs-on: ubuntu-latest
    steps:
      - name: Create Kubernetes Secret
        run: |
          kubectl create secret generic arc-token-secret \
            --from-literal=token=${{ secrets.PERSONAL_ACCESS_TOKEN }} \
            --namespace=arc-runners
",0
1166,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Caching - CircleCI syntax for caching,CircleCI and GitHub Actions provide a method to manually cache files in the configuration file. Below is an example of the syntax for each system.,"- restore_cache:
    keys:
      - v1-npm-deps-{{ checksum ""package-lock.json"" }}
      - v1-npm-deps-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: path/to/dependencies
          key: ${{ runner.os }}-build-${{ hashFiles('**/lockfiles') }}
          restore-keys: |
            ${{ runner.os }}-build-
      - name: Install dependencies
        run: |
          # Command to install dependencies
",0
1167,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Caching - GitHub Actions syntax for caching,CircleCI and GitHub Actions provide a method to manually cache files in the configuration file. Below is an example of the syntax for each system.,"- name: Cache node modules
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}
    restore-keys: v1-npm-deps-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: path/to/dependencies
          key: ${{ runner.os }}-build-${{ hashFiles('**/lockfiles') }}
          restore-keys: |
            ${{ runner.os }}-build-
      - name: Install dependencies
        run: |
          # Command to install dependencies
",0
1168,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Persisting data between jobs - CircleCI syntax for persisting data between jobs,Both CircleCI and GitHub Actions provide mechanisms to persist data between jobs. Below is an example in CircleCI and GitHub Actions configuration syntax.,"- persist_to_workspace:
    root: workspace
    paths:
      - math-homework.txt

...

- attach_workspace:
    at: /tmp/workspace","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Build
        run: echo ""Building project""
      - name: Save artifact
        uses: actions/upload-artifact@v2
        with:
          name: build-output
          path: ./build

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Download artifact
        uses: actions/download-artifact@v2
        with:
          name: build-output
      - name: Test
        run: echo ""Running tests""
",0
1169,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Persisting data between jobs - GitHub Actions syntax for persisting data between jobs,Both CircleCI and GitHub Actions provide mechanisms to persist data between jobs. Below is an example in CircleCI and GitHub Actions configuration syntax.,"- name: Upload math result for job 1
  uses: actions/upload-artifact@v4
  with:
    name: homework
    path: math-homework.txt

...

- name: Download math result for job 1
  uses: actions/download-artifact@v4
  with:
    name: homework","jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Create a file
        run: echo ""Hello, World!"" > myfile.txt
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: my-artifact
          path: myfile.txt

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v2
        with:
          name: my-artifact
      - name: Display file content
        run: cat myfile.txt
",0
1170,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Using databases and service containers - CircleCI syntax for using databases and service containers,"Both systems enable you to include additional containers for databases, caching, or other dependencies. In CircleCI, the first image listed in the config.yaml is the primary image used to run commands. GitHub Actions uses explicit sections: use container for the primary container, and list additional containers in services . Below is an example in CircleCI and GitHub Actions configuration syntax.","---
version: 2.1

jobs:

  ruby-26:
    docker:
      - image: circleci/ruby:2.6.3-node-browsers-legacy
        environment:
          PGHOST: localhost
          PGUSER: administrate
          RAILS_ENV: test
      - image: postgres:10.1-alpine
        environment:
          POSTGRES_USER: administrate
          POSTGRES_DB: ruby26
          POSTGRES_PASSWORD: """"

    working_directory: ~/administrate

    steps:
      - checkout

      # Bundle install dependencies
      - run: bundle install --path vendor/bundle

      # Wait for DB
      - run: dockerize -wait tcp://localhost:5432 -timeout 1m

      # Setup the environment
      - run: cp .sample.env .env

      # Setup the database
      - run: bundle exec rake db:setup

      # Run the tests
      - run: bundle exec rake

workflows:
  version: 2
  build:
    jobs:
      - ruby-26
...

- attach_workspace:
    at: /tmp/workspace","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: primary-image:latest
    services:
      database:
        image: postgres:latest
        ports:
          - 5432:5432
      cache:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - uses: actions/checkout@v2
      - name: Run application
        run: |
          # Commands to run your application
",0
1171,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Using databases and service containers - GitHub Actions syntax for using databases and service containers,"Both systems enable you to include additional containers for databases, caching, or other dependencies. In CircleCI, the first image listed in the config.yaml is the primary image used to run commands. GitHub Actions uses explicit sections: use container for the primary container, and list additional containers in services . Below is an example in CircleCI and GitHub Actions configuration syntax.","name: Containers

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    container: circleci/ruby:2.6.3-node-browsers-legacy

    env:
      PGHOST: postgres
      PGUSER: administrate
      RAILS_ENV: test

    services:
      postgres:
        image: postgres:10.1-alpine
        env:
          POSTGRES_USER: administrate
          POSTGRES_DB: ruby25
          POSTGRES_PASSWORD: """"
        ports:
          - 5432:5432
        # Add a health check
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5

    steps:
      # This Docker file changes sets USER to circleci instead of using the default user, so we need to update file permissions for this image to work on GH Actions.
      # See https://docs.github.com/actions/using-github-hosted-runners/about-github-hosted-runners#docker-container-filesystem

      - name: Setup file system permissions
        run: sudo chmod -R 777 $GITHUB_WORKSPACE /github /__w/_temp
      - uses: actions/checkout@v4
      - name: Install dependencies
        run: bundle install --path vendor/bundle
      - name: Setup environment configuration
        run: cp .sample.env .env
      - name: Setup database
        run: bundle exec rake db:setup
      - name: Run tests
        run: bundle exec rake","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: my-primary-image:latest
    services:
      db:
        image: postgres:latest
        ports:
          - 5432:5432
      cache:
        image: redis:latest
        ports:
          - 6379:6379
    steps:
      - uses: actions/checkout@v2
      - name: Run application
        run: |
          # Commands to run your application
",0
1172,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Complete Example - Complete example for CircleCI,Below is a real-world example. The left shows the actual CircleCI config.yml for the thoughtbot/administrator repository. The right shows the GitHub Actions equivalent.,"---
version: 2.1

commands:
  shared_steps:
    steps:
      - checkout

      # Restore Cached Dependencies
      - restore_cache:
          name: Restore bundle cache
          key: administrate-{{ checksum ""Gemfile.lock"" }}

      # Bundle install dependencies
      - run: bundle install --path vendor/bundle

      # Cache Dependencies
      - save_cache:
          name: Store bundle cache
          key: administrate-{{ checksum ""Gemfile.lock"" }}
          paths:
            - vendor/bundle

      # Wait for DB
      - run: dockerize -wait tcp://localhost:5432 -timeout 1m

      # Setup the environment
      - run: cp .sample.env .env

      # Setup the database
      - run: bundle exec rake db:setup

      # Run the tests
      - run: bundle exec rake

default_job: &default_job
  working_directory: ~/administrate
  steps:
    - shared_steps
    # Run the tests against multiple versions of Rails
    - run: bundle exec appraisal install
    - run: bundle exec appraisal rake

jobs:
  ruby-25:
    <<: *default_job
    docker:
      - image: circleci/ruby:2.5.0-node-browsers
        environment:
          PGHOST: localhost
          PGUSER: administrate
          RAILS_ENV: test
      - image: postgres:10.1-alpine
        environment:
          POSTGRES_USER: administrate
          POSTGRES_DB: ruby25
          POSTGRES_PASSWORD: """"

  ruby-26:
    <<: *default_job
    docker:
      - image: circleci/ruby:2.6.3-node-browsers-legacy
        environment:
          PGHOST: localhost
          PGUSER: administrate
          RAILS_ENV: test
      - image: postgres:10.1-alpine
        environment:
          POSTGRES_USER: administrate
          POSTGRES_DB: ruby26
          POSTGRES_PASSWORD: """"

workflows:
  version: 2
  multiple-rubies:
    jobs:
      - ruby-26
      - ruby-25","name: CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 2.7
      - name: Install dependencies
        run: bundle install
      - name: Run tests
        run: bundle exec rake
",0
1173,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions,Migrating from CircleCI to GitHub Actions - Complete Example - Complete example for GitHub Actions,Below is a real-world example. The left shows the actual CircleCI config.yml for the thoughtbot/administrator repository. The right shows the GitHub Actions equivalent.,"# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Containers

on: [push]

jobs:
  build:

    strategy:
      matrix:
        ruby: ['2.5', '2.6.3']

    runs-on: ubuntu-latest

    env:
      PGHOST: localhost
      PGUSER: administrate
      RAILS_ENV: test

    services:
      postgres:
        image: postgres:10.1-alpine
        env:
          POSTGRES_USER: administrate
          POSTGRES_DB: ruby25
          POSTGRES_PASSWORD: """"
        ports:
          - 5432:5432
        # Add a health check
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5

    steps:
      - uses: actions/checkout@v4
      - name: Setup Ruby
        uses: eregon/use-ruby-action@ec02537da5712d66d4d50a0f33b7eb52773b5ed1
        with:
          ruby-version: ${{ matrix.ruby }}
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: vendor/bundle
          key: administrate-${{ matrix.image }}-${{ hashFiles('Gemfile.lock') }}
      - name: Install postgres headers
        run: |
          sudo apt-get update
          sudo apt-get install libpq-dev
      - name: Install dependencies
        run: bundle install --path vendor/bundle
      - name: Setup environment configuration
        run: cp .sample.env .env
      - name: Setup database
        run: bundle exec rake db:setup
      - name: Run tests
        run: bundle exec rake
      - name: Install appraisal
        run: bundle exec appraisal install
      - name: Run appraisal
        run: bundle exec appraisal rake","name: CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 2.7
      - name: Install dependencies
        run: bundle install
      - name: Run tests
        run: bundle exec rake
",0
1174,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-gitlab-with-github-actions-importer,Migrating from GitLab with GitHub Actions Importer - Reference - Using optional arguments - --config-file-path - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from GitLab. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. The --config-file-path argument can also be used to specify which repository a converted reusable workflow should be migrated to. In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit. To audit a GitLab instance using a configuration file, the file must be in the following format, and each repository_slug value must be unique:","source_files:
  - repository_slug: namespace/project-name
    path: path/to/.gitlab-ci.yml
  - repository_slug: namespace/some-other-project-name
    path: path/to/.gitlab-ci.yml","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer audit
        run: |
          gh actions-importer audit --config-file-path path/to/config-file.yml
",0
1175,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-gitlab-with-github-actions-importer,Migrating from GitLab with GitHub Actions Importer - Reference - Using optional arguments - --config-file-path - Specify the repository of converted reusable workflows,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from GitLab. There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration. You can use the --config-file-path argument with the audit , dry-run , and migrate subcommands. By default, GitHub Actions Importer fetches pipeline contents from source control. The --config-file-path argument tells GitHub Actions Importer to use the specified source files instead. The --config-file-path argument can also be used to specify which repository a converted reusable workflow should be migrated to. GitHub Actions Importer uses the YAML file provided to the --config-file-path argument to determine the repository that converted reusable workflows are migrated to. To begin, you should run an audit without the --config-file-path argument: The output of this command will contain a file named config.yml that contains a list of all the composite actions that were converted by GitHub Actions Importer. For example, the config.yml file may have the following contents:","reusable_workflows:
  - name: my-reusable-workflow.yml
    target_url: https://github.com/octo-org/octo-repo
    ref: main","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer Audit
        run: gh actions-importer audit
  dry-run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer Dry-Run
        run: gh actions-importer dry-run --config-file-path config.yml
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer Migrate
        run: gh actions-importer migrate --config-file-path config.yml
",0
1176,https://docs.github.com/en/actions/writing-workflows/quickstart,Quickstart for GitHub Actions - Creating your first workflow,"In your repository on GitHub, create a workflow file called github-actions-demo.yml in the .github/workflows directory. To do this: If the .github/workflows directory already exists, navigate to that directory on GitHub, click Add file , then click Create new file , and name the file github-actions-demo.yml . If your repository doesn't have a .github/workflows directory, go to the main page of the repository on GitHub, click Add file , then click Create new file , and name the file .github/workflows/github-actions-demo.yml . This creates the .github and workflows directories and the github-actions-demo.yml file in a single step. Note  For GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called.github/workflows.  You can give the workflow file any name you like, but you must use.ymlor.yamlas the file name extension. YAML is a markup language that's commonly used for configuration files. Note For GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called .github/workflows . You can give the workflow file any name you like, but you must use .yml or .yaml as the file name extension. YAML is a markup language that's commonly used for configuration files. Copy the following YAML contents into the github-actions-demo.yml file:","name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "" The job was automatically triggered by a ${{ github.event_name }} event.""
      - run: echo "" This job is now running on a ${{ runner.os }} server hosted by GitHub!""
      - run: echo "" The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.""
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "" The ${{ github.repository }} repository has been cloned to the runner.""
      - run: echo "" The workflow is now ready to test your code on the runner.""
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "" This job's status is ${{ job.status }}.""","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Run a one-line script
      run: echo Hello, world!
    - name: Run a multi-line script
      run: |
        echo Add other actions to build,
        echo test, and deploy your project.
",0
1177,https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller,Quickstart for Actions Runner Controller - Using runner scale sets,"Now you will create and run a simple test workflow that uses the runner scale set runners. In a repository, create a workflow similar to the following example. The runs-on value should match the Helm installation name you used when you installed the autoscaling runner set. For more information on adding workflows to a repository, see Quickstart for GitHub Actions .","name: Actions Runner Controller Demo
on:
  workflow_dispatch:

jobs:
  Explore-GitHub-Actions:
    # You need to use the INSTALLATION_NAME from the previous step
    runs-on: arc-runner-set
    steps:
    - run: echo "" This job uses runner scale set runners!""","jobs:
  test:
    runs-on: my-runner-scale-set
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a one-liner script
        run: echo ""Hello, world!""
",0
1178,https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service,Deploying Docker to Azure App Service - Creating the workflow,"Once you've completed the prerequisites, you can proceed with creating the workflow. The following example workflow demonstrates how to build and deploy a Docker container to Azure App Service when there is a push to the main branch. Ensure that you set AZURE_WEBAPP_NAME in the workflow env key to the name of the web app you created. If you configured a deployment environment, change the value of environment to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the environment key.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Build and deploy a container to an Azure Web App

env:
  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name

on:
  push:
    branches:
      - main

permissions:
  contents: 'read'
  packages: 'write'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b

      - name: Log in to GitHub container registry
        uses: docker/login-action@8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Lowercase the repo name
        run: echo ""REPO=${GITHUB_REPOSITORY,,}"" >>${GITHUB_ENV}

      - name: Build and push container image to registry
        uses: docker/build-push-action@9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f
        with:
          push: true
          tags: ghcr.io/${{ env.REPO }}:${{ github.sha }}
          file: ./Dockerfile

  deploy:
    runs-on: ubuntu-latest

    needs: build

    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Lowercase the repo name
        run: echo ""REPO=${GITHUB_REPOSITORY,,}"" >>${GITHUB_ENV}

      - name: Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          images: 'ghcr.io/${{ env.REPO }}:${{ github.sha }}'","on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Build and push Docker image
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.AZURE_CONTAINER_REGISTRY_LOGIN_SERVER }}
          username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
          password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}

      - name: Build and push Docker image
        run: |
          docker build . -t ${{ secrets.AZURE_CONTAINER_REGISTRY_LOGIN_SERVER }}/myapp:${{ github.sha }}
          docker push ${{ secrets.AZURE_CONTAINER_REGISTRY_LOGIN_SERVER }}/myapp:${{ github.sha }}

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ secrets.AZURE_CONTAINER_REGISTRY_LOGIN_SERVER }}/myapp:${{ github.sha }}
",0
1179,https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: PostgreSQL service example
on: push

jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to PostgreSQL
        # Runs a script that creates a PostgreSQL table, populates
        # the table with data, and then retrieves the data.
        run: node client.js
        # Environment variables used by the `client.js` script to create a new PostgreSQL table.
        env:
          # The hostname used to communicate with the PostgreSQL service container
          POSTGRES_HOST: postgres
          # The default PostgreSQL port
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: user
          POSTGRES_PASSWORD: password
          POSTGRES_DB: mydb
        options: --health-cmd=""pg_isready"" --health-interval=10s --health-timeout=5s --health-retries=5
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run PostgreSQL client
        run: |
          apt-get update
          apt-get install -y postgresql-client
          psql -h postgres -U user -d mydb -c ""SELECT 1;""
",0
1180,https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs in containers - Configuring the runner job for jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. This workflow configures a job that runs in the node:20-bookworm-slim container and uses the ubuntu-latest GitHub-hosted runner as the Docker host for the container. For more information about the node:20-bookworm-slim container, see the node image on Docker Hub. The workflow configures a service container with the label postgres . All services must run in a container, so each service requires that you specify the container image . This example uses the postgres container image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see the postgres image on Docker Hub.","jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:20-bookworm-slim

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: node:20-bookworm-slim
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd ""pg_isready -U postgres""
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
",0
1181,https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs in containers - Configuring the steps for jobs in containers,"Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to PostgreSQL
    # Runs a script that creates a PostgreSQL table, populates
    # the table with data, and then retrieves the data.
    run: node client.js
    # Environment variable used by the `client.js` script to create
    # a new PostgreSQL client.
    env:
      # The hostname used to communicate with the PostgreSQL service container
      POSTGRES_HOST: postgres
      # The default PostgreSQL port
      POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: user
          POSTGRES_PASSWORD: password
          POSTGRES_DB: mydb
        options: --health-cmd=""pg_isready"" --health-interval=10s --health-timeout=5s --health-retries=5
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: |
          apt-get update
          apt-get install -y postgresql-client
          psql -h postgres -U user -d mydb -c ""SELECT 1;""
",0
1182,https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed.","name: PostgreSQL Service Example
on: push

jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps tcp port 5432 on service container to the host
          - 5432:5432

    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v4

      # Performs a clean installation of all dependencies in the `package.json` file
      # For more information, see https://docs.npmjs.com/cli/ci.html
      - name: Install dependencies
        run: npm ci

      - name: Connect to PostgreSQL
        # Runs a script that creates a PostgreSQL table, populates
        # the table with data, and then retrieves the data
        run: node client.js
        # Environment variables used by the `client.js` script to create
        # a new PostgreSQL table.
        env:
          # The hostname used to communicate with the PostgreSQL service container
          POSTGRES_HOST: localhost
          # The default PostgreSQL port
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
    steps:
      - name: Check out repository
        uses: actions/checkout@v3
      - name: Run a command
        run: |
          echo ""PostgreSQL is running on localhost:5432""
",0
1183,https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs directly on the runner machine - Configuring the runner job for jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The example uses the ubuntu-latest GitHub-hosted runner as the Docker host. The workflow configures a service container with the label postgres . All services must run in a container, so each service requires that you specify the container image . This example uses the postgres container image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see the postgres image on Docker Hub. The workflow maps port 5432 on the PostgreSQL service container to the Docker host. For more information about the ports keyword, see About service containers .","jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps tcp port 5432 on service container to the host
          - 5432:5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd=""pg_isready -U postgres""
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
",0
1184,https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers,Creating PostgreSQL service containers - Running jobs directly on the runner machine - Configuring the steps for jobs directly on the runner machine,"When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using localhost and the Docker host port number. You can copy this workflow file to the .github/workflows directory of your repository and modify it as needed. The workflow performs the following steps:","steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v4

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to PostgreSQL
    # Runs a script that creates a PostgreSQL table, populates
    # the table with data, and then retrieves the data
    run: node client.js
    # Environment variables used by the `client.js` script to create
    # a new PostgreSQL table.
    env:
      # The hostname used to communicate with the PostgreSQL service container
      POSTGRES_HOST: localhost
      # The default PostgreSQL port
      POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run a script
        run: |
          echo ""Running on the runner machine""
          psql -h localhost -U postgres -c ""SELECT version();""
",0
1185,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action,Creating a composite action - Creating an action metadata file,"In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions .","name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: ""Random number""
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: ""composite""
  steps:
    - name: Set Greeting
      run: echo ""Hello $INPUT_WHO_TO_GREET.""
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo ""random-number=$(echo $RANDOM)"" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo ""$GITHUB_ACTION_PATH"" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash","runs:
  using: ""composite""
  steps:
    - name: Check out repository
      uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Run script
      run: echo ""Hello, World!""
",0
1186,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action,Creating a composite action - Testing out your action in a workflow,"The following workflow code uses the completed hello world action that you made in Creating a composite action . Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","jobs:
  test-composite-action:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run hello world action
        uses: OWNER/REPO@SHA
        with:
          who-to-greet: 'Your Name'
",0
1187,https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action,Creating a composite action - Creating a composite action within the same repository,"Create a new subfolder called hello-world-composite-action , this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier. In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action . When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.","on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number ""$RANDOM_NUMBER""
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}","runs:
  using: ""composite""
  steps:
    - run: echo ""Goodbye, World!""
      shell: bash
      working-directory: .github/actions/hello-world-composite-action
",0
1188,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer,Migrating from Bitbucket Pipelines with GitHub Actions Importer - About migrating from Bitbucket Pipelines with GitHub Actions Importer - Limitations,"The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Bitbucket Pipelines to GitHub Actions. There are some limitations when migrating from Bitbucket Pipelines to GitHub Actions with GitHub Actions Importer. Images in a private AWS ECR are not supported. The Bitbucket Pipelines option size is not supported. If additional runner resources are required in GitHub Actions, consider using larger runners. For more information, see Using larger runners . Metrics detailing the queue time of jobs is not supported by the forecast command. Bitbucket after-scripts are supported using GitHub Actions always() in combination with checking the steps.<step_id>.conclusion of the previous step. For more information, see Accessing contextual information about workflow runs . The following is an example of using the always() with steps.<step_id>.conclusion .","- name: After Script 1
    run: |-
      echo ""I'm after the script ran!""
      echo ""We should be grouped!""
    id: after-script-1
    if: ""${{ always() }}""
  - name: After Script 2
    run: |-
      echo ""this is really the end""
      echo ""goodbye, for now!""
    id: after-script-2
    if: ""${{ steps.after-script-1.conclusion == 'success' && always() }}""","jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run main script
        run: |
          echo ""Running main script""
      - name: After script
        if: always()
        run: |
          if [ ""${{ steps.main.conclusion }}"" == ""success"" ]; then
            echo ""Main script succeeded""
          else
            echo ""Main script failed""
          fi
",0
1189,https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer,Migrating from Bitbucket Pipelines with GitHub Actions Importer - Reference - Audit example,"This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bitbucket Pipelines. In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit. To audit a Bitbucket instance using a config file, the config file must be in the following format, and each repository_slug must be unique:","source_files:
  - repository_slug: repo_name
    path: path/to/one/source/file.yml
  - repository_slug: another_repo_name
    path: path/to/another/source/file.yml","jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Run GitHub Actions Importer Audit
        uses: github/gh-actions-importer@v1
        with:
          config-file: path/to/config.yml
",0
1190,https://docs.github.com/en/actions/security-guides/automatic-token-authentication,Automatic token authentication - Using the GITHUB_TOKEN in a workflow - Example 1: passing the GITHUB_TOKEN as an input,"You can use the GITHUB_TOKEN by using the standard syntax for referencing secrets: ${{ secrets.GITHUB_TOKEN }} . Examples of using the GITHUB_TOKEN include passing the token as an input to an action, or using it to make an authenticated GitHub API request. Important  An action can access theGITHUB_TOKENthrough thegithub.tokencontext even if the workflow does not explicitly pass theGITHUB_TOKENto the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to theGITHUB_TOKEN. For more information, seePermissions for theGITHUB_TOKEN. Important An action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN . For more information, see Permissions for the GITHUB_TOKEN . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. Commits pushed by a GitHub Actions workflow that uses the GITHUB_TOKEN do not trigger a GitHub Pages build. This example workflow uses the GitHub CLI , which requires the GITHUB_TOKEN as the value for the GH_TOKEN input parameter:","name: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title ""Issue title"" --body ""Issue body""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up GitHub CLI
        uses: actions/setup-gh@v2
      - name: Authenticate with GitHub CLI
        run: gh auth login --with-token <<< ""${{ secrets.GITHUB_TOKEN }}""
",0
1191,https://docs.github.com/en/actions/security-guides/automatic-token-authentication,Automatic token authentication - Using the GITHUB_TOKEN in a workflow - Example 2: calling the REST API,"You can use the GITHUB_TOKEN by using the standard syntax for referencing secrets: ${{ secrets.GITHUB_TOKEN }} . Examples of using the GITHUB_TOKEN include passing the token as an input to an action, or using it to make an authenticated GitHub API request. Important  An action can access theGITHUB_TOKENthrough thegithub.tokencontext even if the workflow does not explicitly pass theGITHUB_TOKENto the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to theGITHUB_TOKEN. For more information, seePermissions for theGITHUB_TOKEN. Important An action can access the GITHUB_TOKEN through the github.token context even if the workflow does not explicitly pass the GITHUB_TOKEN to the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to the GITHUB_TOKEN . For more information, see Permissions for the GITHUB_TOKEN . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. Commits pushed by a GitHub Actions workflow that uses the GITHUB_TOKEN do not trigger a GitHub Pages build. You can use the GITHUB_TOKEN to make authenticated API calls. This example workflow creates an issue using the GitHub REST API:","name: Create issue on commit

on: [ push ]

jobs:
  create_issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Create issue using REST API
        run: |
          curl --request POST \
          --url https://api.github.com/repos/${{ github.repository }}/issues \
          --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \
          --header 'content-type: application/json' \
          --data '{
            ""title"": ""Automated issue for commit: ${{ github.sha }}"",
            ""body"": ""This issue was automatically created by the GitHub Action workflow **${{ github.workflow }}**. \n\n The commit hash was: _${{ github.sha }}_.""
            }' \
          --fail","jobs:
  create_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub Issue
        run: |
          curl -X POST \
          -H ""Authorization: token ${{ secrets.GITHUB_TOKEN }}"" \
          -H ""Accept: application/vnd.github.v3+json"" \
          https://api.github.com/repos/${{ github.repository }}/issues \
          -d '{""title"":""Automated Issue"",""body"":""This issue was created automatically by a GitHub Action.""}'
",0
1192,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle,Building and testing Java with Gradle - Using a Gradle workflow template - Specifying the Java version and architecture,"To get started quickly, add a workflow template to the .github/workflows directory of your repository. GitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template. On GitHub, navigate to the main page of the repository. Under your repository name, click Actions . If you already have a workflow in your repository, click New workflow . The ""Choose a workflow"" page shows a selection of recommended workflow templates. Search for ""Java with Gradle"". On the ""Java with Gradle"" workflow, click Configure .
This workflow performs the following steps: Checks out a copy of project's repository. Sets up the Java JDK. Sets up the Gradle environment. The gradle/actions/setup-gradle action takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions. The ""Build with Gradle"" step executes the build task using the Gradle Wrapper . Edit the workflow as required. For example, change the Java version. Note    This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, seeSecurity hardening for GitHub Actions. Note Click Commit changes . The gradle.yml workflow file is added to the .github/workflows directory of your repository. The workflow template sets up the PATH to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( x64 or x86 ), you can use the setup-java action to choose a different Java runtime environment. For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the setup-java action and configure the java-version , distribution and architecture parameters to '11' , 'temurin' and x64 .","steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 11 for x64
    uses: actions/setup-java@v4
    with:
      java-version: '11'
      distribution: 'temurin'
      architecture: x64","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        architecture: 'x64'
    - name: Set up Gradle
      uses: gradle/gradle-build-action@a1b2c3d4e5f6g7h8i9j0k
    - name: Build with Gradle
      run: ./gradlew build
",0
1193,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle,Building and testing Java with Gradle - Building and testing your code,"You can use the same commands that you use locally to build and test your code. The workflow template will run the build task by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file. If you use different commands to build your project, or you want to use a different task, you can specify those. For example, you may want to run the package task that's configured in your ci.gradle file.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - name: Setup Gradle
    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  - name: Build with Gradle
    run: ./gradlew -b ci.gradle package","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
    - name: Build with Gradle
      run: ./gradlew build
",0
1194,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle,Building and testing Java with Gradle - Packaging workflow data as artifacts,"After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see Storing and sharing data from a workflow . Gradle will usually create output files like JARs, EARs, or WARs in the build/libs directory. You can upload the contents of that directory using the upload-artifact action.","steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - name: Setup Gradle
    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  - name: Build with Gradle
    run: ./gradlew build

  - name: Upload build artifacts
    uses: actions/upload-artifact@v4
    with:
      name: Package
      path: build/libs","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'adopt'
        java-version: '11'
    - name: Build with Gradle
      run: ./gradlew build
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-artifacts
        path: build/libs
",0
1195,https://docs.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation,Scheduling issue creation - Creating the workflow,"Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see Creating a new repository . In your repository, create a file called .github/workflows/YOUR_WORKFLOW.yml , replacing YOUR_WORKFLOW with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see Creating new files . Copy the following YAML contents into your workflow file.","name: Weekly Team Sync
on:
  schedule:
    - cron: 20 07 * * 1

jobs:
  create_issue:
    name: Create team sync issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Create team sync issue
        run: |
          if [[ $CLOSE_PREVIOUS == true ]]; then
            previous_issue_number=$(gh issue list \
              --label ""$LABELS"" \
              --json number \
              --jq '.[0].number')
            if [[ -n $previous_issue_number ]]; then
              gh issue close ""$previous_issue_number""
              gh issue unpin ""$previous_issue_number""
            fi
          fi
          new_issue_url=$(gh issue create \
            --title ""$TITLE"" \
            --assignee ""$ASSIGNEES"" \
            --label ""$LABELS"" \
            --body ""$BODY"")
          if [[ $PINNED == true ]]; then
            gh issue pin ""$new_issue_url""
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          TITLE: Team sync
          ASSIGNEES: monalisa,doctocat,hubot
          LABELS: weekly sync,docs-team
          BODY: |
            ### Agenda

            - [ ] Start the recording
            - [ ] Check-ins
            - [ ] Discussion points
            - [ ] Post the recording

            ### Discussion Points
            Add things to discuss below

            - [Work this week](https://github.com/orgs/github/projects/3)
          PINNED: false
          CLOSE_PREVIOUS: false","name: Schedule Issue Creation
on:
  schedule:
    - cron: '0 9 * * 1'
jobs:
  create_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub Issue
        uses: actions/github-script@v6
        with:
          script: |
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'Weekly Update',
              body: 'Please provide your weekly update.',
            });
",0
1196,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - About expressions - Example setting an environment variable,"You can use expressions to programmatically set environment variables in workflow files and access contexts. An expression can be any combination of literal values, references to a context, or functions. You can combine literals, context references, and functions using operators. For more information about contexts, see Accessing contextual information about workflow runs . Expressions are commonly used with the conditional if keyword in a workflow file to determine whether a step should run. When an if conditional is true , the step will run. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. ${{ <expression> }} Note  The exception to this rule is when you are using expressions in anifclause, where, optionally, you can usually omit${{and}}. For more information aboutifconditionals, seeWorkflow syntax for GitHub Actions. Note The exception to this rule is when you are using expressions in an if clause, where, optionally, you can usually omit ${{ and }} . For more information about if conditionals, see Workflow syntax for GitHub Actions . Warning  When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions. Warning When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions .","env:
  MY_ENV_VAR: ${{ <expression> }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo ""MY_VAR=${{ github.event_name }}"" >> $GITHUB_ENV
",0
1197,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Literals - Example of literals,"As part of an expression, you can use boolean , null , number , or string data types. Note that in conditionals, falsy values ( false , 0 , -0 , """" , '' , null ) are coerced to false and truthy ( true and other non-falsy values) are coerced to true .","env:
  myNull: ${{ null }}
  myBoolean: ${{ false }}
  myIntegerNumber: ${{ 711 }}
  myFloatNumber: ${{ -9.2 }}
  myHexNumber: ${{ 0xff }}
  myExponentialNumber: ${{ -2.99e-2 }}
  myString: Mona the Octocat
  myStringInBraces: ${{ 'It''s open source!' }}","jobs:
  evaluate-expressions:
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate boolean
        run: echo ${{ true && false }}
      - name: Evaluate null
        run: echo ${{ null || 'default' }}
      - name: Evaluate number
        run: echo ${{ 0 || 42 }}
      - name: Evaluate string
        run: echo ${{ '' || 'fallback' }}
",0
1198,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Operators - Example,"Note    GitHub ignores case when comparing strings.steps.<step_id>.outputs.<output_name>evaluates as a string. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. For more information, seeAccessing contextual information about workflow runs.For numerical comparison, thefromJSON()function can be used to convert a string to a number. For more information on thefromJSON()function, seefromJSON. Note GitHub performs loose equality comparisons. If the types do not match, GitHub coerces the type to a number. GitHub casts data types to a number using these conversions: When NaN is one of the operands of any relational comparison ( > , < , >= , <= ), the result is always false . For more information, see the NaN Mozilla docs . GitHub ignores case when comparing strings. Objects and arrays are only considered equal when they are the same instance. GitHub offers ternary operator like behaviour that you can use in expressions. By using a ternary operator in this way, you can dynamically set the value of an environment variable based on a condition, without having to write separate if-else blocks for each possible option.","env:
  MY_ENV_VAR: ${{ github.ref == 'refs/heads/main' && 'value_for_main_branch' || 'value_for_other_branches' }}","jobs:
  evaluate-expressions:
    runs-on: ubuntu-latest
    steps:
      - id: example
        run: echo ""result=$((fromJSON('\""5\""') > 3 ? 'greater' : 'lesser'))"" >> $GITHUB_ENV
",0
1199,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Functions - fromJSON - Example returning a JSON object,"GitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions: fromJSON(value) Returns a JSON object or JSON data type for value . You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects. This workflow sets a JSON matrix in one job, and passes it to the next job using an output and fromJSON .","name: build
on: push
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo ""matrix={\""include\"":[{\""project\"":\""foo\"",\""config\"":\""Debug\""},{\""project\"":\""bar\"",\""config\"":\""Release\""}]}"" >> $GITHUB_OUTPUT
  job2:
    needs: job1
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}
    steps:
      - run: echo ""Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}""","jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo ""::set-output name=matrix::{\""include\"":[{\""os\"":\""ubuntu-latest\""},{\""os\"":\""windows-latest\""}]}""

  use-matrix:
    runs-on: ubuntu-latest
    needs: set-matrix
    strategy:
      matrix: ${{ fromJSON(needs.set-matrix.outputs.matrix) }}
    steps:
      - run: echo ""Running on ${{ matrix.os }}""
",0
1200,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Functions - fromJSON - Example returning a JSON data type,"GitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions: fromJSON(value) Returns a JSON object or JSON data type for value . You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects. This workflow uses fromJSON to convert environment variables from a string to a Boolean or integer.","name: print
on: push
env:
  continue: true
  time: 3
jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - continue-on-error: ${{ fromJSON(env.continue) }}
        timeout-minutes: ${{ fromJSON(env.time) }}
        run: echo ...","jobs:
  convert_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Convert environment variables
        env:
          BOOLEAN_STRING: ""true""
          INTEGER_STRING: ""42""
        run: |
          echo ""Boolean value: ${{ fromJSON(env.BOOLEAN_STRING) }}""
          echo ""Integer value: ${{ fromJSON(env.INTEGER_STRING) }}""
",0
1201,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Status check functions - success - Example of success,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true when all previous steps have succeeded.","steps:
  ...
  - name: The job has succeeded
    if: ${{ success() }}","jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: Step 2
        run: echo ""This is step 2""
      - name: Step 3
        if: success()
        run: echo ""All previous steps succeeded""
",0
1202,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Status check functions - always - Example of always,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Causes the step to always execute, and returns true , even when canceled. The always expression is best used at the step level or on tasks that you expect to run even when a job is canceled. For example, you can use always to send logs even when a job is canceled. Warning  Avoid usingalwaysfor any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative:if: ${{ !cancelled() }} Warning Avoid using always for any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative: if: ${{ !cancelled() }}",if: ${{ always() }},"jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Run step always
        run: echo ""This step runs always""
        if: always()
",0
1203,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Status check functions - cancelled - Example of cancelled,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true if the workflow was canceled.",if: ${{ cancelled() }},"jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Check if cancelled
        if: cancelled()
        run: echo ""The workflow was cancelled.""
",0
1204,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Status check functions - failure - Example of failure,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true when any previous step of a job fails. If you have a chain of dependent jobs, failure() returns true if any ancestor job fails.","steps:
  ...
  - name: The job has failed
    if: ${{ failure() }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: Step 2
        run: exit 1
      - name: Step 3
        if: failure()
        run: echo ""A previous step has failed""
",0
1205,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions,Evaluate expressions in workflows and actions - Status check functions - failure - failure with conditions - Example of failure with conditions,"You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions . Returns true when any previous step of a job fails. If you have a chain of dependent jobs, failure() returns true if any ancestor job fails. You can include extra conditions for a step to run after a failure, but you must still include failure() to override the default status check of success() that is automatically applied to if conditions that don't contain a status check function.","steps:
  ...
  - name: Failing step
    id: demo
    run: exit 1
  - name: The demo step has failed
    if: ${{ failure() && steps.demo.conclusion == 'failure' }}","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo ""This is step 1""
      - name: Step 2
        run: echo ""This is step 2""
        if: failure()
",0
1206,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - About workflow triggers - Triggering a workflow from a workflow,"Workflow triggers are events that cause a workflow to run. These events can be: For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened. Workflow triggers are defined with the on key. For more information, see Workflow syntax for GitHub Actions . The following steps occur to trigger a workflow run: An event occurs on your repository. The event has an associated commit SHA and Git ref. GitHub searches the .github/workflows directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event. A workflow run is triggered for any workflows that have on: values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run. Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) environment variables in the runner environment. For more information, see Store information in variables . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. For more information, see Automatic token authentication . If you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of GITHUB_TOKEN to trigger events that require a token. If you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow . If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see Managing your personal access tokens . For more information about storing secrets, see Using secrets in GitHub Actions . To minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs. For example, the following workflow uses a personal access token (stored as a secret called MY_TOKEN ) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed.","on:
  issues:
    types:
      - opened

jobs:
  label_issue:
    runs-on: ubuntu-latest
    steps:
      - env:
          GH_TOKEN: ${{ secrets.MY_TOKEN }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          gh issue edit $ISSUE_URL --add-label ""triage""","jobs:
  add_label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Add label to issue
        env:
          GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}
        run: gh issue edit ${{ github.event.issue.number }} --add-label ""new-label""
",0
1207,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - About workflow triggers - Triggering a workflow from a workflow,"Workflow triggers are events that cause a workflow to run. These events can be: For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened. Workflow triggers are defined with the on key. For more information, see Workflow syntax for GitHub Actions . The following steps occur to trigger a workflow run: An event occurs on your repository. The event has an associated commit SHA and Git ref. GitHub searches the .github/workflows directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event. A workflow run is triggered for any workflows that have on: values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run. Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) environment variables in the runner environment. For more information, see Store information in variables . When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN , with the exception of workflow_dispatch and repository_dispatch , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN , a new workflow will not run even when the repository contains a workflow configured to run when push events occur. For more information, see Automatic token authentication . If you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of GITHUB_TOKEN to trigger events that require a token. If you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow . If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see Managing your personal access tokens . For more information about storing secrets, see Using secrets in GitHub Actions . To minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs. For example, the following workflow uses a personal access token (stored as a secret called MY_TOKEN ) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed. Conversely, the following workflow uses GITHUB_TOKEN to add a label to an issue. It will not trigger any workflows that run when a label is added.","on:
  issues:
    types:
      - opened

jobs:
  label_issue:
    runs-on: ubuntu-latest
    steps:
      - env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          gh issue edit $ISSUE_URL --add-label ""triage""","jobs:
  add_label:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Add label to issue
        env:
          GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}
        run: gh issue edit 1 --add-label ""bug""
",0
1208,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using events to trigger workflows - Using a single event,"Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows . For example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:",on: push,"on:
  push:
    branches:
      - '**'
",0
1209,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using events to trigger workflows - Using multiple events,"Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows . You can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:","on: [push, fork]","on:
  push:
    branches:
      - '**'
  fork:
",0
1210,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using events to trigger workflows - Using activity types and filters with multiple events,"Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows . You can use activity types and filters to further control when your workflow will run. For more information, see Using event activity types and Using filters . If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon ( : ) to all events, including events without configuration. For example, a workflow with the following on value will run when:","on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:","on:
  push:
    branches:
      - main
  pull_request:
    types:
      - opened
      - synchronize
  issues:
    types:
      - opened
      - closed
  workflow_dispatch:
",0
1211,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using event activity types,"Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.","on:
  label:
    types:
      - created","on:
  label:
    types: [created]
",0
1212,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using event activity types,"Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run. For example, the issue_comment event has the created , edited , and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted. If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.","on:
  issues:
    types:
      - opened
      - labeled","on:
  issues:
    types: [opened, labeled]
",0
1213,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.","on:
  push:
    branches:
      - main
      - 'releases/**'","on:
  push:
    branches:
      - 'main'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1214,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for pull request events - Example: Including branches,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'","pull_request:
  branches:
    - 'main'
    - 'release/*'
",0
1215,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for pull request events - Example: Excluding branches,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:","on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'","pull_request:
  branches-ignore:
    - 'main'
    - 'release/*'
",0
1216,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for pull request events - Example: Including and excluding branches,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches and branches-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. The order that you define patterns matters. The following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona , but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","pull_request:
  branches:
    - releases/10
    - releases/beta/mona
    - '!releases/**-alpha'
",0
1217,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches or tags for push events - Example: Including branches and tags,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*","on:
  push:
    branches:
      - 'main'
      - 'release/*'
    tags:
      - 'v1.*'
",0
1218,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches or tags for push events - Example: Excluding branches and tags,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . When a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:","on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*","on:
  push:
    branches-ignore:
      - 'main'
      - 'release/*'
    tags-ignore:
      - 'v1.*'
      - 'beta-*'
",0
1219,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches or tags for push events - Example: Including and excluding branches and tags,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push event, you can configure a workflow to run on specific branches or tags. Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow. If you define only tags / tags-ignore or only branches / branches-ignore , the workflow won't run for events affecting the undefined Git ref. If you define neither tags / tags-ignore or branches / branches-ignore , the workflow will run for events affecting either branches or tags. If you define both branches / branches-ignore and paths/paths-ignore , the workflow will only run when both filters are satisfied. The branches , branches-ignore , tags , and tags-ignore keywords accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . You can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded. If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead. The order that you define patterns matters. The following workflow will run on pushes to releases/10 or releases/beta/mona , but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.","on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","on:
  push:
    branches:
      - releases/10
      - releases/beta/mona
      - '!releases/**-alpha'
",0
1220,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific paths for pull request or push events - Example: Including paths,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . If at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file ( .js ).","on:
  push:
    paths:
      - '**.js'","on:
  push:
    paths:
      - '**/*.js'
  pull_request:
    paths:
      - '**/*.js'
",0
1221,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific paths for pull request or push events - Example: Excluding paths,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . When all the path names match patterns in paths-ignore , the workflow will not run. If any path names do not match patterns in paths-ignore , even if some path names match the patterns, the workflow will run. A workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.","on:
  push:
    paths-ignore:
      - 'docs/**'","on:
  push:
    paths-ignore:
      - 'docs/**'
",0
1222,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific paths for pull request or push events - Example: Including and excluding paths,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags. Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. Note  The order that you definepathspatterns matters:  A matching negative pattern (prefixed with!) after a positive match will exclude the path.A matching positive pattern after a negative match will include the path again. Note The order that you define paths patterns matters: If you define both branches / branches-ignore and paths / paths-ignore , the workflow will only run when both filters are satisfied. The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions . You cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded. If you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead. This example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.","on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'","on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'
",0
1223,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for workflow run events,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'","on:
  workflow_run:
    workflows: [""Build""]
    branches:
      - releases/**
",0
1224,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for workflow run events,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary :","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches-ignore:
      - ""canary""","on:
  workflow_run:
    workflows: [""Build""]
    branches-ignore:
      - canary
",0
1225,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using filters - Using filters to target specific branches for workflow run events,"Some events have filters that give you more control over when your workflow should run. For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs. When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow. The branches and branches-ignore filters accept glob patterns that use characters like * , ** , + , ? , ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \ . For more information about glob patterns, see the Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/ : A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary : You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded. The order that you define patterns matters. For example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha , releases/beta/3-alpha , or main .","on:
  workflow_run:
    workflows: [""Build""]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'","workflow_run:
  workflows: [""Build""]
  branches:
    - releases/10
    - releases/beta/mona
    - '!releases/10-alpha'
    - '!releases/beta/3-alpha'
    - '!main'
",0
1226,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Defining inputs for manually triggered workflows,"When using the workflow_dispatch event, you can optionally specify inputs that are passed to the workflow. This trigger only receives events when the workflow file is on the default branch.
The triggered workflow receives the inputs in the inputs context. For more information, see Contexts . Note    The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.The maximum number of top-level properties forinputsis 10.The maximum payload forinputsis 65,535 characters. Note","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
      print_tags:
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    if: ${{ inputs.print_tags }} 
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }}","on:
  workflow_dispatch:
    inputs:
      example_input:
        description: 'An example input'
        required: true
        default: 'default_value'
",0
1227,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using event information - Viewing all properties of an event,"Information about the event that triggered a workflow run is available in the github.event context. The properties in the github.event context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label. Reference the webhook event documentation for common properties and example payloads. For more information, see Webhook events and payloads . You can also print the entire github.event context to see what properties are available for the event that triggered your workflow:","jobs:
  print_context:
    runs-on: ubuntu-latest
    steps:
      - env:
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
        run: |
          echo $EVENT_CONTEXT","jobs:
  print-event:
    runs-on: ubuntu-latest
    steps:
      - name: Print event context
        run: echo ""${{ toJson(github.event) }}""
",0
1228,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Using event information - Accessing and using event properties,"Information about the event that triggered a workflow run is available in the github.event context. The properties in the github.event context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label. You can use the github.event context in your workflow. For example, the following workflow runs when a pull request that changes package*.json , .github/CODEOWNERS , or .github/workflows/** is opened. If the pull request author ( github.event.pull_request.user.login ) is not octobot or dependabot[bot] , then the workflow uses the GitHub CLI to label and comment on the pull request ( github.event.pull_request.number ).","on:
  pull_request:
    types:
      - opened
    paths:
      - '.github/workflows/**'
      - '.github/CODEOWNERS'
      - 'package*.json'

jobs:
  triage:
    if: >-
      github.event.pull_request.user.login != 'octobot' &&
      github.event.pull_request.user.login != 'dependabot[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: ""Comment about changes we can't accept""
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR: ${{ github.event.pull_request.html_url }}
        run: |
          gh pr edit $PR --add-label 'invalid'
          gh pr comment $PR --body 'It looks like you edited `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**`. We do not allow contributions to these files. Please review our [contributing guidelines](https://github.com/octo-org/octo-repo/blob/main/CONTRIBUTING.md) for what contributions are accepted.'","on:
  pull_request:
    types: [opened]
    paths:
      - 'package*.json'
      - '.github/CODEOWNERS'
      - '.github/workflows/**'

jobs:
  label_and_comment:
    runs-on: ubuntu-latest
    steps:
      - name: Check PR author
        if: ${{ github.event.pull_request.user.login != 'octobot' && github.event.pull_request.user.login != 'dependabot[bot]' }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body ""Thank you for your contribution!""
          gh pr edit ${{ github.event.pull_request.number }} --add-label ""needs review""
",0
1229,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Further controlling how your workflow will run - Using conditionals - Example using a value in the event payload,"If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run. You can use conditionals to further control whether jobs or steps in your workflow will run. For example, if you want the workflow to run when a specific label is added to an issue, you can trigger on the issues labeled event activity type and use a conditional to check what label triggered the workflow. The following workflow will run when any label is added to an issue in the workflow's repository, but the run_if_label_matches job will only execute if the label is named bug .","on:
  issues:
    types:
      - labeled

jobs:
  run_if_label_matches:
    if: github.event.label.name == 'bug'
    runs-on: ubuntu-latest
    steps:
      - run: echo 'The label was bug'","jobs:
  run_if_label_matches:
    runs-on: ubuntu-latest
    if: github.event.label.name == 'bug'
    steps:
      - name: Run a script
        run: echo ""The 'bug' label was added to an issue.""
",0
1230,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Further controlling how your workflow will run - Using conditionals - Example using event type,"If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run. You can use conditionals to further control whether jobs or steps in your workflow will run. For example, if you want to run different jobs or steps depending on what event triggered the workflow, you can use a conditional to check whether a specific event type exists in the event context. The following workflow will run whenever an issue or pull request is closed. If the workflow ran because an issue was closed, the github.event context will contain a value for issue but not for pull_request . Therefore, the if_issue step will run but the if_pr step will not run. Conversely, if the workflow ran because a pull request was closed, the if_pr step will run but the if_issue step will not run.","on:
  issues:
    types:
      - closed
  pull_request:
    types:
      - closed

jobs:
  state_event_type:
    runs-on: ubuntu-latest
    steps:
    - name: if_issue
      if: github.event.issue
      run: |
        echo An issue was closed
    - name: if_pr
      if: github.event.pull_request
      run: |
        echo A pull request was closed","jobs:
  conditional-job:
    runs-on: ubuntu-latest
    steps:
      - name: if_issue
        if: ${{ github.event.issue }}
        run: echo ""An issue was closed.""
      - name: if_pr
        if: ${{ github.event.pull_request }}
        run: echo ""A pull request was closed.""
",0
1231,https://docs.github.com/en/actions/using-workflows/triggering-a-workflow,Triggering a workflow - Further controlling how your workflow will run - Using environments to manually trigger workflow jobs,"If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run. If you want to manually trigger a specific job in a workflow, you can use an environment that requires approval from a specific team or user. First, configure an environment with required reviewers. For more information, see Managing environments for deployment . Then, reference the environment name in a job in your workflow using the environment: key. Any job referencing the environment will not run until at least one reviewer approves the job. For example, the following workflow will run whenever there is a push to main. The build job will always run. The publish job will only run after the build job successfully completes (due to needs: [build] ) and after all of the rules (including required reviewers) for the environment called production pass (due to environment: production ).","on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: build
        run: |
          echo 'building'

  publish:
    needs: [build]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: publish
        run: |
          echo 'publishing'","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Building the project""

  publish:
    runs-on: ubuntu-latest
    needs: [build]
    environment: production
    steps:
      - run: echo ""Publishing the project""
",0
1232,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:","permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout","permissions:
  id-token: write
jobs:
  request-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Request secret from Vault
        uses: hashicorp/vault-action@v2
        with:
          url: ${{ secrets.VAULT_URL }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          path: secret/data/myapp
",0
1233,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Adding permissions settings,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. The job or workflow run requires a permissions setting with id-token: write to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the permissions for id-token is not set to write , however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect . The id-token: write setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches: If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example: If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:","permissions:
  id-token: write # This is required for requesting the JWT","permissions:
  id-token: write

jobs:
  request-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Request secret from Vault
        uses: hashicorp/vault-action@v2.4.0
        with:
          url: https://vault.example.com
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: secret/data/myapp/config
",0
1234,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Requesting the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. The hashicorp/vault-action action receives a JWT from the GitHub OIDC provider, and then requests an access token from your HashiCorp Vault instance to retrieve secrets. For more information, see the HashiCorp Vault GitHub Action documentation . This example demonstrates how to create a job that requests a secret from HashiCorp Vault.","jobs:
  retrieve-secret:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Retrieve secret from Vault
        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b
        with:
          method: jwt
          url: VAULT-URL
          namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only
          role: ROLE-NAME
          secrets: SECRET-PATH

      - name: Use secret from Vault
        run: |
          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.","jobs:
  request-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Configure OIDC
        uses: hashicorp/vault-action@v2
        with:
          method: jwt
          role: my-role
          url: https://my-vault-instance.com
          secrets: secret/data/my-secret
",0
1235,https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault,Configuring OpenID Connect in HashiCorp Vault - Updating your GitHub Actions workflow - Revoking the access token,"To update your workflows for OIDC, you will need to make two changes to your YAML: Note  When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment. Note When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment . To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes: This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault. By default, the Vault server will automatically revoke access tokens when their TTL is expired, so you don't have to manually revoke the access tokens. However, if you do want to revoke access tokens immediately after your job has completed or failed, you can manually revoke the issued token using the Vault API .","jobs:
  retrieve-secret:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Retrieve secret from Vault
        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b
        with:
          exportToken: true
          method: jwt
          url: VAULT-URL
          role: ROLE-NAME
          secrets: SECRET-PATH

      - name: Use secret from Vault
        run: |
          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.

      - name: Revoke token
        # This step always runs at the end regardless of the previous steps result
        if: always()
        run: |
          curl -X POST -sv -H ""X-Vault-Token: ${{ env.VAULT_TOKEN }}"" \
            VAULT-URL/v1/auth/token/revoke-self","jobs:
  oidc-vault:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Authenticate with Vault using OIDC
        id: oidc-auth
        uses: hashicorp/vault-action@v2
        with:
          method: oidc
          role: my-role
          oidc_token: ${{ secrets.GITHUB_TOKEN }}
          vault_address: https://vault.example.com

      - name: Request secret from Vault
        id: get-secret
        uses: hashicorp/vault-action@v2
        with:
          method: token
          token: ${{ steps.oidc-auth.outputs.token }}
          path: secret/data/my-secret
          field: my-field

      - name: Revoke Vault token
        run: |
          curl --request POST \
            --header ""X-Vault-Token: ${{ steps.oidc-auth.outputs.token }}"" \
            https://vault.example.com/v1/auth/token/revoke-self
",0
1236,https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows,Using OpenID Connect with reusable workflows - How the token works with reusable workflows,"During a workflow run, GitHub's OIDC provider presents a OIDC token to the cloud provider which contains information about the job. If that job is part of a reusable workflow, the token will include the standard claims that contain information about the calling workflow, and will also include a custom claim called job_workflow_ref that contains information about the called workflow. For example, the following OIDC token is for a job that was part of a called workflow. The workflow , ref , and other attributes describe the caller workflow, while job_workflow_ref refers to the called workflow:","{
  ""typ"": ""JWT"",
  ""alg"": ""RS256"",
  ""x5t"": ""example-thumbprint"",
  ""kid"": ""example-key-id""
}
{
  ""jti"": ""example-id"",
  ""sub"": ""repo:octo-org/octo-repo:environment:prod"",
  ""aud"": ""https://github.com/octo-org"",
  ""ref"": ""refs/heads/main"",
  ""sha"": ""example-sha"",
  ""repository"": ""octo-org/octo-repo"",
  ""repository_owner"": ""octo-org"",
  ""actor_id"": ""12"",
  ""repository_id"": ""74"",
  ""repository_owner_id"": ""65"",
  ""run_id"": ""example-run-id"",
  ""run_number"": ""10"",
  ""run_attempt"": ""2"",
  ""actor"": ""octocat"",
  ""workflow"": ""example-workflow"",
  ""head_ref"": """",
  ""base_ref"": """",
  ""event_name"": ""workflow_dispatch"",
  ""ref_type"": ""branch"",
  ""job_workflow_ref"": ""octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main"",
  ""iss"": ""https://token.actions.githubusercontent.com"",
  ""nbf"": 1632492967,
  ""exp"": 1632493867,
  ""iat"": 1632493567
}","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Authenticate with cloud provider
        id: auth
        uses: actions/oidc-auth@v1
        with:
          token: ${{ steps.auth.outputs.token }}
      - name: Call reusable workflow
        uses: owner/repo/.github/workflows/reusable-workflow.yml@main
        with:
          some_input: some_value
",0
1237,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-environments-for-deployment,Using environments for deployment - Using an environment in a workflow,"You can specify an environment for each job in your workflow. To do so, add a jobs.<job_id>.environment key followed by the name of the environment. For example, this workflow will use an environment called production .","name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy to production
        run: echo ""Deploying to production environment""
",0
1238,https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-environments-for-deployment,Using environments for deployment - Using an environment in a workflow,"You can specify an environment for each job in your workflow. To do so, add a jobs.<job_id>.environment key followed by the name of the environment. For example, this workflow will use an environment called production . When the above workflow runs, the deployment job will be subject to any rules configured for the production environment. For example, if the environment requires reviewers, the job will pause until one of the reviewers approves the job. You can also specify a URL for the environment. The specified URL will appear on the deployments page for the repository (accessed by clicking Environments on the home page of your repository) and in the visualization graph for the workflow run. If a pull request triggered the workflow, the URL is also displayed as a View deployment button in the pull request timeline. When using the ""Require deployments to succeed before merging"" rule, only the name specified is being checked even if a URL has also been specified. See About protected branches .","name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://github.com
    steps:
      - name: deploy
        # ...deployment-specific steps","jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com/deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Deploy
        run: echo ""Deploying to production""
",0
1239,https://docs.github.com/en/actions/using-workflows/about-workflows,About workflows - Advanced workflow features - Storing secrets,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your workflows use sensitive data, such as passwords or certificates, you can save these in GitHub as secrets and then use them in your workflows as environment variables. This means that you will be able to create and share workflows without having to embed sensitive values directly in the workflow's YAML source. This example job demonstrates how to reference an existing secret as an environment variable, and send it as a parameter to an example command.","jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Retrieve secret
        env:
          super_secret: ${{ secrets.SUPERSECRET }}
        run: |
          example-command ""$super_secret""","jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Use secret
        run: echo ""Using secret""
        env:
          MY_SECRET: ${{ secrets.MY_SECRET }}
",0
1240,https://docs.github.com/en/actions/using-workflows/about-workflows,About workflows - Advanced workflow features - Creating dependent jobs,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. By default, the jobs in your workflow all run in parallel at the same time. If you have a job that must only run after another job has completed, you can use the needs keyword to create this dependency. If one of the jobs fails, all dependent jobs are skipped; however, if you need the jobs to continue, you can define this using the if conditional statement. In this example, the setup , build , and test jobs run in series, with build and test being dependent on the successful completion of the job that precedes them:","jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: ./setup_server.sh
  build:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - run: ./build_server.sh
  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: ./test_server.sh","jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Setting up environment""

  build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - run: echo ""Building the application""

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo ""Running tests""
",0
1241,https://docs.github.com/en/actions/using-workflows/about-workflows,About workflows - Advanced workflow features - Using a matrix,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. The matrix is created using the strategy keyword, which receives the build options as an array. For example, this matrix will run the job multiple times, using different versions of Node.js:","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [12, 14, 16]
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - run: npm test
",0
1242,https://docs.github.com/en/actions/using-workflows/about-workflows,About workflows - Advanced workflow features - Caching dependencies,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your jobs regularly reuse dependencies, you can consider caching these files to help improve performance. Once the cache is created, it is available to all workflows in the same repository. This example demonstrates how to cache the ~/.npm directory:","jobs:
  example-job:
    steps:
      - name: Cache node modules
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache NPM dependencies
        uses: actions/cache@v2
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-
      - name: Install dependencies
        run: npm install
",0
1243,https://docs.github.com/en/actions/using-workflows/about-workflows,About workflows - Advanced workflow features - Using databases and service containers,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If your job requires a database or cache service, you can use the services keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can use services to create a postgres container, and then use node to connect to the service.","jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node:20-bookworm-slim
    services:
      postgres:
        image: postgres
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: npm ci
      - name: Connect to PostgreSQL
        run: node client.js
        env:
          POSTGRES_HOST: postgres
          POSTGRES_PORT: 5432","jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:latest
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run database script
        env:
          PGHOST: localhost
          PGUSER: postgres
          PGPASSWORD: postgres
          PGDATABASE: postgres
        run: node script.js
",0
1244,https://docs.github.com/en/actions/using-workflows/about-workflows,About workflows - Advanced workflow features - Using labels to route workflows,"This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows. If you want to be sure that a particular type of runner will process your job, you can use labels to control where jobs are executed. You can assign labels to a self-hosted runner in addition to their default label of self-hosted . Then, you can refer to these labels in your YAML workflow, ensuring that the job is routed in a predictable way. GitHub-hosted runners have predefined labels assigned. This example shows how a workflow can use labels to specify the required runner:","jobs:
  example-job:
    runs-on: [self-hosted, linux, x64, gpu]","jobs:
  example-job:
    runs-on: [self-hosted, custom-label]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Running on a self-hosted runner with a custom label""
",0
1245,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift,Building and testing Swift - Specifying a Swift version - Using multiple Swift versions,"To use a specific preinstalled version of Swift on a GitHub-hosted runner, use the swift-actions/setup-swift action. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries to PATH . These changes will persist for the remainder of a job. For more information, see the swift-actions/setup-swift action. If you are using a self-hosted runner, you must install your desired Swift versions and add them to PATH . The examples below demonstrate using the swift-actions/setup-swift action. You can configure your job to use multiple versions of Swift in a matrix.","# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Swift

on: [push]

jobs:
  build:
    name: Swift ${{ matrix.swift }} on ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        swift: [""5.2"", ""5.3""]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf
        with:
          swift-version: ${{ matrix.swift }}
      - uses: actions/checkout@v4
      - name: Build
        run: swift build
      - name: Run tests
        run: swift test","jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        swift: ['5.3', '5.4', '5.5']
    steps:
      - uses: actions/checkout@v2
      - uses: swift-actions/setup-swift@v1
        with:
          swift-version: ${{ matrix.swift }}
      - run: swift build
      - run: swift test
",0
1246,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift,Building and testing Swift - Specifying a Swift version - Using a single specific Swift version,"To use a specific preinstalled version of Swift on a GitHub-hosted runner, use the swift-actions/setup-swift action. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries to PATH . These changes will persist for the remainder of a job. For more information, see the swift-actions/setup-swift action. If you are using a self-hosted runner, you must install your desired Swift versions and add them to PATH . The examples below demonstrate using the swift-actions/setup-swift action. You can configure your job to use a single specific version of Swift, such as 5.3.3 .","steps:
  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf
    with:
      swift-version: ""5.3.3""
  - name: Get swift version
    run: swift --version # Swift 5.3.3","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: swift-actions/setup-swift@v1
        with:
          swift-version: '5.3.3'
      - run: swift build
      - run: swift test
",0
1247,https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift,Building and testing Swift - Building and testing your code,You can use the same commands that you use locally to build and test your code using Swift. This example demonstrates how to use swift build and swift test in a job:,"steps:
  - uses: actions/checkout@v4
  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf
    with:
      swift-version: ""5.3.3""
  - name: Build
    run: swift build
  - name: Run tests
    run: swift test","jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Swift
        uses: fwal/setup-swift@v1
      - name: Build
        run: swift build
      - name: Test
        run: swift test
",0
1248,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - branch_protection_rule,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, see About protected branches . For information about the branch protection rule APIs, see Objects in the GraphQL API documentation or REST API endpoints for branches and their settings . For example, you can run a workflow when a branch protection rule has been created or deleted :","on:
  branch_protection_rule:
    types: [created, deleted]","on:
  branch_protection_rule:
    types: [created, deleted]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1249,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - check_run,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, see Using the REST API to interact with checks . For information about the check run APIs, see Objects in the GraphQL API documentation or REST API endpoints for check runs . For example, you can run a workflow when a check run has been rerequested or completed .","on:
  check_run:
    types: [rerequested, completed]","on:
  check_run:
    types: [rerequested, completed]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Check run triggered""
",0
1250,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - check_suite,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. Although only thecompletedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . Although only the completed activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions. To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions. Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, see Using the REST API to interact with checks . For information about the check suite APIs, see Objects in the GraphQL API documentation or REST API endpoints for check suites . For example, you can run a workflow when a check suite has been completed .","on:
  check_suite:
    types: [completed]","on:
  check_suite:
    types: [completed]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1251,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - create,"Note  An event will not be created when you create more than three tags at once. Note An event will not be created when you create more than three tags at once. Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references . For example, you can run a workflow when the create event occurs.","on:
  create","on:
  create:
    branches:
      - '*'
    tags:
      - '*'
jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1252,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - delete,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Note  An event will not be created when you delete more than three tags at once. An event will not be created when you delete more than three tags at once. Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references . For example, you can run a workflow when the delete event occurs.","on:
  delete","on: 
  delete:
jobs:
  run-on-delete:
    runs-on: ubuntu-latest
    steps:
      - name: Run a script
        run: echo ""A Git reference was deleted.""
",0
1253,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - deployment,"Runs your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, see Mutations in the GraphQL API documentation or REST API endpoints for repositories . For example, you can run a workflow when the deployment event occurs.","on:
  deployment","on:
  deployment:

jobs:
  deployment_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run deployment script
        run: echo ""Deployment triggered""
",0
1254,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - deployment_status,"Note  When a deployment status's state is set toinactive, a workflow run will not be triggered. Note When a deployment status's state is set to inactive , a workflow run will not be triggered. Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, see Mutations in the GraphQL API documentation or REST API endpoints for deployments . For example, you can run a workflow when the deployment_status event occurs.","on:
  deployment_status","on:
  deployment_status:

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1255,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - discussion,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  Webhook events for GitHub Discussions are currently in public preview and subject to change. Webhook events for GitHub Discussions are currently in public preview and subject to change. Runs your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use the discussion_comment event. For more information about discussions, see About discussions . For information about the GraphQL API, see Objects . For example, you can run a workflow when a discussion has been created , edited , or answered .","on:
  discussion:
    types: [created, edited, answered]","on:
  discussion:
    types: [created, edited, answered]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
",0
1256,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - discussion_comment,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  Webhook events for GitHub Discussions are currently in public preview and subject to change. Webhook events for GitHub Discussions are currently in public preview and subject to change. Runs your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the discussion event. For more information about discussions, see About discussions . For information about the GraphQL API, see Objects . For example, you can run a workflow when a discussion comment has been created or deleted .","on:
  discussion_comment:
    types: [created, deleted]","on:
  discussion_comment:
    types: [created, edited]

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
1257,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - fork,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when someone forks a repository. For information about the REST API, see REST API endpoints for forks . For example, you can run a workflow when the fork event occurs.","on:
  fork","on:
  fork:
jobs:
  run-on-fork:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
",0
1258,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - gollum,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when someone creates or updates a Wiki page. For more information, see About wikis . For example, you can run a workflow when the gollum event occurs.","on:
  gollum","on: 
  gollum:
jobs:
  wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Run a script
        run: echo ""A Wiki page was created or updated.""
",0
1259,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - issue_comment,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see Objects in the GraphQL API documentation or Webhook events and payloads in the REST API documentation. For example, you can run a workflow when an issue or pull request comment has been created or deleted .","on:
  issue_comment:
    types: [created, deleted]","on:
  issue_comment:
    types: [created, deleted]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
1260,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - issue_comment - issue_comment on issues only or pull requests only,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see Objects in the GraphQL API documentation or Webhook events and payloads in the REST API documentation. For example, you can run a workflow when an issue or pull request comment has been created or deleted . The issue_comment event occurs for comments on both issues and pull requests. You can use the github.event.issue.pull_request property in a conditional to take different action depending on whether the triggering object was an issue or pull request. For example, this workflow will run the pr_commented job only if the issue_comment event originated from a pull request. It will run the issue_commented job only if the issue_comment event originated from an issue.","on: issue_comment

jobs:
  pr_commented:
    # This job only runs for pull request comments
    name: PR comment
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on PR $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}

  issue_commented:
    # This job only runs for issue comments
    name: Issue comment
    if: ${{ !github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on issue $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}","on:
  issue_comment:
    types: [created, deleted]

jobs:
  pr_commented:
    if: github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Comment on a pull request""

  issue_commented:
    if: ""!github.event.issue.pull_request""
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Comment on an issue""
",0
1261,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - issues,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use the issue_comment event. For more information about issues, see About issues . For information about the issue APIs, see Objects in the GraphQL API documentation or REST API endpoints for issues . For example, you can run a workflow when an issue has been opened , edited , or milestoned .","on:
  issues:
    types: [opened, edited, milestoned]","on:
  issues:
    types: [opened, edited, milestoned]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
",0
1262,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - label,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when a label in your workflow's repository is created or modified. For more information about labels, see Managing labels . For information about the label APIs, see Objects in the GraphQL API documentation or REST API endpoints for labels . If you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use the labeled or unlabeled activity types for the issues , pull_request , pull_request_target , or discussion events instead. For example, you can run a workflow when a label has been created or deleted .","on:
  label:
    types: [created, deleted]","on:
  label

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1263,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - merge_group,"Note    More than one activity type triggers this event. Although only thechecks_requestedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.If your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include themerge_groupevent as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. Themerge_groupevent is separate from thepull_requestandpushevents. Note Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information see Merging a pull request with a merge queue . For example, you can run a workflow when the checks_requested activity has occurred.","on:
  pull_request:
    branches: [ ""main"" ]
  merge_group:
    types: [checks_requested]","on:
  merge_group:
    types: [checks_requested]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
1264,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - milestone,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, see About milestones . For information about the milestone APIs, see Objects in the GraphQL API documentation or REST API endpoints for milestones . If you want to run your workflow when an issue is added to or removed from a milestone, use the milestoned or demilestoned activity types for the issues event instead. For example, you can run a workflow when a milestone has been opened or deleted .","on:
  milestone:
    types: [opened, deleted]","on:
  milestone:
    types: [created, edited, closed, opened, deleted]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1265,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - page_build,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, see Configuring a publishing source for your GitHub Pages site . For information about the REST API, see REST API endpoints for repositories . For example, you can run a workflow when the page_build event occurs.","on:
  page_build","on:
  page_build:
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Run a script
        run: echo ""Page build event triggered""
",0
1266,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - public,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when your workflow's repository changes from private to public. For information about the REST API, see REST API endpoints for repositories . For example, you can run a workflow when the public event occurs.","on:
  public","on:
  public:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Repository is now public!""
",0
1267,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened.","on:
  pull_request:
    types: [opened, reopened]","on:
  pull_request:
    types: [opened, reopened]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
1268,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested.","on:
  pull_request:
    types: [review_requested]
jobs:
  specific_review_requested:
    runs-on: ubuntu-latest
    if: ${{ github.event.requested_team.name == 'octo-team'}}
    steps:
      - run: echo 'A review from octo-team was requested'","on:
  pull_request:
    types:
      - review_requested

jobs:
  specific_review_requested:
    if: github.event.requested_reviewer.login == 'octo-team'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1269,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on the head or base branch of a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'","on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches:
      - 'releases/**'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1270,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on the head or base branch of a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo Hello, world!
",0
1271,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on the head or base branch of a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ : To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo ""The head of this PR starts with 'releases/'""","on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'

jobs:
  run_if:
    runs-on: ubuntu-latest
    if: startsWith(github.head_ref, 'releases/')
    steps:
      - run: echo ""Running job for releases/* branch with .js file changes""
",0
1272,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on files changed in a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can also configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ):","on:
  pull_request:
    paths:
      - '**.js'","on:
  pull_request:
    paths:
      - '**.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""JavaScript file changed""
",0
1273,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow based on files changed in a pull request,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. You can also configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ): Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**.js'
",0
1274,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request - Running your pull_request workflow when a pull request merges,"Note    More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main. Note Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review , pull_request_review_comment , or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead. For example, you can run a workflow when a pull request has been opened or reopened. You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested. When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request  closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.","on:
  pull_request:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged","on:
  pull_request:
    types: [closed]

jobs:
  if_merged:
    runs-on: ubuntu-latest
    steps:
      - name: Check if merged
        if: github.event.pull_request.merged == true
        run: echo ""The pull request was merged.""
",0
1275,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_review,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the pull_request_review_comment or issue_comment events instead. For information about the pull request review APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . For example, you can run a workflow when a pull request review has been edited or dismissed .","on:
  pull_request_review:
    types: [edited, dismissed]","on:
  pull_request_review:
    types: [submitted, edited, dismissed]
",0
1276,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_review - Running a workflow when a pull request is approved,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the pull_request_review_comment or issue_comment events instead. For information about the pull request review APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . For example, you can run a workflow when a pull request review has been edited or dismissed . To run your workflow when a pull request has been approved, you can trigger your workflow with the submitted type of pull_request_review event, then check the review state with the github.event.review.state property. For example, this workflow will run whenever a pull request review is submitted, but the approved job will only run if the submitted review is an approving review:","on:
  pull_request_review:
    types: [submitted]

jobs:
  approved:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - run: echo ""This PR was approved""","on:
  pull_request_review:
    types: [submitted]

jobs:
  approved:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Approved action
        run: echo ""Pull request approved""
",0
1277,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_review_comment,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use the pull_request_review or issue_comment events instead. For information about the pull request review comment APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests . For example, you can run a workflow when a pull request review comment has been created or deleted .","on:
  pull_request_review_comment:
    types: [created, deleted]","on:
  pull_request_review_comment:
    types: [edited]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
1278,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened .","on:
  pull_request_target:
    types: [assigned, opened, synchronize, reopened]","on:
  pull_request_target:
    types: [assigned, opened, synchronize, reopened]
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1279,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on the head or base branch of a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'","on:
  pull_request_target:
    branches:
      - 'releases/**'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
",0
1280,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on the head or base branch of a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request_target:
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1281,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on the head or base branch of a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/ : Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ : To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo ""The head of this PR starts with 'releases/'""","on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    branches:
      - 'releases/**'
    paths:
      - '**/*.js'

jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
",0
1282,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on files changed in a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the paths or paths-ignore filter to configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ):","on:
  pull_request_target:
    paths:
      - '**.js'","on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    paths:
      - '**/*.js'

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1283,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow based on files changed in a pull request,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . You can use the paths or paths-ignore filter to configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when a pull request includes a change to a JavaScript file ( .js ): Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( .js ) file is opened on a branch whose name starts with releases/ :","on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    paths:
      - '**/*.js'
    branches:
      - 'releases/**'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1284,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - pull_request_target - Running your pull_request_target workflow when a pull request merges,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, a workflow only runs when a pull_request_target event's activity type is opened , synchronize , or reopened . To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions . Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request. To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event. Warning  For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website. Warning For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website. For example, you can run a workflow when a pull request has been assigned , opened , synchronize , or reopened . When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request_target  closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.","on:
  pull_request_target:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged","on:
  pull_request_target:
    types: [closed]

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Run actions on merged pull request
        run: echo ""Pull request has been merged.""
",0
1285,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - push,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs.","on:
  push","on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run a one-line script
        run: echo ""Hello, world!""
",0
1286,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push to specific branches occurs,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the branches or branches-ignore filter to configure your workflow to only run when specific branches are pushed. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes to main or to a branch that starts with releases/ .","on:
  push:
    branches:
      - 'main'
      - 'releases/**'","on:
  push:
    branches:
      - main
      - 'releases/**'
",0
1287,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push to specific branches occurs,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the branches or branches-ignore filter to configure your workflow to only run when specific branches are pushed. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes to main or to a branch that starts with releases/ . Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript ( .js ) file is made to a branch whose name starts with releases/ :","on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  push:
    branches:
      - main
      - 'releases/*'
    paths:
      - '**.js'
",0
1288,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push of specific tags occurs,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the tags or tags-ignore filter to configure your workflow to only run when specific tags are pushed. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes a tag that starts with v1. .","on:
  push:
    tags:
      - v1.**","on:
  push:
    tags:
      - 'v1.*'
",0
1289,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push affects specific files,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the paths or paths-ignore filter to configure your workflow to run when a push to specific files occurs. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes a change to a JavaScript file ( .js ):","on:
  push:
    paths:
      - '**.js'","on:
  push:
    paths:
      - '**/*.js'
",0
1290,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - push - Running your workflow only when a push affects specific files,"Note  The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits. Note The webhook payload available to GitHub Actions does not include the added , removed , and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits . Note  Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once. Runs your workflow when you push a commit or tag, or when you create a repository from a template. For example, you can run a workflow when the push event occurs. Note  When apushwebhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. When a push webhook event triggers a workflow run, the Actions UI's ""pushed by"" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the ""pushed by"" field will be the repository admin who verified the deploy key when it was added it to a repository. You can use the paths or paths-ignore filter to configure your workflow to run when a push to specific files occurs. For more information, see Workflow syntax for GitHub Actions . For example, this workflow will run when someone pushes a change to a JavaScript file ( .js ): Note  If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts withreleases/: If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript ( .js ) file is made to a branch whose name starts with releases/ :","on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'","on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
",0
1291,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - registry_package,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional: When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:","jobs:
    job_name:
        if: $true","on:
  registry_package

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1292,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - registry_package,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional: When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional: Runs your workflow when activity related to GitHub Packages occurs in your repository. For more information, see GitHub Packages Documentation . For example, you can run a workflow when a new package version has been published .","on:
  registry_package:
    types: [published]","on:
  registry_package

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1293,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - release,"Note  More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  Workflows are not triggered for thecreated,edited, ordeletedactivity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft. Workflows are not triggered for the created , edited , or deleted activity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft. Note  Theprereleasedtype will not trigger for pre-releases published from draft releases, but thepublishedtype will trigger. If you want a workflow to run when stableandpre-releases publish, subscribe topublishedinstead ofreleasedandprereleased. The prereleased type will not trigger for pre-releases published from draft releases, but the published type will trigger. If you want a workflow to run when stable and pre-releases publish, subscribe to published instead of released and prereleased . Runs your workflow when release activity in your repository occurs. For information about the release APIs, see Objects in the GraphQL API documentation or REST API endpoints for releases and release assets in the REST API documentation. For example, you can run a workflow when a release has been published .","on:
  release:
    types: [published]","on:
  release:
    types: [published]
",0
1294,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - repository_dispatch,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. You can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see REST API endpoints for repositories . When you make a request to create a repository_dispatch event, you must specify an event_type to describe the activity type. By default, all repository_dispatch activity types trigger a workflow to run. You can use the types keyword to limit your workflow to run when a specific event_type value is sent in the repository_dispatch webhook payload.","on:
  repository_dispatch:
    types: [test_result]","on:
  repository_dispatch:
    types:
      - my_event_type

jobs:
  my_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1295,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - repository_dispatch,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. You can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see REST API endpoints for repositories . When you make a request to create a repository_dispatch event, you must specify an event_type to describe the activity type. By default, all repository_dispatch activity types trigger a workflow to run. You can use the types keyword to limit your workflow to run when a specific event_type value is sent in the repository_dispatch webhook payload. Note  Theevent_typevalue is limited to 100 characters. The event_type value is limited to 100 characters. Any data that you send through the client_payload parameter will be available in the github.event context in your workflow. For example, if you send this request body when you create a repository dispatch event: then you can access the payload in a workflow like this:","on:
  repository_dispatch:
    types: [test_result]

jobs:
  run_if_failure:
    if: ${{ !github.event.client_payload.passed }}
    runs-on: ubuntu-latest
    steps:
      - env:
          MESSAGE: ${{ github.event.client_payload.message }}
        run: echo $MESSAGE","on:
  repository_dispatch:
    types: [your_event_type]

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Print event payload
        run: echo ""${{ toJson(github.event.client_payload) }}""
",0
1296,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - schedule,"Note    Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.This event will only trigger a workflow run if the workflow file is on the default branch.Scheduled workflows will only run on the default branch.In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example: Note The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. This event will only trigger a workflow run if the workflow file is on the default branch. Scheduled workflows will only run on the default branch. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow . For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor . Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located. Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows. For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change. Example:","on:
  schedule:
    - cron: ""15 4,5 * * *""   # <=== Change this value","on:
  schedule:
    - cron: '15 3 * * *'
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Hello, World!""
",0
1297,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - schedule,"Note    Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.This event will only trigger a workflow run if the workflow file is on the default branch.Scheduled workflows will only run on the default branch.In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example: Note The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. This event will only trigger a workflow run if the workflow file is on the default branch. Scheduled workflows will only run on the default branch. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow . For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor . Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located. Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows. For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change. Example: The schedule event allows you to trigger a workflow at a scheduled time. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC:","on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'","on:
  schedule:
    - cron: '30 5,17 * * *'
",0
1298,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - schedule,"Note    Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.This event will only trigger a workflow run if the workflow file is on the default branch.Scheduled workflows will only run on the default branch.In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example: Note The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. This event will only trigger a workflow run if the workflow file is on the default branch. Scheduled workflows will only run on the default branch. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow . For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor . Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located. Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows. For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change. Example: The schedule event allows you to trigger a workflow at a scheduled time. You can schedule a workflow to run at specific UTC times using POSIX cron syntax . Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. This example triggers the workflow every day at 5:30 and 17:30 UTC: A single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.","on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo ""This step will be skipped on Monday and Wednesday""
      - name: Every time
        run: echo ""This step will always run""","on:
  schedule:
    - cron: '30 5,17 * * *'
    - cron: '30 5 * * 1-4'

jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - name: Run on Monday and Wednesday
        if: ""!contains(github.event.schedule, 'Mon') && !contains(github.event.schedule, 'Wed')""
        run: echo ""Not on Monday or Wednesday""
",0
1299,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - status,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when the status of a Git commit changes. For example, commits can be marked as error , failure , pending , or success . If you want to provide more details about the status change, you may want to use the check_run event. For information about the commit status APIs, see Objects in the GraphQL API documentation or REST API endpoints for commits . For example, you can run a workflow when the status event occurs.","on:
  status","on:
  status

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Status event triggered""
",0
1300,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - status,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when the status of a Git commit changes. For example, commits can be marked as error , failure , pending , or success . If you want to provide more details about the status change, you may want to use the check_run event. For information about the commit status APIs, see Objects in the GraphQL API documentation or REST API endpoints for commits . For example, you can run a workflow when the status event occurs. If you want to run a job in your workflow based on the new commit state, you can use the github.event.state context. For example, the following workflow triggers when a commit status changes, but the if_error_or_failure job only runs if the new commit state is error or failure .","on:
  status
jobs:
  if_error_or_failure:
    runs-on: ubuntu-latest
    if: >-
      github.event.state == 'error' ||
      github.event.state == 'failure'
    steps:
      - env:
          DESCRIPTION: ${{ github.event.description }}
        run: |
          echo The status is error or failed: $DESCRIPTION","on:
  status

jobs:
  if_error_or_failure:
    runs-on: ubuntu-latest
    if: github.event.state == 'error' || github.event.state == 'failure'
    steps:
      - run: echo ""Commit status is error or failure""
",0
1301,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - watch,"Note  More than one activity type triggers this event. Although only thestartedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. Although only the started activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Runs your workflow when the workflow's repository is starred. For information about the pull request APIs, see Mutations in the GraphQL API documentation or REST API endpoints for starring . For example, you can run a workflow when someone stars a repository, which is the started activity type for a watch event.","on:
  watch:
    types: [started]","on:
  watch:
    types: [started]
jobs:
  run-on-star:
    runs-on: ubuntu-latest
    steps:
      - name: Print a message
        run: echo ""Repository starred!""
",0
1302,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_call,"workflow_call is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the workflow_call event, the event payload in the called workflow is the same event payload from the calling workflow. For more information see, Reusing workflows . The example below only runs the workflow when it's called from another workflow:",on: workflow_call,"on:
  workflow_call:
",0
1303,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_dispatch,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see Manually running a workflow .",on: workflow_dispatch,"on:
  workflow_dispatch:
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1304,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_dispatch - Providing inputs,"Note  This event will only trigger a workflow run if the workflow file exists on the default branch. Note This event will only trigger a workflow run if the workflow file exists on the default branch. To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see Manually running a workflow . You can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the ref and any inputs . When the workflow runs, you can access the input values in the inputs context. For more information, see Accessing contextual information about workflow runs . Note    The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.The maximum number of top-level properties forinputsis 10.The maximum payload forinputsis 65,535 characters. This example defines inputs called logLevel , tags , and environment . You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using the inputs.logLevel , inputs.tags , and inputs.environment context properties.","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug
      tags:
        description: 'Test scenario tags'
        required: false
        type: boolean
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  log-the-inputs:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo ""Log level: $LEVEL""
          echo ""Tags: $TAGS""
          echo ""Environment: $ENVIRONMENT""
        env:
          LEVEL: ${{ inputs.logLevel }}
          TAGS: ${{ inputs.tags }}
          ENVIRONMENT: ${{ inputs.environment }}","on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'info'
      tags:
        description: 'Tags'
        required: false
      environment:
        description: 'Environment'
        required: true
        default: 'production'

jobs:
  print-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Print inputs
        run: |
          echo ""Log Level: ${{ inputs.logLevel }}""
          echo ""Tags: ${{ inputs.tags }}""
          echo ""Environment: ${{ inputs.environment }}""
",0
1305,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_run,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes.","on:
  workflow_run:
    workflows: [Run Tests]
    types:
      - completed","on:
  workflow_run:
    workflows: [""Run Tests""]
    types:
      - completed

jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1306,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_run,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes.","on:
  workflow_run:
    workflows: [Staging, Lab]
    types:
      - completed","on:
  workflow_run:
    workflows: [""Run Tests""]
    types:
      - completed
jobs:
  example_job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1307,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Running a workflow based on the conclusion of another workflow,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. A workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with the github.event.workflow_run.conclusion property. For example, this workflow will run whenever a workflow named ""Build"" completes, but the on-success job will only run if the ""Build"" workflow succeeded, and the on-failure job will only run if the ""Build"" workflow failed:","on:
  workflow_run:
    workflows: [Build]
    types: [completed]

jobs:
  on-success:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - run: echo 'The triggering workflow passed'
  on-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - run: echo 'The triggering workflow failed'","on:
  workflow_run:
    workflows: [""Build""]
    types: [completed]

jobs:
  on-success:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Build succeeded!""

  on-failure:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo ""Build failed!""
",0
1308,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Limiting your workflow to run based on branches,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. You can use the branches or branches-ignore filter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, see Workflow syntax for GitHub Actions . For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch named canary .","on:
  workflow_run:
    workflows: [Build]
    types: [requested]
    branches: [canary]","on:
  workflow_run:
    workflows: [""Run Tests""]
    types: [completed]
    branches: [canary]
",0
1309,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Using data from the triggering workflow,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. You can access the workflow_run event payload that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the workflow_run event can access these artifacts. The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)","name: Upload data

on:
  pull_request:

jobs:
  upload:
    runs-on: ubuntu-latest

    steps:
      - name: Save PR number
        env:
          PR_NUMBER: ${{ github.event.number }}
        run: |
          mkdir -p ./pr
          echo $PR_NUMBER > ./pr/pr_number
      - uses: actions/upload-artifact@v4
        with:
          name: pr_number
          path: pr/","on:
  workflow_run:
    workflows: [""Run Tests""]
    types:
      - completed

jobs:
  upload-artifact:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Upload pull request number
        run: echo ${{ github.event.workflow_run.pull_requests[0].number }} > pr-number.txt
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: pull-request-number
          path: pr-number.txt
",0
1310,https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows,Events that trigger workflows - workflow_run - Using data from the triggering workflow,"Note  More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions. Note More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads . By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions . Note  This event will only trigger a workflow run if the workflow file exists on the default branch. This event will only trigger a workflow run if the workflow file exists on the default branch. Note  You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:ABCDEF), workflowsEandFwill not be run. You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F ) to run sequentially after an initial workflow A has run (that is: A  B  C  D  E  F ), workflows E and F will not be run. This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow. In this example, a workflow is configured to run after the separate ""Run Tests"" workflow completes. If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the ""Staging"" workflow or the ""Lab"" workflow completes. You can access the workflow_run event payload that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the workflow_run event can access these artifacts. The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.) When a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses the github.event.workflow_run context and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact.","name: Use the data

on:
  workflow_run:
    workflows: [Upload data]
    types:
      - completed

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: 'Download artifact'
        uses: actions/github-script@v7
        with:
          script: |
            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: context.payload.workflow_run.id,
            });
            let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => {
              return artifact.name == ""pr_number""
            })[0];
            let download = await github.rest.actions.downloadArtifact({
               owner: context.repo.owner,
               repo: context.repo.repo,
               artifact_id: matchArtifact.id,
               archive_format: 'zip',
            });
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            if (!fs.existsSync(temp)){
              fs.mkdirSync(temp);
            }
            fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data));

      - name: 'Unzip artifact'
        run: unzip pr_number.zip -d ""${{ runner.temp }}/artifacts""

      - name: 'Comment on PR'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number')));
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: 'Thank you for the PR!'
            });","jobs:
  download-artifact:
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: pull-request-number

      - name: Unzip artifact
        run: unzip pull-request-number.zip

      - name: Comment on pull request
        uses: actions/github-script@v6
        with:
          script: |
            const prNumber = require('fs').readFileSync('pull-request-number.txt', 'utf8').trim();
            const { data: pullRequest } = await github.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            await github.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: 'Artifact processed and PR commented.'
            })
",0
1311,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Scheduling a pipeline to run with cron - Jenkins pipeline with cron,.,"pipeline {
  agent any
  triggers {
    cron('H/15 * * * 1-5')
  }
}","on:
  schedule:
    - cron: '0 0 * * *'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1312,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Scheduling a pipeline to run with cron - GitHub Actions workflow with cron,.,"on:
  schedule:
    - cron: '*/15 * * * 1-5'","on:
  schedule:
    - cron: '0 0 * * *'
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
",0
1313,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Configuring environment variables in a pipeline - Jenkins pipeline with an environment variable,.,"pipeline {
  agent any
  environment {
    MAVEN_PATH = '/usr/local/maven'
  }
}","jobs:
  build:
    runs-on: ubuntu-latest
    env:
      MY_ENV_VAR: 'value'
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run a script
        run: echo ""Environment variable is $MY_ENV_VAR""
",0
1314,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Configuring environment variables in a pipeline - GitHub Actions workflow with an environment variable,.,"jobs:
  maven-build:
    env:
      MAVEN_PATH: '/usr/local/maven'","jobs:
  example-job:
    runs-on: ubuntu-latest
    env:
      EXAMPLE_VARIABLE: example_value
    steps:
      - name: Print environment variable
        run: echo $EXAMPLE_VARIABLE
",0
1315,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Building from upstream projects - Jenkins pipeline that builds from an upstream project,.,"pipeline {
  triggers {
    upstream(
      upstreamProjects: 'job1,job2',
      threshold: hudson.model.Result.SUCCESS
    )
  }
}","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          java-version: '11'
      - name: Build with Maven
        run: mvn clean install
",0
1316,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Building from upstream projects - GitHub Actions workflow that builds from an upstream project,.,"jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]","jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout upstream repository
        uses: actions/checkout@v2
        with:
          repository: owner/upstream-repo
          ref: main

      - name: Checkout current repository
        uses: actions/checkout@v2
        with:
          path: current-repo

      - name: Build project
        run: |
          cd current-repo
          ./build-script.sh
",0
1317,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Building with multiple operating systems - Jenkins pipeline that builds with multiple operating systems,.,"pipeline {
  agent none
  stages {
    stage('Run Tests') {
      matrix {
        axes {
          axis {
            name: 'PLATFORM'
            values: 'macos', 'linux'
          }
        }
        agent { label ""${PLATFORM}"" }
        stages {
          stage('test') {
            tools { nodejs ""node-20"" }
            steps {
              dir(""scripts/myapp"") {
                sh(script: ""npm install -g bats"")
                sh(script: ""bats tests"")
              }
            }
          }
        }
      }
    }
  }
}","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Set up JDK 11
        uses: actions/setup-java@v2
        with:
          java-version: 11
      - name: Build with Gradle
        run: ./gradlew build
",0
1318,https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions,Migrating from Jenkins to GitHub Actions - Examples of common tasks - Building with multiple operating systems - GitHub Actions workflow that builds with multiple operating systems,.,"name: demo-workflow
on:
  push:
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, ubuntu-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install -g bats
      - run: bats tests
        working-directory: ./scripts/myapp","jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install
      - run: npm run build
",0